

# C语言

> <http://oj.haizeix.com/problem/70>

所谓丑数，就是素因子中只含有 2、3、52、3、5 的数字。给出一个数字 NN，请输出 NN 以内所有丑数。特别的规定，11 是第一个丑数。

+ 先除以2除到不能再除为止，除5，除到不能再除为止，除3，如果结果为1则是丑数，否则不是

~~~
#include<iostream>
using namespace std;
int ugly_num(int x) {
    while(x % 2 == 0) {
        x /= 2; 
    }
    while(x % 5 == 0) {
        x /= 5;
    }
    while(x % 3 == 0) {
        x /= 3;
    }
    if(x == 1) return 1;
    else  return 0;
    
}
int main() {
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++){
        if(ugly_num(i) == 1){
            cout << i << endl;
        }
    }
    return 0;
}
~~~

~~~
实现可变参数max_int从若干个传入的参数中返回最大值。
va一族
va_list 类型的变量 获得a往后的参数列表
va_start 函数 定位a后面第一个参数的位置
va_arg 函数  获取下一个可变参数列表中的参数
va_end 函数  结束整个获取可变参数列表的动作(⊙o⊙)…
#include<stdio.h>
#include<inttypes.h>
#include<stdarg.h> 
//                 可变参数列表
int max_int(int n, ...) {
    va_list arg;
    va_start(arg, n);
    int ans = INT32_MIN;//int ans = 0;
    while (n--) {
        int temp = va_arg(arg, int);
        temp > ans && (ans = temp);
    }
    va_end(arg);//销毁arg的变量
    return ans;
}
int main() {
    printf("%d\n", max_int(3, 3, 5, 16));
    printf("%d\n", max_int(3, 3, 5, 16, 21));
    printf("%d\n", max_int(4, 3, 5, 21, -32));
    return 0;
}
~~~

## 素数筛

> 课

- 素数筛是如何筛数的：
- 是用每一个素数来筛合数

```
#include<stdio.h>
#include<inttypes.h>
#define max_n 200000

int prime[max_n + 5] = {0};
void init() {
    for (int i = 2; i * i <= max_n; i++) {
        if (prime[i]) continue;
        //prime[++prime[0]] = i;<=>prime[0] += 1;prime[prime[0]] = i;
        for (int j = i * i; j <= max_n; j += i) {
            prime[j] = 1;
        }
    }
    for (int i = 2; i <= max_n; i++) {
        !prime[i]&& (prime[++prime[0]] = i);
    }
    return ;
}

int main() {
    init();
    printf("%d\n", prime[10001]);
    return 0;
}
```

![深度截图_选择区域_20191217202230](/home/unique/Desktop/%E6%B5%B7%E8%B4%BC/picture/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20191217202230.png)

- 线性筛是怎么筛数的：

- 找每个数（包括合数）的最小素因子，将其乘以所有小于等于它素因子的素数，即为该数可筛出的数，首先从2开始2的最小素因子为2，所以可以筛去4……如果是6最小素因子为2所以只能筛12，而的最小素因子为其本身故可以筛出14，21，35等

  ><https://projecteuler.net/problem=7>

```
线性筛代码（找到第10001个素数）欧拉7
#include<stdio.h>
#define max_n 200000

int prime[max_n + 5] = {0};

void init() {
    for (int i = 2; i <= max_n; i++) {
        if (!prime[i]) prime[++prime[0]] = i;
        for (int j = 1; j <= max_n; j++) {
            if (prime[j] * i > max_n) break;
            prime[prime[j] * i] = 1;
            if (i % prime[j] == 0) break;
        }
    }
    return ;
}
int main() {
    init();
    
    printf("%d\n", prime[10001]);
    return 0;
}
```

~~~
#include<stdio.h>
int is_prime(int x) {
    for (int i = 2; i * i <= x; i++) {
        if(x % i == 0 ) return 0;
    }
    return 1;
}

int main() {
    int num, prime_nums = 0;
    for (num = 2;prime_nums < 10001;num++) {
        prime_nums += is_prime(num);
    }
    printf("%d\n"), num;
    return 0;
}
~~~

## 线性筛

><http://oj.haizeix.com/problem/188>

~~~
#include<iostream> 
using namespace std;
#define max_n 2000000
int prime[max_n + 5];

void init() {
    for (int i = 2; i <= max_n; i++) {
        if (!prime[i]) prime[++prime[0]] = i;
        for (int j = 1; j <= prime[0]; j++) {
            if(prime[j] * i > max_n) break;
            prime[prime[j] * i] = 1;
            if (i % prime[j] == 0) break;
            // i是最大因子  prime[j]是最小素因子
        }
    }
    return ;
}

int main() {
    init ();
    int m, n;
    long long sum = 0;
    cin >> n >> m;
    for(int i = 1; i <= prime[0] && prime[i] < n; i++) {
        if(prime[i] >= m) cout << prime[i] << endl;
    }
    return 0;
}
~~~

+ 输出m到n之间的所有素数
+ 在prime[]数组中存的是素数prime[1]代表第一个素数，故在输出时要注意循环的开始和结束条件
+ 在输出时可以分为两部分，第一部分是让其从第一个素数开始，__结束条件为i <= prime[0] 和 prime[i] < n，是用prime[i]和n比较，不是i!!!!!__

~~~
素数筛做法：
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
#define max_n 200
int prime[max_n + 5] = {0};

void f() {
    for (int i = 2; i < max_n; i++) {
        if (!prime[i]) prime[++prime[0]] = i;
        for (int j = i * i; j <= max_n; j += i) {
            prime[j] = 1;
        }
    }
    return ;
}
int main() {
    f();
    long long  ans = 0;
    int x, y;
    cin >> x >> y;
    /*for (int i = 1; i <= max_n ; i++) {
        ans += prime[i];
    }*/
    for (int i = 1; i <= prime[0] && prime[i] <= y; i++){
        if(prime[i] >= x) ans += prime[i];
    }
    cout << ans << endl;
    return 0;
}
~~~

```
int prime[max_n + 5] = {0};
int is_prime[max_n + 5] = {0};
void init() {
    prime[0] = prime[1] = 1;
    for (int i = 2; i < max_n; i++) {
        if (!prime[i]) is_prime[++is_prime[0]] = i;
        for (int j = 1; j <= is_prime[0]; j++) {
            if (is_prime[j] * i > max_n) break;
            prime[is_prime[j] * i] = 1;
            if (i % is_prime[j] == 0) break;
        }
    }
    return ;
}

```



## 滑动窗口法

> <https://projecteuler.net/problem=8>

~~~
The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.

73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450

Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
一个一千位的数求相邻十三位乘积最大的是多少
#include<stdio.h> 
#include<string.h>
#define max_n 1000
char num[max_n + 5];
int main(){
    int len = 0;
    while(~scanf("%s", num + len)) len += strlen(num + len);
    long long ans = 0, p = 1, zero = 0;
    for(int i = 0; num[i]; i++) {
        num[i] -= '0';//转换成整型
        if (num[i]) p *= num[i];
        else zero += 1;
        if (i < 13) continue;
        if (num[i - 13]) p /= num[i - 13];
        else zero -= 1;
        if (zero == 0 && p > ans) ans = p;
    }
    printf("%ld\n", ans);
    return 0;
}
~~~

+ 窗口为13，滑动时如果为0，判断要出去的数是否为0，用计数器加1，为0时不乘
+ 滑动后第一个数如果不为0则除以它，并将新的第13乘进来
+ 将字符串-‘0’变成整数，方便运算
+ 用文件重定向的方式读入

## 方向数组

><https://projecteuler.net/problem=11>

~~~
In the 20×20 grid below, four numbers along a diagonal line have been marked in red.

08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48

The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?
#include<stdio.h>
#define max_n 20

int grid[max_n + 5][max_n + 5];
int dir[4][2] = {s
    {-1, -1}, {-1, 0}, {-1, 1}, {0, 1}
};

int calc(int x, int y) {
    int ans = 0;
    for (int k = 0; k < 4; k++) {
        int p = 1; 
        for (int step = 0; step < 4; step++) {
            int dx = x + dir[k][0] * step;//代表X的偏移量
            //本身的值加上移动的步数在乘以x和y的偏移量
            int dy = y + dir[k][1] * step;//代表Y的偏移量
            if (dx < 0 || dx >= max_n) break;
            if (dy < 0 || dy >= max_n) break;
            p *= grid[dx][dy];
        }
        if (p > ans) ans = p;
    }
    return ans;
}
int main() {
    for (int i = 0; i < max_n; i++) {
        for (int j = 0; j < max_n; j++) {
            scanf("%d", &grid[i][j]);
        }
    }
    int ans = 0;
    for(int i = 0; i < max_n; i++) {
        for(int j = 0; j < max_n; j++) {
            int p = calc(i, j);
            if (p > ans) ans = p;
        }
    }
    printf("%d\n", ans);
    return 0;
}							
~~~

+ 此题应先确定方向，有几个以及维度，本题用的是二维x, y.

+ 先定义数组以及方向数组，封装一个函数参数为点的坐标

+ 移动后的坐标等于初始时坐标加上所移动步数乘以该对应方向的偏移量

+ 二维数组4，2 表示x有四个分别用0， 1，2， 3 来表示，y用0， 1来表示，

+  故int dx = x + dir【k】【0】 * step;//代表X的偏移量

  ​      //本身的值加上移动的步数在乘以x和y的偏移量

  ​      int dy = y + dir【k】【1】* step;//代表Y的偏移量

## 记忆化（常用于搜索）

将中间中的计算结果保存起来，减少后续计算中的重复计算

> <https://projecteuler.net/problem=14>

```
The following iterative sequence is defined for the set of positive integers:

n → n/2 (n is even)偶数
n → 3n + 1 (n is odd)奇数

Using the rule above and starting with 13, we generate the following sequence:

13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.

Which starting number, under one million, produces the longest chain?

NOTE: Once the chain starts the terms are allowed to go above one million.
Answer:
837799
#include<stdio.h>
#define max_n 1000000
#define size 100
int keep[max_n + 5] = {0};

typedef long long ll;

ll get_len(ll  n) {
    if (n == 1) return 1;
    if (n <= max_n && keep[n]) return keep[n];
    ll ret = 0;
    if (!(n & 1)) ret =  get_len(n >> 1) + 1;
    else ret = get_len(3 * n + 1) + 1;
    if (n <= max_n) keep[n] = ret;
    return ret;
}

int main() {
    ll ans = 0, len = 0;
    for (ll i = 1; i < max_n; i++) {
        ll temp = get_len(i);
        if (temp > len) {
            ans = i;
            len = temp;
        }
    }
    printf("num = %lld, len = %lld\n", ans, len);
    return 0;
}
```

## 大整数

###大整数加法

> <https://projecteuler.net/problem=13>

```
Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.

37107287533902102798797998220837590246510135740250
46376937677490009712648124896970078050417018260538
74324986199524741059474233309513058123726617309629
91942213363574161572522430563301811072406154908250
23067588207539346171171980310421047513778063246676
89261670696623633820136378418383684178734361726757
28112879812849979408065481931592621691275889832738
44274228917432520321923589422876796487670272189318
47451445736001306439091167216856844588711603153276
70386486105843025439939619828917593665686757934951
62176457141856560629502157223196586755079324193331
64906352462741904929101432445813822663347944758178
92575867718337217661963751590579239728245598838407
58203565325359399008402633568948830189458628227828
80181199384826282014278194139940567587151170094390
35398664372827112653829987240784473053190104293586
86515506006295864861532075273371959191420517255829
71693888707715466499115593487603532921714970056938
54370070576826684624621495650076471787294438377604
53282654108756828443191190634694037855217779295145
36123272525000296071075082563815656710885258350721
45876576172410976447339110607218265236877223636045
17423706905851860660448207621209813287860733969412
81142660418086830619328460811191061556940512689692
51934325451728388641918047049293215058642563049483
62467221648435076201727918039944693004732956340691
15732444386908125794514089057706229429197107928209
55037687525678773091862540744969844508330393682126
18336384825330154686196124348767681297534375946515
80386287592878490201521685554828717201219257766954
78182833757993103614740356856449095527097864797581
16726320100436897842553539920931837441497806860984
48403098129077791799088218795327364475675590848030
87086987551392711854517078544161852424320693150332
59959406895756536782107074926966537676326235447210
69793950679652694742597709739166693763042633987085
41052684708299085211399427365734116182760315001271
65378607361501080857009149939512557028198746004375
35829035317434717326932123578154982629742552737307
94953759765105305946966067683156574377167401875275
88902802571733229619176668713819931811048770190271
25267680276078003013678680992525463401061632866526
36270218540497705585629946580636237993140746255962
24074486908231174977792365466257246923322810917141
91430288197103288597806669760892938638285025333403
34413065578016127815921815005561868836468420090470
23053081172816430487623791969842487255036638784583
11487696932154902810424020138335124462181441773470
63783299490636259666498587618221225225512486764533
67720186971698544312419572409913959008952310058822
95548255300263520781532296796249481641953868218774
76085327132285723110424803456124867697064507995236
37774242535411291684276865538926205024910326572967
23701913275725675285653248258265463092207058596522
29798860272258331913126375147341994889534765745501
18495701454879288984856827726077713721403798879715
38298203783031473527721580348144513491373226651381
34829543829199918180278916522431027392251122869539
40957953066405232632538044100059654939159879593635
29746152185502371307642255121183693803580388584903
41698116222072977186158236678424689157993532961922
62467957194401269043877107275048102390895523597457
23189706772547915061505504953922979530901129967519
86188088225875314529584099251203829009407770775672
11306739708304724483816533873502340845647058077308
82959174767140363198008187129011875491310547126581
97623331044818386269515456334926366572897563400500
42846280183517070527831839425882145521227251250327
55121603546981200581762165212827652751691296897789
32238195734329339946437501907836945765883352399886
75506164965184775180738168837861091527357929701337
62177842752192623401942399639168044983993173312731
32924185707147349566916674687634660915035914677504
99518671430235219628894890102423325116913619626622
73267460800591547471830798392868535206946944540724
76841822524674417161514036427982273348055556214818
97142617910342598647204516893989422179826088076852
87783646182799346313767754307809363333018982642090
10848802521674670883215120185883543223812876952786
71329612474782464538636993009049310363619763878039
62184073572399794223406235393808339651327408011116
66627891981488087797941876876144230030984490851411
60661826293682836764744779239180335110989069790714
85786944089552990653640447425576083659976645795096
66024396409905389607120198219976047599490197230297
64913982680032973156037120041377903785566085089252
16730939319872750275468906903707539413042652315011
94809377245048795150954100921645863754710598436791
78639167021187492431995700641917969777599028300699
15368713711936614952811305876380278410754449733078
40789923115535562561142322423255033685442488917353
44889911501440648020369068063960672322193204149535
41503128880339536053299340368006977710650566631954
81234880673210146739058568557934581403627822703280
82616570773948327592232845941706525094512325230608
22918802058777319719839450180888072429661980811197
77158542502016545090413245809786882778948721859617
72107838435069186155435662884062257473692284509516
20849603980134001723930671666823555245252804609722
53503534226472524250874054075591789781264330331690
#include<stdio.h>
#include<string.h>
#define max_n 52

char str[max_n + 5] = {0}; 
int ans[max_n + 5] = {0};

int main() {
    while(~scanf("%s", str)) {
        
        int len = strlen(str);
        if (len > ans[0]) ans[0] = len;
        for (int i = 0; i < len; i++) {
            ans[len - i] += str[i] - '0';
        }
        for (int i = 1; i <= ans[0]; i++) {
            if (ans[i] < 10) continue;
            ans[i + 1] += ans[i] / 10;
            ans[i] %= 10;
            /*if (i == 10) {
                ans[0] += 1;
            }*/
            ans[0] += (i == ans[0]);
        }
    }    
    for (int i = ans[0]; i > ans[0] - 10; i--) {
        printf("%d", ans[i]);
    }
    printf("\n");
    return 0; 
}
```



### 大整数乘法

><http://oj.haizeix.com/problem/471>

```
 输入两个 100100 位以内的正整数，输出它们的乘积。
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
#define max_n 100
using namespace std;
//a[i] = str_a[len_a - i - 1] - '0';
char str_a[max_n + 5], str_b[max_n + 5];
int a[max_n + 5], b[max_n + 5], c[2 * max_n + 5];

int main() {
    memset(c, 0, sizeof(c));
    cin >> str_a >> str_b;
    int len_a = strlen(str_a);
    int len_b = strlen(str_b);
    for (int i = 0; i < len_a; i++) a[i] = str_a[len_a - i- 1] - '0';
    for (int i = 0; i < len_b; i++) b[i] = str_b[len_b - i- 1] - '0';
    for (int i = 0; i < len_a; i++) {
        for (int j = 0; j < len_b; j++) {
            c[i + j] += a[i] * b[j];
            if (c[i + j] < 10) continue;
            c[i + j + 1] += c[i + j] / 10;
            c[i + j] %= 10;
        }
    }
    int len_c = len_a + len_b;
    while (!c[len_c]) len_c--;
    for (int i = len_c; i >= 0; i--) {
        printf("%d", c[i]);
    }
    printf("\n");
    return 0;
}
```

> <http://oj.haizeix.com/problem/54>

```
义运算 f(x) 为x! 中各位非零值的相乘结果，例如5!=120 则f(5)=1×2=2
#include<stdio.h>
#include<string.h>
#define max_n 1000
int ans[max_n + 5];
int res[max_n + 5];

void solve(int x) {
    memset(ans, 0, sizeof(ans));
    ans[0] = 1,ans[1] = 1;
    for (int i = 1; i <= x; i++) {
        for (int j = 1; j <= ans[0]; j++) {
            ans[j] *= i;
        }
        for (int k = 1; k <= ans[0]; k++) {
            if (ans[k] < 10) continue;
            ans[k + 1] += ans[k] / 10;
            ans[k] %= 10;
            ans[0] += (ans[0] == k);
        }

    }
    memset(res, 0, sizeof(res));
    res[0] = 1, res[1] = 1;
    for (int i = 1; i <= ans[0]; i++) {
        if (!ans[i]) continue;
        for (int j = 1; j <= res[0]; j++) {
            res[j] *= ans[i];
        }
        for (int k = 1; k <= res[0]; k++) {
            if(res[k] < 10) continue;
            res[k + 1] += res[k] / 10;
            res[k] %= 10;
            res[0] += (res[0] == k);
        }
    } 
    for (int i = res[0]; i >= 1; i--) {
        printf("%d", res[i]);
    }
    printf("\n");
}
int main() {
    int x;
    while (scanf("%d", &x) != EOF)
        solve(x);
    return 0;  
}

```

##### a * b = c ,每位数不同且只出现一次

>  <https://projecteuler.net/problem=32>

```
We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through 5 pandigital.

The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.

Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.

HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.
45228
#include<stdio.h>
#include<math.h>
#define max_n 10000
int keep[max_n + 5] = {0};
int add_to_num (int *num, int n) {
    while (n) {
    if (num[n % 10]) return 0;
    num[n % 10] += 1;
    n /= 10;
    }
    return 1;
}

int digit(int n) {
    int d = floor(log10(n)) + 1;
    return d;
}


int is_val(int a, int b) {
    if (digit(a) + digit(b) + digit(a * b) != 9) return 0;
    int num[10] = {0};
    num[0] = 1;
    int flag = 1;
    flag = flag && add_to_num(num, a);
    flag = flag && add_to_num(num, b);
    flag = flag && add_to_num(num, a * b);
    return flag;
}


int main() {
    int sum = 0;
    for (int a = 1; a < 100; a++) {
        for (int b = a + 1; b < 10000; b++) {
            if(!is_val(a, b)) continue;
            printf("%d * %d = %d\n", a, b, a * b);
            if (keep[a * b]) continue;
            keep[a * b] = 1;
            sum += a * b;
        }
    }
    printf("%d\n", sum);
}
```

- 取一个数字的位数：floor(log10(n)) + 1;
- a * b = c, abc三个数的位数加起来为九
- 不能重复
- 相同的数只加一遍

## 大整数乘方

> <https://projecteuler.net/problem=20>

```
n! means n × (n − 1) × ... × 3 × 2 × 1

For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.

Find the sum of the digits in the number 100!


Answer:
648
#include<stdio.h>
#include<string.h>
#define max_n 300
int ans[max_n + 5] = {1, 1, 0};

int main() {
    for (int i = 1; i <= 100; i++) {
        for (int j = 1; j <= ans[0]; j++) {
            ans[j] *= i;
        }
        for (int k = 1; k <= ans[0]; k++) {
            if (ans[k] < 10) continue;
            ans[k + 1] += ans[k] / 10;
            ans[k] %= 10;
            ans[0] += (k == ans[0]);
        }
    }    
    int sum = 0;
    for (int i = 1; i <= ans[0]; i++) {
        sum += ans[i];
    }
    printf("%d\n", sum);
    return 0;
}
```



## 滚动数组

<https://projecteuler.net/problem=25>

```
The Fibonacci sequence is defined by the recurrence relation:

Fn = Fn−1 + Fn−2, where F1 = 1 and F2 = 1.
Hence the first 12 terms will be:

F1 = 1
F2 = 1
F3 = 2
F4 = 3
F5 = 5
F6 = 8
F7 = 13
F8 = 21
F9 = 34
F10 = 55
F11 = 89
F12 = 144
The 12th term, F12, is the first term to contain three digits.

What is the index of the first term in the Fibonacci sequence to contain 1000 digits?
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>

int f[3][1005];

int main() {
    int n = 2;
    f[1][0] = 1;
    f[1][1] = 1;
    f[2][0] = 1;
    f[2][1] = 1;
    while(f[n % 3][0] < 1000) {//判断当前位数是否小于1000
        n += 1;
        int *a = f[n % 3], *b = f[(n - 1) % 3], *c = f[(n - 2) % 3];
        for(int i = 1; i <= b[0]; i++) {
            a[i] = b[i] + c[i];//a[i][0]存位数a[i][1]存值
        }
        a[0] = b[0];
        for(int i = 1; i <= a[0]; i++) {
            if(a[i] < 10) continue;
            a[i + 1] += a[i] / 10;
            a[i] %= 10;
            a[0] += (a[0] == i);
        }
    }
    printf("%d\n", n);
    return 0;
}
```

## 递推算法

> <https://projecteuler.net/problem=31>

- f(n, m) 代表用前n种硬币换m钱的方法总数
- f(n, m) = f(n - 1, m) + f(n, m - w[n])  两种方案无交集
- w[n]代表第n种的硬币面值
- 前n种硬币的方法总数(没用上n)，加上一定用上第n种硬币的方法总数



```
In the United Kingdom the currency is made up of pound (£) and pence (p). There are eight coins in general circulation:
1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), and £2 (200p).
It is possible to make £2 in the following way:
1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p
How many different ways can £2 be made using any number of coins?
Answer:
73682
```

```
方法一：
正常方法
#include<stdio.h>
#define N 8
#define M 200

int f[N + 5][M + 5];
int w[N + 5] = {1, 2, 5, 10, 20, 50, 100, 200};

int main() {
    for(int i = 0; i < N;i++) {
        f[i][0] = 1;//假设f[i][i] = f[i - 1][i]+f[i][i-w[i]]10元 拼凑10元
        for(int j = 1; j <= M; j++) {
            f[i][j] = 0;
            if(i >= 1) f[i][j] += f[i - 1][j];
            if(j >= w[i]) f[i][j] += f[i][j - w[i]];//j > w[i], i = 0, i - 1 = -1,为了防止这样不合法的情况出现。
            //拼凑第I中硬币J元钱W『I』是第I元钱的面值
        }
    }
    printf("%d\n", f[N - 1][M]);
    return 0;
}
```

```

方法二：
滚动数组
#include<stdio.h>
#define max_n 8
#define max_m 200

int w[max_n + 5] = {
    1, 2, 5, 10, 20, 50, 100, 200
};
int f[2][max_m + 5];


int main() {
    for (int k = 0; k < max_n; k++) {
        int i = k % 2;
        f[i][0] = 1;//用前i种硬币拼凑0元钱
        //f[i][i] = f[i - 1][i] + f
        for (int j = 1; j <= max_m; j++) {
            f[i][j] = 0;
            f[i][j] += f[i ^ 1][j];//需要0 0^1 = 1
            if (j >= w[k]) f[i][j] += f[i][j - w[k]];
        }
    }
    printf("%d\n", f[(max_n - 1) % 2][max_m]);
    return 0;
}
```

```
方法三：
降维
f[i+1][j] = f[i][j] + f[i+1][j-w[i+1]]
              (1)             (2)        
f[j]为这一次的方法总数，所以仅需要加上上次的(2),这次的(1) += 上次的(1) + 这次的(2)
#include<stdio.h>
#define max_n 8
#define max_m 200

int w[max_n + 5] = {
    1, 2, 5, 10, 20, 50, 100, 200
};
int f[max_m + 5];


int main() {
    f[0] = 1;
    for (int i = 0; i < max_n; i++) {
        for (int j = 1; j <= max_m; j++) {
            if (j >= w[i]) f[j] += f[j - w[i]];
        }
    }
    printf("%d\n", f[max_m]);
    return 0;
}
```

### 递推题解法

- 定义状态（最重要）
- 确定递推方程
- 程序实现

一般正向递推 需要加记忆化，逆向递推 直接用for循环。

##整数因子个数

> <https://projecteuler.net/problem=12>



![1c = a * b](/home/unique/Desktop/%E6%B5%B7%E8%B4%BC/picture/1c%20=%20a%20*%20b.png)

![c = a * b](/home/unique/Desktop/%E6%B5%B7%E8%B4%BC/picture/c%20=%20a%20*%20b.png)

![深度截图_dde-desktop_20191226200823](/home/unique/Desktop/海贼/picture/深度截图_dde-desktop_20191226200823.png)

```
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.
What is the value of the Answer:
first triangle number to have over five hundred divisors?
Answer:
76576500
#include<iostream>
using namespace std;
#define N 1000000

int prime[N + 5]= {0};
int f[N + 5] = {0};//存因子个数
int cnt[N + 5] = {0};//素因子幂次

void init() {
    for(int i = 2; i <= N; i++) {
        if(!prime[i]) { 
            prime[++prime[0]]= i;
            f[i] = 2;
            cnt[i] = 1;
        }
        for(int j = 1; j <= prime[0]; j++) {
            if(prime[j] * i > N) break;
            prime[i * prime[j]] = 1;
            if(i % prime[j] == 0) {//代表a和prime[j]不互素
                /*int a = i, cnt = 0;
                while(a % prime[j] == 0) a /= prime[j], cnt++;
                f[i * prime[j]] = f[i] /(cnt + 1) * (cnt + 2);//代表当前素因子幂次
                break;*/
                cnt[i * prime[j]] = cnt[i] + 1;
                f[i * prime[j]] = f[i] / (cnt[i] + 1) * (cnt[i] + 2);
                break;
            } else {//a和prime[j]互素
                f[prime[j] * i] = f[prime[j]] * f[i];
                cnt[prime[j] * i] = 1;
            }
        }
    }
    return ;
}

int main () {
    init();
    long long int n = 0, fac = 0;
    while(fac <= 500) {
        n += 1;
        if(n & 1) {
            fac = f[n] * f[(n + 1) >> 1];
        } else{
            fac = f[n >> 1] * f[n + 1];
        }
    }
    cout << n * (n + 1)/ 2 << endl;
    return 0;
}
```

## 素勾股数

![深度截图_dde-desktop_20191226181206](/home/unique/Desktop/海贼/picture/深度截图_dde-desktop_20191226181206.png)

> <https://projecteuler.net/problem=9>

```
A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
a2 + b2 = c2
For example, 32 + 42 = 9 + 16 = 25 = 52.
There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.

Answer:
31875000

#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
int gcd (int a, int b) {
    return (b ? gcd(b, a % b) : a);
}

int main() {
    int ans = 0;
    for (int n = 1; n <= 33; n++) {
        for (int m = n + 1; m * m + n * n < 1000; m++) {
            if (gcd(m ,n) - 1) continue;
            int a = 2 * m * n;
            int b = m * m - n * n;
            int c = m * m + n * n;
            if (1000 % (a + b + c) == 0) {
                int k = 1000 / (a + b +c);
                ans = a * b * c * k * k * k;
            }
            if (ans) break;
        }
        if (ans) break;
    }
    cout << ans << endl;
}
```

## 阶乘分解

> <http://oj.haizeix.com/problem/310>

```
题目描述
给定整数 N(1≤N≤106)N(1≤N≤106)，试把阶乘 N!N! 分解质因数，按照算术基本定理的形式输出分解结果中的pi和ci即可。

输入
一个整数 NN。

输出
N! 分解质因数后的结果，共若干行，每行一对pi,ci，表示含有 pciipici 项。按照 pi从小到大的顺序输出。

样例输入
5
样例输出
2 3
3 1
5 1
样例说明
5!=120=23∗31∗51

#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
#define max_n 1000000
int prime[max_n + 5] = {0};
 
void init(int n) {
    for (int i = 2; i <= n; i++) {
        if (!prime[i]) prime[++prime[0]] = i;
        for (int j = 1; j <= prime[0]; j++) {
            if (prime[j] * i > n) break;
            prime[prime[j] * i] = 1;
            if (i % prime[j] == 0) break;
        }
    }
    return ;
}

int cnt[max_n + 5] = {0};

int main() {
    long long n; 
    cin >> n;
    init(n);
    for (int j = 1; j <= prime[0]; j++) {
        long long tmp = prime[j], cnt = 0;
        while (tmp <= n){
            cnt += n / tmp;//看看1~n之间有几个prime[j]
            tmp *= prime[j];//
        } 
        //while循环的作用就是，如果n 为5，则需要求出5！并算其素数以及所对应的
        幂次，如果N为5 1×2×3×4×5，小于5的素数有2,3,5,通过这个while循环可算出包含一个prime[j]的数和包含两个prime[j]的数相加即cnt += n / tmp;因为2^2 * 2^1 = 2^3,所以幂次是相加的故用+=。
        cout << prime[j] << " " << cnt << endl;
    }
    return 0;
}
如果求6的阶乘
6! = 1*2*3*4*5*6
       2   2   2   三个2此时cnt = 3
       tmp*=prime[j]  
           4       有*一个4 所以cnt = 4
```

#### 深搜(dfs)

> <http://oj.haizeix.com/problem/43>

![深搜](/home/unique/Desktop/海贼/picture/深搜.jpg)

```
题目描述
有一个由数字组成的三角形数塔，站在上一层的某个点，只能到达其下方左右的两个点。现在请找到一条从上到下的路径，使得路径上所有数字相加之和最大

4274F9B8E6E14581A4EC851BCE349029.jpg

输入
第一行输入一个数字 n（1≤n≤1000）（1≤n≤1000）代表数塔层数

接下来n行，按数塔图形，每行有一个或多个的整数，表示该层节点的值（节点值≤100000）（节点值≤100000）
输出
输出一个整数，代表从上到下路径上所有数字相加和的最大值。

样例输入1
6
3
9 5
4 2 1
3 4 9 6
3 5 3 7 3
2 1 3 9 3 2
样例输出1
39
//动态规划递推
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
#define max_n 1000
int val[max_n + 5][max_n + 5]= {0};
using namespace std;
int main() {
    int n;
    cin >> n;
    for(int i = 0; i < n; i++) {
        for (int j = 0; j <= i; j++) {
            cin >> val[i][j];
        }
    }
    for (int i = max_n - 2; i >= 0; i--) {
        for (int j = 0; j <= i; j++) {
            val[i][j] += max(val[i + 1][j], val[i + 1][j + 1]);
        }
    }
    cout << val[0][0] << endl;
    return 0;
}
```

```
//深搜记忆化（递归）
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
#define max_n 1000
using namespace std;
int val[max_n + 5][max_n + 5];
int keep[max_n + 5][max_n + 5] = {0};
int dfs(int i, int j, int n) {
    if (i + 1 == n) return val[i][j];
    if (keep[i][j]) return keep[i][j];
    int val1 = dfs(i + 1, j, n);
    int val2 = dfs(i + 1, j + 1, n);
    return keep[i][j] = (val1 > val2 ? val1 : val2) + val[i][j];
}

int main() {
    int n;
    cin >> n;
    for(int i = 0; i < n; i++) {
        for (int j = 0; j <= i; j++) {
            cin >> val[i][j];
        }
    }
    cout << dfs(0, 0, n) << endl;
    return 0;
}

```

##蒙特卡洛方法计算圆周率(C语言实现)

```
#include<iostream>
#include<ctime>
#include<cmath>
#include<cstdlib>
#include<cstdio>
using namespace std;
#define MAX_OP 1000000

int main () {
    int n = 0, m = 0;
    for(int i = 0; i < MAX_OP; i++) {
        double x = rand() * 1.0 /RAND_MAX * (rand() % 2 ? 1 : -1);
        double y = rand() * 1.0/ RAND_MAX * (rand() % 2 ? 1 : -1);
        if(x * x + y * y <= 1.0) m += 1;//半径<= 1说明在圆内
        n += 1;
    }
    printf("%lf\n", m * 1.0 / n * 4.0);//圆内个数处理圆外正方形内应为π/4,所以乘以4，求得π
     return 0;
}
```

## oj380大统领投票

> <http://oj.haizeix.com/problem/380>

+ 两个大数比大小，位数相同时从左到右比
  位数不同时输出位数大的即可

```
题目描述
 第一届地球大统领开始选拔，全地球的所有生物都积极参与投票，现在已知得票结果，请输出新当选的得票数最多的地球大统领的编号和得票数。

输入
 输入第一行为一个整数 NN 表示参选生物数。（1≤N≤100）（1≤N≤100）
 接下来 NN 行，每行一个整数，表示第 ii 名参选生物的票数。票数不会超过 10001000位。

输出
 输出得票数最多的生物的编号和票数。

样例输入
3
123456799
123456789132456789123456789
11111111111111
样例输出
2
123456789132456789123456789



#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
struct Node {
    int num;
    char str[1005];
};
 
int cmp (struct Node a, struct Node b) {
    int x = strlen(a.str);
    int y = strlen(b.str);
    if (x - y) return x > y;//位数相同时，返回位数大的数
    return a.str > b.str;//位数不同时，正常比就好
}
int main() {
    struct Node a[105]; 
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i].str;
        a[i].num = i;    
    }
    sort(a, a + n, cmp);
    cout << a[0].num + 1<< endl;
    cout << a[0].str << endl;
    return 0;
}

```

## 二分方法

阅读题意后根据题意二分答案，就直接将mid 认为是符合题意的那个最大的最小值/最小的最大值，所以小于/大于这个传入的mid的数据处理



> 链接：http://poj.org/problem?id=1064 

```
题目大意：有n条绳子，长度分别为L[i]。如果从他们中切割出k条长度相同的绳子的话，这k条绳子每条最长能有多长？（答案保留小数点后两位，规定1单位长度的绳子最多可以切割成100份）。 分析：二分搜索最大长度x。我们令C（x）为可以得到K条长度为x的绳子，那么问题就变为了求满足条件C（x）的最大的x。在区间初始化时，只需使用充分大的数inf（大于绳子的最大长度的二倍）作为上界即可：left=0,right=inf。那么现在的问题就变为了如何高效的判断C（x）是否满足。由于长度为L的绳子最多可以切割出floor(L/x)段长度为x的绳子，因子C（x）=floor(Li/x)的总和是否不小于k，他可以在O（n）的时间内判断出来。


#include<cstdio.h>
#include<cmath>
using namespace std;
const int M = 10005;
const ouble inf = 200005.0;
double L[M];
int n, k;
bool jugde(double x) {
    int num = 0;
    for (int i = 0; i < n; i++) {
        num += (int)(L[i] / x);
    }
    return num >= k;
}
void solve() {
//代替while(r>l) 避免了精度问题 = mid
//1次循环可以把区间缩小一半，100次可以达到10^(-30)的精度 
    double left = 0, right = inf;
    for (int i = 0; i < 100; i++) {
        double mid = (left + right) / 2;
        if (judge(mid)) left = mid;
        else right = mid;
    }"
    printf("%.2f\n", floor(right*100) / 100);
}
int main() {
    while(scanf("%d%d", &n, &k) != -1) {
        for (int i = 0; i < n; i++) {
            scanf("%lf", &L[i]);
        }
        solve();
    }
    return 0;
}
```

> <http://oj.haizeix.com/training-ground/19/problem/394>

+ 最短跳跃距离尽可能长：即对终点到起点的距离二分找到最小距离，小于最小距离的石头移走，再最后判断移动石头数是否满足要求，才能使所有距离都大于最小距离。后由返回值判定为最终结果或者移动r或l.

```
 一年一度的“跳石头”比赛又要开始了!

 这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 NN 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。

 为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 MM 块岩石（不能移走起点和终点的岩石）。

输入
 第一行包含三个整数 L,N,ML,N,M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 L≥1L≥1 且 N≥M≥0N≥M≥0。

接下来 NN 行，每行一个整数，第 ii 行的整数 Di(0<Di<L)Di(0<Di<L)， 表示第 ii 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。

输出
 一个整数，即最短跳跃距离的最大值。

样例输入
25 5 2 
2
11
14
17 
21
样例输出
4

一年一度的“跳石头”比赛又要开始了！ 
这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有N块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。 

为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走M块岩石（不能移走起点和终点的岩石）。

输入描述 Input Description
输入文件名为 stone.in。 

输入文件第一行包含三个整数L，N，M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。 

接下来N行，每行一个整数，第i行的整数Di（0 < Di < L）表示第i块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。 
输出描述 Output Description
输出文件名为stone.out。 
输出文件只包含一个整数，即最短跳跃距离的最大值。
样例输入 Sample Input
25 5 2
2 
11 
14 
17
21
样例输出 Sample Output
4

#include <iostream>
using namespace std;
int l,n,m,a[50005],ans;
bool check(int dis)
{
    int count=0,last=0;
    for(int i=1;i<=n;i++)
        if(a[i]-last<dis)count++;
        //目前设最短距离为dis，所以小于最小距离的石头移走
            else last=a[i];
    if(count>m)return 0;return 1;
}
int main()
{
    cin>>l>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    a[n+1]=l;
    int fl=0,fr=l;
    while(fl<=fr)
    {
        int mid=(fl+fr)/2;
        if(check(mid))fl=mid+1,ans=mid;
            else fr=mid-1;
    }
    cout<<ans;
    return 0;
}
```

+ 说了是二分答案，你说二分啥？二分距离呗。意思是我们现在要找到一个最大值的距离，这个距离能保证只搬走m或m以内个石头就能让任意两个相邻的石头之间的距离≥这个距离。我们就来二分查找满足这个条件的最大的距离。

  当我们处理完上一步后，就得到了一个新的查找区间——原区间的左半边或者右半边。再在这个查找区间用上面的方法查找，直到区间里没有数字了，查找结束。输出答案。

+ 先是从0~L之间查找这个距离，取中间值，也就是L/2，然后看L/2这个距离是否满足上面那个条件，如果满足那个条件，就把二分查找的左边界调到中间值（也就是L/2）的右边一个去，这样再次查找的范围就排除了不可能存在最优解的左半边（因为左半边所有满足或者不满足上面那个条件的所有距离都会小于L/2这个距离，所以不可能存在（不然为啥不选L/2这个值呢？L/2也满足那个条件啊）），并且在这里还要记住中间值，因为他是目前的最优解。如果中间值（当前是L/2）不满足那个条件，那L/2的右边的所有距离也都不可能存在某个距离能满足那个条件了（要不然L/2也会满足那个条件的，对吧？），所以就把查找的右边界调到中间值的左边一个去。

    

    

    

    ![二分答案](/home/unique/Desktop/海贼/picture/二分答案.png)

    

    左： 找一堆6中的最后一个                                                       右： 找一堆6中的最后一个六

    ![2](/home/unique/Desktop/海贼/picture/2.png)

    mid =  l + (r - l) / 2 因为7/2向下去取整时3， 而-7/2向下取整时为-3，为了防止出现这样的bug

    abs(a - b) <1e-x  x取题中要求进度的后两位就可。特别接近就看成相等

    > <http://oj.haizeix.com/problem/389>	

```
题目描述
 某公司的程序猿每天都很暴躁，因为他们每个人都认为其他程序猿和自己风格不同，无法一同工作，当他们的工位的编号距离太近时，他们可能会发生语言甚至肢体冲突，为了尽量避免这种情况发生，现在公司打算重新安排工位，因为有些关系户的工位是固定的，现在只有一部分工位空了出来，现在有 NN 个程序猿需要分配在 MM 个工位中，第 ii 个工位的编号为 XiXi，工位编号各不相同，现在要求距离最近的两个程序猿之间的距离最大，求这个最大距离是多少。XiXi 和 XjXj 工位之间距离为|Xi−Xj||Xi−Xj|。

输入
 输入共 M+1M+1 行。

 第一行两个整数 M,NM,N。（1≤N≤M≤100,000）（1≤N≤M≤100,000）
 接下来 MM 行，每行一个数，表示剩余的工位的编号。

输出
 输出距离最近的两个程序猿之间的最大距离。

样例输入
5 3
1
2
8
4
9
样例输出
3
```

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
#define max_n 100005
int m, n;
int a[max_n];

int is_val (int x) {
    int last = 0;
    for (int i = 1; i < n; i++) {
        int cur = last + 1;
        while (cur < m && a[cur] - a[last] < x) {
            cur++;
        }
        if (cur == m) return 0;
        last = cur;
    }
    return 1;
}

int main() {
    cin >> m >> n;
    for (int i = 0; i < m; i++) {
        cin >> a[i];
    }
    sort(a, a + m);
    int l = 0, r = a[m - 1];
    while (r - l > 1) {
        int mid = (l + r) / 2;
        if (is_val(mid)) l = mid;
        else r = mid;
    }  
    cout << l << endl;
    return 0;
}
```

> <http://oj.haizeix.com/training-ground/19/problem/391>

```
 对于给定的一个长度为 NN 的正整数数列 AiAi，现要将其分成 M(M≤N)M(M≤N) 段，并要求每段连续，且每段和的最大值最小。
关于最大值最小：
例如一数列 4 2 4 5 14 2 4 5 1 要分成 33 段
将其如下分段：
[4 2][4 5][1][4 2][4 5][1]
第 1 段和为6，第2 段和为9，第3 段和为1，和最大值为9。
将其如下分段
[4][2 4][5 1][4][2 4][5 1]
第 1 段和为4，第2 段和为6，第3 段和为6，和最大值为6。
并且无论如何分段，最大值不会小于6。
所以可以得到要将数列 4 2 4 5 1要分成 3 段，每段和的最大值最小为 6。
```

```
#include<iostream>
using namespace std;
typedef long long ll;
ll n, m;
#define max_n 100000
ll a[max_n + 5];

ll is_val(ll x) {
    ll sum = 0, cnt = 1;
    for (int i = 1; i <= n; i++) {
        if (sum + a[i] > x) {
            sum = a[i];
            cnt++;
        }
        else sum += a[i];
    }
    return cnt <= m;
}    
int main() {
    ll maxx = 0;
    cin >> n >> m;
    ll l;
    ll r = 0;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        maxx = (a[i] > maxx ? a[i] : maxx);
        r += a[i];
    }
    l = maxx;
    ll res = 0;
    while (l <= r) {
        ll mid = (l + r) / 2;
        if (is_val(mid)) r = mid - 1;//求最大值的最小值，故 r = mid
        else l = mid + 1;
    }
    cout << l << endl;
    return 0;
}
```

# 递归深搜广搜

OJ83N分

>  给定一个正整数 nn，把它用正整数分成 mm 份，求有多少种不同的分法。

```c
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;

int dfs(int n, int m) {
    if (n < m) return 0;
    if (n == m) return 1;
    if (m == 1) return 1; 
    if (n > m) return dfs(n - 1, m - 1) + dfs(n - m, m);//相当于把n个球放到m个盒子中
}

int main() {
    int n, m;
    cin >> n >> m;
    cout << dfs(n, m) << endl;
    return 0;
}
```

## 把n个分成m堆

<https://blog.csdn.net/define_danmu_primer/article/details/53348722>

1. 把n个相同物品分成m个相同的堆，可空设为R(n,m)R(n,m)
  R(n,m)=∑mk=1S(n,k)R(n,m)=∑k=1mS(n,k)
2. 把n个相同物品分成m个相同的堆，不空设为S(n,m)S(n,m)
  S(n,m)=S(n−1,m−1)+S(n−m,m)S(n,m)=S(n−1,m−1)+S(n−m,m)
3. 把n个相同物品分成m个不同的堆，可空设为T(n,m)T(n,m)
  T(n,m)=Cm−1n+m−1T(n,m)=Cn+m−1m−1
4. 把n个相同物品分成m个不同的堆，不空设为U(n,m)U(n,m)
  U(n,m)=Cm−1n−1U(n,m)=Cn−1m−1
5. 把n个不同物品分成m个相同的堆，可空设为P(n,m)P(n,m)
  P(n,m)=∑mk=1Q(n,k)贝尔数

## oj235递归实现指数型枚举

这三道题都是通过递归实现的思想大概相似，读懂题意，将此题的答案想成是一个二叉树，然后用数组实现，用cnt来进行技术或者回溯，

![235](/home/unique/Desktop/海贼/picture/235.jpg)

例如有1,2,3,4此时数组中4个数，而回溯到上一个后就相当于让cnt--将数组中cnt位置的数被新的数覆盖掉变为1,2,4.__相当于建立了n颗树__

![235](/home/unique/Desktop/海贼/picture/235.png)

>  从 1−n1−n 这 nn 个整数中随机选取任意多个，每种方案里的数从小到大排列，按字典序输出所有可能的选择方案。
>
> #### 样例输入
>
> ```
> 3
> ```
>
> #### 样例输出
>
> ```
> 1
> 1 2
> 1 2 3
> 1 3
> 2
> 2 3
> 3
> ```

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <cstring>
#include <cmath>
#include <ctime>
#include <iomanip>
using namespace std;
//num数组用来记录每次搜索的答案
int num[15], cnt ;//cnt是num的计数器
int n;//枚举上线
void p() {
    for (int i = 0;i < cnt ;i++) {
        if (i) cout << " ";
        cout << num[i];
    }
    cout << endl;
}
//用树的结构想，用数组想中下标cnt++, cnt--来模拟向下搜索和回溯的过程
void func(int s) {
    for (int i = s ;i <= n; i++) {//第一个数从s开始
        //建立了n颗树,如上图
        num[cnt++] = i ;//存进相应位置，相当于构造好树
        p();//打印
        func(i + 1);
        cnt--;//回溯，1234,cnt--,num[cnt] = 3,达到了回溯的目的
    }
}

int main(){
    cin >> n;
    func(1);
   return 0;
}

/*#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;

void func(int ind, int n, int k, int *a) {
    if (ind == n) return ;
    for (int i = ind + 1; i <= n; i++) {
        a[k] = i;
        for (int j = 0; j <= k; j++) {
            j && cout << " ";
            cout << a[j];
        }
        cout << endl;
        func(i, n, k + 1, a);
    }
    return ;
}

int main() {
    int n;
    int a[10];
    cin >> n;
    func(0, n, 0, a);
    return 0;
}*/
```

## oj236递归实现组合型枚举



>  从 1−n这 n 个整数中随机选取 m 个，每种方案里的数从小到大排列，按字典序输出所有可能的选择方案。
>
> #### 样例输入2
>
> ```
> 5 3
> ```
>
> #### 样例输出2
>
> ```
> 1 2 3
> 1 2 4
> 1 2 5
> 1 3 4
> 1 3 5
> 1 4 5
> 2 3 4
> 2 3 5
> 2 4 5
> 3 4 5
> ```

```c++
#include <iostream>
using namespace std;

int n, m, num[15], cnt;

void func(int s, int left) {
    if (left == 0) {//已经为m个了后面的就不要了，直接输出
        for (int i = 0; i < cnt; i++) {
            if (i) cout << " ";
            cout << num[i];
        }
        cout << endl;
        return ;
    }
    for (int i = s; i <= n - left + 1; i++) {
        num[cnt] = i;
        cnt++;
        func(i + 1, left - 1);//每向下递归一次，left 减一个
        cnt--;
    }
}

int main() {
    cin >> n >> m;
    func(1, m);
    return 0;
}
```

## 237递归实现排列型枚举

>  从 1−n1−n 这 nn 个整数排成一排并打乱次序，按字典序输出所有可能的选择方案。
>
>  样例输入
>
> ```
> 3
> ```
>
> #### 样例输出
>
> ```
> 1 2 3
> 1 3 2
> 2 1 3
> 2 3 1
> 3 1 2
> 3 2 1
> ```

```c++
#include <iostream>
using namespace std;

int n, num[15], cnt, mark[15];
// num用来存每一次的答案，mark是标记数组，防止重复
void func(int left) {
    if (left == 0) {//已经把本次搜索的数已经确定好的
        for (int i = 0; i < cnt; i++) {
            if (i) cout << " ";
            cout << num[i];
        }
        cout << endl;
        return ;
    }
    for (int i = 1; i <= n; i++) {
        if (mark[i] == 0) {//没用过，可以用
            mark[i] = 1;
            num[cnt] = i;
            cnt++;
            func(left - 1);
            cnt--;
            mark[i] = 0;//还原回去
        }
    }
}

int main() {
    cin >> n;
    func(n);
    return 0;
}

```

## 240打印图形

> 当 nn 为 11 时，图形如下图：
>
> ```
> X
> ```
>
>  当 nn 为 22 时，图形如下图：
>
> ```
> X X
>  X
> X X
> ```
>
>  当 n≥2n≥2 时，图形规律如下：
>
> ```
> 图形n-1   图形n-1
>     图形n-1
> 图形n-1   图形n-1
> ```

```
输入
1
2
3
4
-1
输出
X n == 1
-
X X
 X   n == 2
X X
-
X X   X X
 X     X
X X   X X
   X X      n == 3
    X
   X X
X X   X X
 X     X
X X   X X
-
X X   X X         X X   X X
 X     X           X     X
X X   X X         X X   X X
   X X               X X
    X                 X
   X X               X X
X X   X X         X X   X X
 X     X           X     X
X X   X X         X X   X X
         X X   X X
          X     X
         X X   X X
            X X
             X                n == 4
            X X
         X X   X X
          X     X
         X X   X X
X X   X X         X X   X X
 X     X           X     X
X X   X X         X X   X X
   X X               X X
    X                 X
   X X               X X
X X   X X         X X   X X
 X     X           X     X
X X   X X         X X   X X
```

![240](/home/unique/Desktop/海贼/picture/240.png)

将左上角的左边规定为1,1，然后根据边长在五个位置上做n - 1的图像，然后递归下去

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
char ans[2200][2200];//答案数组
int num[10] = {0, 1, 3, 9, 27, 81, 243, 729};//1到7的边长
//将n的图形在左上左下右上右下中间这五个方向上用n - 1的图形弄出来
void func(int x, int y, int n) {
    if (n == 1) {
        ans[x][y] = 'X';
        return ;
    }
    func(x, y, n - 1);//左上
    func(x, y + num[n] / 3 * 2, n - 1);//左下
    func(x + num[n] / 3 * 2, y, n - 1);//右上
    func(x + num[n] / 3 * 2, y + num[n] / 3 * 2, n - 1);//右下
    func(x + num[n] / 3, y + num[n] / 3, n - 1);//中间
}

int main() {
    func(1, 1, 7);
    int n;
    while (cin >> n) {
        if (n == -1) {
            break;
        }
        for (int i = 1; i <= num[n]; i++) {
            for (int j = 1; j <= num[n]; j++) {
                if (ans[i][j] == 'X') cout << 'X';
                else cout << ' ';
            }
            cout << endl;
        }
        cout << '-' << endl;
    }
    return 0;
}

```

## 83N 分

>  给定一个正整数 nn，把它用正整数分成 mm 份，求有多少种不同的分法。
>
> #### 样例输入
>
> ```
> 6 3
> ```
>
> #### 样例输出
>
> ```
> 3
> ```
>
> #### 样例说明
>
>  1+1+41+1+4 1+2+31+2+3 2+2+22+2+2
>
>  共三种情况（调换数的顺序视为同一种方法）

一层一层找，找一层就减去当前的值，然后找到的数减一，直到找到符合条件的为止

```c++
#include <iostream>
using namespace std;
//输入6 3
//left_num为n减去当前这一层数,还剩几 
//left_cnt为这是找的第几个，到m为止
int func(int s, int left_num, int left_cnt) {
    if (left_cnt == 0) {//递归出口
        if (left_num == 0) return 1;//都遍历完了并且数等于0
        return 0;
    }
    int ans = 0;
    for (int i = s; i <= left_num; i++) {
        ans += func(i, left_num - i, left_cnt - 1);
    //每次搜索完一层后要减去当前层的值left_num - i
    //然后继续向下一层搜索,并且当前一查找到的个数加1left_cnt + 1
    }
    return ans;
}

int main() {
    int n, m;
    cin >> n >> m;
    cout << func(1, n, m) << endl;
    return 0;
}

//具体输出哪几种答案
/*#include <iostream>
using namespace std;

int num[10], cnt;

void p() {
    for (int i = 0; i < cnt; i++) {
        if (i) cout << '+';
        cout << num[i];
    }
    cout << endl;
}
int func(int s, int left_num, int left_cnt) {
    if (left_cnt == 0) {
        if (left_num == 0) {
            p();
            return 1;
        }
        return 0;
    }
    int ans =  0;
    for (int i = s; i <= left_num; i++) {
        num[cnt] = i;
        cnt++;
        ans += func(i, left_num - i, left_cnt - 1);//
        cnt--;
    }
    return ans;
}

int main() {
    int n, m;
    cin >> n >> m;
    cout << func(1, n, m) << endl;
    return 0;
}*/


//公式法
/*#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;

int dfs(int n, int m) {
    if (n < m) return 0;
    if (n == m) return 1;
    if (m == 1) return 1; 
    if (n > m) return dfs(n - 1, m - 1) + dfs(n - m, m);
}

int main() {
    int n, m;
    cin >> n >> m;
    cout << dfs(n, m) << endl;
    return 0;
}*/
```

## 80

> #### #不可以走 .可以走看看小明能否到达g
>
> ```
> 4 5
> s####
> ....#
> #####
> #...g
> ```
>
> #### 样例输出1
>
> ```
> No
> ```

运用递归直至找到答案

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;

char mmap[505][505];
int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};//方向数组

int func(int x, int y) {
    for (int i = 0; i < 4; i++) {//四个方向
        int tx = x + dir[i][0];
        int ty = y + dir[i][1];
        if (mmap[tx][ty] == 'g') {
            return 1;
        }
        if (mmap[tx][ty] == '.') {
    //如果可以走，就把他标记为*证明走过了,以免重复而导致死循环
            mmap[tx][ty] = '*';
            if (func(tx, ty)) {
                return 1;
            }
        }
    }
    return 0;
}
int main() {
    int n, m;
    cin >> n >> m;
    int sx, sy;
//从(1，1)点开始存，因为在第一行的时候如果向上走就会出现负数，用1来预防数组越界
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> mmap[i][j];
            if (mmap[i][j] == 's') {
                //用sx,sy记录起点坐标
                sx = i;
                sy = j;
            }
        }
    }
    if (func(sx, sy)) cout << "yes" << endl;
    else cout << "no" << endl;
    return 0;
}
```

## oj535瓷砖

> 小明现在站在某一块黑色的瓷砖上，他可以从此处出发，移动到上下左右四个相邻的且是黑色的瓷砖上。现在，他想知道，通过重复上述移动所能经过的黑色瓷砖数。 ".","#","@"".","#","@"，分别代表黑色瓷砖，红色瓷砖，初始位置。
>
> #### 样例输入
>
> ```
> 11 9
> .#.........
> .#.#######.
> .#.#.....#.
> .#.#.###.#.
> .#.#..@#.#.
> .#.#####.#.
> .#.......#.
> .#########.
> ...........
> ```
>
> #### 样例输出
>
> ```
> 59
> ```

```c++
#include<iostream>
using namespace std;
int n, m, sx, sy, ans = 1;
char mmap[55][55];
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};

void func(int x, int y) {
    for (int i = 0; i < 4; i++) {
        int tx = x + dir[i][0];
        int ty = y + dir[i][1];
        if (mmap[tx][ty] == '.') {
            mmap[tx][ty] = 0;
            ans++;
            func(tx, ty);
        }
    }
}

int main() {
    cin >> m >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> mmap[i][j];
            if (mmap[i][j] == '@') {
                sx = i;
                sy = j;
            }
        }
    }
    func(sx,sy);
    cout << ans << endl;
    return 0;
}
```

## 397僵尸来袭

>  00 代表这个格子上没有僵尸，其余数代表僵尸的个数。若某一个格子上有僵尸，且在这个格子上下左右的某个格子上也有僵尸，那么他们为同一波僵尸，现求后院外还有多少波僵尸。
>
>  样例输入
>
> ```
> 5 6
> 0 1 2 3 4 0
> 1 0 0 0 0 0
> 2 9 3 0 2 4
> 0 0 2 0 2 8
> 1 0 0 0 0 0
> ```
>
> #### 样例输出
>
> ```
> 4
> ```

```c++
#include<iostream>
using namespace std;

int n, m, mmap[105][105], ans = 0;
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
void func(int x, int y) {
    for (int i = 0; i < 4; i++) {
        int tx = x + dir[i][0];
        int ty = y + dir[i][1];
        if (mmap[tx][ty]) {//如果不为0就代表着是同一拨僵尸
            mmap[tx][ty] = 0;
            func(tx, ty);//以当前的点作为起点搜索
        }
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> mmap[i][j]; 
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (mmap[i][j] != 0) {
                ans++;
                mmap[i][j] = 0;//标记已经走过的点
                func(i, j);
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```

## 536最大黑色面积

>  00 （代表白色）或 11 （代表黑色）。现规定某一点的颜色与它的上下左右某点的颜色相同，则它们为同一区域，现求最大黑色区域的大小。
>
> #### 样例输入
>
> ```
> 5 6
> 011001
> 110101
> 010010
> 000111
> 101110
> ```
>
> #### 样例输出
>
> ```
> 7
> ```

```c++
#include<iostream>
using namespace std;

int n, m, mmax, ans;
char mmap[105][105];
int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};

void func(int x, int y) {
    for (int i = 0;i < 4; i++) {
        int tx = x + dir[i][0];
        int ty = y + dir[i][1];
        if (mmap[tx][ty] == '1') {
            ans++;//每找到一个，ans加1
            mmap[tx][ty] = '0';
            func(tx, ty);
        }
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> (&mmap[i][1]);
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (mmap[i][j] == '1') {
                mmap[i][j] = '0';
                ans = 1;
                func(i, j);
                mmax = max(mmax, ans);//取最大的
            }
        }
    }
    cout << mmax << endl;
    return 0;
}
```

## oj404 01简易版迷宫

> 若你位于一格 00 上，那么你可以移动到相邻 44 格中的某一格 11 上，同样若你位于一格 11 上，那么你可以移动到相邻 44 格中的某一格 00 上。
>
> #### 样例输入
>
> ```
> 2 3
> 011
> 100
> 2 3
> ```
>
> #### 样例输出
>
> ```
> 2
> ```

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
int n, m, sx, sy, ans = 1;
char mmap[3005][3005];
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
int check[3005][3005];
void func(int x, int y) {
    for (int i = 0; i < 4; i++) {
        int tx = x + dir[i][0];
        int ty = y + dir[i][1];
        if (tx < 1 || ty < 1 || tx > n || ty > m) {
            continue;//边界
        }

        if (mmap[tx][ty] != mmap[x][y] && check[tx][ty] == 0){//如果不相同就可以走，check用来标记是否走过
            check[tx][ty] = 1;
            ans++;
            func(tx, ty);
        }
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> &(mmap[i][1]);
    }
    cin >> sx >> sy;
    check[sx][sy] = 1;
    func(sx, sy);
    cout << ans << endl;
    return 0;
}
```

## oj405 01迷宫

> 若你位于一格 00 上，那么你可以移动到相邻 44 格中的某一格 11 上，同样若你位于一格 11 上，那么你可以移动到相邻 44 格中的某一格 00 上。你的任务是：对于给定的迷宫，询问 kk 次从某一格开始能移动到多少个格子（包含自身）。
>
> #### 样例输入
>
> ```
> 2 3 4
> 011
> 100
> 1 1
> 2 2
> 1 3
> 2 3
> ```
>
> #### 样例输出
>
> ```
> 4
> 4
> 2
> 2
> ```

例 01

​     10

这四个点不管以那个点为起点，答案都是4，所以可以将每个点的答案记录下来，遍历一次即可

__因为本题数据范围较大，所以用队列,遍历一遍后将它存起来，以后直接用__

![oj405](/home/unique/Desktop/海贼/picture/oj405.png)

```c++
#include<iostream>
#include<queue>
using namespace std;

struct node{//结构体用来存放坐标x,y
    int x, y;
};

int n, m, k, ans;
char mmap[3005][3005];
int check[3005][3005];//去重，记录答案
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
queue<node> que;

void func(int x, int y) {
    for (int i = 0; i < 4; i++) {
        int tx = x + dir[i][0];
        int ty = y + dir[i][1];
        if (check[tx][ty] == 0 && mmap[tx][ty] != mmap[x][y] && mmap[tx][ty]) {
            //mmap[tx][ty] 不能等于0， 如果等于0代表出界了
            ans++;
            check[tx][ty] = 1;
            que.push({tx, ty});//将从该起点能走到的点插入到队列中去
            func(tx, ty);
        }
    }
}
int main() {
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++) {
        cin >> (&mmap[i][1]);
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (check[i][j] == 0) {//等于0代表还没有记录答案，如果不为0代表有答案可以直接输出
                ans = 1;
                check[i][j] = 1;
                que.push({i, j});//就是把i,j这个坐标的结构体入队
                func(i, j);
                //每次搜索完成之后，以那个起点开始能走到的点都在队列中
                while (!que.empty()) {//将队列清空同时用check数组存答案
                    node temp = que.front();
                    que.pop();
                    check[temp.x][temp.y] = ans;
                }
            }
        }
    }
    for (int i = 0; i < k; i++) {
        int a, b;
        cin >> a >> b;
        cout << check[a][b] << endl;
    }
    return 0;
}
```

## 534  体积

> 给出 nn 件物品，每个物品有一个体积 ViVi，从中取出若干件物品能够组成的不同的体积和有多少种可能。例如，n=3 , Vi={1,3,4}，那么输出 6，6 种不同的体积和为 1,3,4,5,7,8。
>
>  样例输入
>
> ```
> 3
> 1 3 4
> ```
>
> #### 样例输出
>
> ```
> 6
> ```

```c++
#include<iostream>
using namespace std;
int n, num[25], check[1005] = {1}, ans;

void func(int s, int sum) {
    if (check[sum] == 0) {//标记，为了去重
        ans++;
        check[sum] = 1;
    }
    for (int i = s; i <= n; i++) {
        sum += num[i];//加这个值
        func(i + 1, sum);
        sum -= num[i];//不加
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> num[i];
    }
    func(0, 0);
    cout << ans << endl;
    return 0;
}
```

## 535 瓷砖广搜

>  在一个 w∗hw∗h 的矩形广场上，每一块 1∗11∗1 的地面都铺设了红色或黑色的瓷砖。小明现在站在某一块黑色的瓷砖上，他可以从此处出发，移动到上下左右四个相邻的且是黑色的瓷砖上。现在，他想知道，通过重复上述移动所能经过的黑色瓷砖数。
>
> ------
>
> #### 样例输入
>
> ```
> 11 9
> .#.........
> .#.#######.
> .#.#.....#.
> .#.#.###.#.
> .#.#..@#.#.
> .#.#####.#.
> .#.......#.
> .#########.
> ...........
> ```
>
> #### 样例输出
>
> ```
> 59
> ```

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#include<cmath>
using namespace std;
int h, w, ans = 1;
char mmap[55][55];
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};

struct node {
    int x, y;
};
queue <node> q;
int main() {
    cin >> h >> w;
    for (int i = 1; i <= w; i++) {
        for (int j = 1; j <= h; j++) {
            cin >> mmap[i][j];
            if (mmap[i][j] == '@') q.push({i, j});
        }
    }
    while (!q.empty()) {
        node temp = q.front();
        q.pop();
        for (int i = 0; i < 4; i++) {
            int x = temp.x + dir[i][0];
            int y = temp.y + dir[i][1];
            if (mmap[x][y] == '.') {
                mmap[x][y] = '#';
                ans++;
                q.push({x, y});
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```



## 537门票问题

> 一个有效的密码由 LL 个小写字母组成，至少有一个元音 (a,e,i,o,u)(a,e,i,o,u) 和两个辅音，并且是按字母表顺序出现的，例如 abcabc 是有效的，而 cbacba 不是。
>
>  现在给定一个期望长度 LL 和 CC 个小写字母，输出所有有效密码。
>
> #### 样例输入
>
> ```
> 4 6
> a t c i s w
> ```
>
> #### 样例输出
>
> ```
> acis
> acit
> aciw
> acst
> acsw
> actw
> aist
> aisw
> aitw
> astw
> cist
> cisw
> citw
> istw
> ```

```c++
#include<iostream>
using namespace std;
int l, c, ans_cnt, fu, yu, cnt;
char let[30];
char ans[30];

int func(int s, int left) {
    if (left == 0) {
        //符合要求输出，结束
        if (yu >= 1 && fu >= 2) {//符合要求
            for (int i = 0; i < ans_cnt; i++) {
                cout << ans[i];
            }
            cout << endl;
            cnt++;
            if (cnt == 25000) return -1;//如果多，只输出前25000个
        }
        return 0;
    }
    for (int i = s; i < c; i++) {
        ans[ans_cnt] = let[i];
        ans_cnt++;
        int f = 0;
        if (let[i] == 'a'|| let[i] == 'e' || let[i] == 'i' || let[i] == 'o' || let[i] == 'u') {
            yu++;//元音字母计数器
            f = 1;
        } else {
            fu++;//辅音字母计数器
        }

        if (func(i + 1, left - 1) == -1) return -1;
        
        if(f == 1) yu--;//回溯
        else fu--;
        ans_cnt--;
    }
    return 0;
}

int main() {
    cin >> l >> c;
    for (int i = 0; i < c; i++) {
        cin >> let[i];
    }
    sort(let, let + c);
    func(0, l);
    return 0;
}
```

## 538 图的遍历

>  读入一个用邻接矩阵存储的无向图，输出它的深度优先遍历序列。（以 11 为起点，按照编号越小权值越大的规则）
>
> #### 样例输入1
>
> ```
> 8
> 0 1 1 0 0 0 0 0 
> 1 0 0 1 1 0 0 0 
> 1 0 0 0 0 0 1 1 
> 0 1 0 0 0 1 0 0 
> 0 1 0 0 0 1 0 0 
> 0 0 0 1 1 0 0 0 
> 0 0 1 0 0 0 0 1 
> 0 0 1 0 0 0 1 0
> ```
>
> #### 样例输出1
>
> ```
> 1-2-4-6-5-3-7-8
> ```

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;

int n, num[25][25], check[25], flag;
//check数组用来标记，当前的点是否已经有边了，就是判断这个数出现过没有
void func(int x) {
    if (flag == 1) {
        cout << "-";
    }
    flag = 1;
    cout << x;
    for (int i = 1; i <= n; i++) {
        if (num[x][i] == 1 && check[i] == 0) {
            check[i] = 1;
            func(i);
        }
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> num[i][j];
        }
    }
    for (int i = 1; i <= n; i++) {
        if (check[i] == 0) {
            check[i] = 1;
            func(i);
        }
    }
    return 0;
}
```

## 540 生日礼物

>  一次只能使用一张购物券，不找零，不补现，这就意味着，小明购买的 NN 件物品中，必须有若干物品的总价值正好等于其中一张购物券的价值。现求小明能不能用购物券顺利的购物。
>
>  第一行两个正整数 N,XN,X，表示物品个数，和其中一张购物券的面额。（N≤40）（N≤40）
>
>  第二行输入 NN 个数，分别表示物品的价格。所有物品总价格不会超过 intint 范围。 
>
> 样例输入
>
> ```
> 10 2000
> 1000 100 200 300 400 500 700 600 900 800
> 10 2001
> 1000 100 200 300 400 500 700 600 900 800
> ```
>
> #### 样例输出
>
> ```
> YES
> NO
> ```

![540](/home/unique/Desktop/海贼/picture/540.png)

```c++
#include<iostream>
#include <algorithm>
using namespace std;
//set01分别记录一半，cnt用来保存多少种方案，多少个sum
int n, cost, num[45], set[2][2100000], cnt[2]; 
//set 0 前一半set 1后一半，cnt计数器
void func(int set_num, int start, int end, int sum) {
    if (sum > cost) return ;
    for (int i = start; i < end; i++) {
        sum += num[i];
        set[set_num][cnt[set_num]] = sum;
        cnt[set_num]++;
        func(set_num, i + 1, end, sum);
        sum -= num[i];
    }
}

int main() {
    while (cin >> n >> cost) {
        cnt[0] = cnt[1] = 0;
        for (int i = 0; i < n; i++) {
            cin >> num[i];
        }
        //分两部分
        func(0, 0, n / 2, 0);
        func(1, n / 2, n, 0);
        sort(set[1], set[1] + cnt[1]);
        int flag = 0;
        for (int i = 0; i < cnt[0]; i++) {
            int target = cost - set[0][i];
            int l = 0, r = cnt[1] - 1;
            while (l <= r) {
                int mid = (l + r) / 2;
                if (set[1][mid] == target) {
                    cout << "YES" << endl;
                    flag = 1;
                    break;
                }
                if (set[1][mid] < target) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
            if (flag == 1) break;
        }
        if (flag == 0) cout << "NO" << endl;
    }
    return 0;
}
```

## 541相遇

>整个农场共有 NN 个牧场，11 号牧场就是谷仓，NN 号牧场是她们最喜爱的牧场。整个农场是建在一个山坡上的，如果 X<YX<Y，则代表 XX 号牧场比 YY 牧场要高。有 MM 条路径连接一堆牧场。然而，由于每条路径都很陡，每条路只能向下山的方向走。比如，一条连接 55 号和 88 号农场的路只能从 55 走到 88 而不能反过来，因为那样就是向山上走了。每对牧场之间最多有一条路径，故 M≤N(N−1)/2M≤N(N−1)/2。
>
> 贝丽斯和艾丽斯可能需要不同的时间来走过一条路径。例如，贝丽斯可能花 1010 个单位的时间，而艾丽斯会花 2020 个单位，而且她们只在路径上花时间，在牧场上是不花时间的。
>
> 请帮助决定贝丽斯和艾丽斯至少要花多少时间，使她们能同时到达她们最喜爱的农场。
>
>#### 输入
>
> 第一行两个整数 N,MN,M。
>
> 接下来的 MM 行，每行有四个整数 A,B,C,DA,B,C,D，表示 AA 牧场和 BB 牧场是被连接的，CC 是贝丽斯经过这条路要花的时间，DD 是艾丽斯经过这条路要花的时间。CC 和 DD 的范围是 1∼10001∼1000。
>
>#### 输出
>
> 输出一行一个整数，表示贝丽斯和艾丽斯至少要花多少时间使她们能同时到达她们最喜爱的农场。如果这是不可能的，或者根本就没有路径使她们能到达她们最喜爱的农场，在一行输出 IMPOSSIBLEIMPOSSIBLE。
>
>------
>
>#### 样例输入
>
>```
>3 3
>1 3 1 2
>1 2 1 2
>2 3 1 2
>```
>
>#### 样例输出
>
>```
>2
>```

因为本题中提到“一条连接 5 号和 8 号农场的路只能从 5 走到 8 而不能反过来，因为那样就是向山上走了。每对牧场之间最多有一条路径”，所以是从小到大的

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;

int n, m, atime[2][20][20], ans[2][100000], ans_num[2];
//ppl 哪个人 loc从哪开始走 cose花费多长时间
void func (int ppl, int loc, int cost) {
    if (loc == n) {
        ans[ppl][ans_num[ppl]] = cost;
        //记录方法总数
        ans_num[ppl]++;
        return ;
    }
    //从1 到2 到3 一直按顺序往下所需要花费的时间
    for (int i = loc + 1; i <= n; i++) {
        if (atime[ppl][loc][i]) {
            func(ppl, i, cost + atime[ppl][loc][i]);
        }
    }
}

int main () {
    cin >> n >> m;
    for (int i = 0; i  <m ; i++) {
        int a, b, c, d;
        cin >> a >> b >> c >> d;
        //表示从a到b和b从到a的时间是一样的
        atime[0][a][b] = atime[0][b][a] = c;
        atime[1][a][b] = atime[1][b][a] = d;
    }
    func(0, 1, 0);
    func(1, 1, 0);
    sort(ans[0], ans[0] + ans_num[0]);
    sort(ans[1], ans[1] + ans_num[1]);//排序
    for (int i = 0; i < ans_num[0]; i++) {//找是否有相同的
        for (int j = 0; j < ans_num[1]; j++) {
            if (ans[0][i] == ans[1][j]) {
                cout << ans[0][i] << endl;
                return 0;
            }
        }
    }
    cout << "IMPOSSIBLE" << endl;
    return 0;
}
```

## 542 奶酪

> 现有一块大奶酪，它的高度为 hh，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中， 奶酪的下表面为 z=0z=0，奶酪的上表面为 z=hz=h。
>
>  现在，奶酪的下表面有一只小老鼠 JerryJerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 JerryJerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，JerryJerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，JerryJerry 则可以从空洞跑到奶酪上表面。
>
>  位于奶酪下表面的 JerryJerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑到奶酪的上表面去?
>
>  空间内两点P1(x1,y1,z1)P1(x1,y1,z1)、P2(x2,y2,z2)P2(x2,y2,z2)的距离公式如下：
>
> x1-x2的平方加上y1-y2的平方加上z1-z1的平方
>
> #### 输入
>
>  每个输入包含多组数据。
>
>  数据的第一行，包含一个正整数 TT，代表该输入文件中所含的数据组数。
>
>  接下来是 TT 组数据，每组数据的格式如下：
>
>  第一行包含三个正整数 n,hn,h 和 rr，两个数之间以一个空格分开，分别代表奶酪中空洞的数量，奶酪的高度和空洞的半径。
>
>  接下来的 nn 行，每行包含三个整数 x,y,zx,y,z，两个数之间以一个空格分开，表示空洞球心坐标为(x,y,z)(x,y,z)。
>
> #### 输出
>
>  输出共 TT 行，分别对应 TT 组数据的答案，如果在第 ii 组数据中，JerryJerry 能从下 表面跑到上表面，则输出 YesYes，如果不能，则输出 NoNo。
>
> ------
>
> #### 样例输入
>
> ```
> 3 
> 2 4 1 
> 0 0 1 
> 0 0 3 
> 2 5 1 
> 0 0 1 
> 0 0 4 
> 2 5 2 
> 0 0 2 
> 2 0 4
> ```
>
> #### 样例输出
>
> ```
> Yes
> No
> Yes 
> ```

本题思路：先找到起点和终点，然后对相通的圆做一个边的处理，用二维数组表示出来，然后用538的方法做

```C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <cstring>
#include <cmath>
#include <ctime>
#include <iomanip>
using namespace std;

int t, n , h , r, qiu[1005][3], low[1005], low_num, up[1005], arr[1005][1005], check[1005];

int func(int now) {
    if (up[now] == 1) return 1;
    for (int i = 1;i <= n; i++) {
        if (arr[now][i] && check[i]== 0) {
            check[i] = 1;
            if (func(i)) return 1;
        }
    }
    return 0;
}
int main(){
    cin >> t ;
    while (t--) {
        memset(low, 0 , sizeof(low));
        memset(up, 0 , sizeof(up));
        memset(arr, 0 , sizeof(arr));
        memset(check, 0 , sizeof(check));
        low_num = 0;
        cin >> n >> h >> r;
        for (int i = 1;i <= n;i++) {
            //x, y, z
            cin >> qiu[i][0] >> qiu[i][1] >> qiu[i][2];
            if (qiu[i][2] <= r) {
                low[low_num] = i;
                low_num++;
            }
            if (qiu[i][2] + r >= h) {
                up[i] = 1;
            }
            for (int j = 1; j < i ;j++) {
                int t0 = qiu[i][0] - qiu[j][0];
                int t1 = qiu[i][1] - qiu[j][1];
                int t2 = qiu[i][2] - qiu[j][2];
                //两个洞相交，带表连通，就将连通数组设为1
                if (sqrt(t0 * t0 + t1 * t1 + t2 * t2) <= 2 * r) {
                    //i到j和j到i都能走
                    arr[i][j] = arr[j][i] = 1;
                }
            }
        }
        int flag = 0;
        for (int i = 0;i <= low_num; i++) {
            if (check[i] == 0) {
                check[i] = 1;
                if (func(i)) {
                    cout << "Yes" << endl;
                    flag = 1;
                    break;
                }
            }
        }
        if (flag == 0) {
        cout << "No" << endl;
        }
    }    
    return 0;
}
```

## 80 小明看电影

> #### 样例输入1
>
> ```
> 4 5
> s####
> ....#
> #####
> #...g
> ```
>
> #### 样例输出1
>
> ```
> No
> ```
>
> #### 样例输入2
>
> ```
> 4 4
> ...s
> ..##
> ....
> .g..
> ```
>
> #### 样例输出2
>
> ```
> 5
> ```
>
>  s到g最小步数 

```c++
#include <iostream>
#include <queue>
using namespace std;

struct node {
    int x, y, step;
};

int n, m;
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
char mmap[505][505];
queue<node> que;

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> mmap[i][j];
            if (mmap[i][j] == 's') {
                /*node temp;
                temp.x = i;
                temp.y = j;
                temp.step = 0;
                que.push(temp);*/
                que.push({i, j, 0});
            }
        }
    }
    while (!que.empty()) {
        node temp = que.front();
        que.pop();
        for (int i = 0; i < 4; i++) {
            int x = temp.x + dir[i][0];
            int y = temp.y + dir[i][1];
            if (mmap[x][y] == 'g') {
                cout << temp.step + 1 << endl;
                return 0;
            }
            if (mmap[x][y] == '.') {
                mmap[x][y] = 0;
                que.push({x, y, temp.step + 1});
            }
        }
    }
    cout << "No" << endl;
    return 0;
}
```

## 304 骑士风度的牛

八个方向，广搜，从一个点出发，将这个点能走的地方都压入队列，然后在一次遍历每个点然后将遍历过的点弹出队列，对队列中的下一个队首元素能走的点进行遍历

>从K到H最小步数，在农场里像骑士一样地跳（就是我们熟悉的象棋中马的走，
>
>#### 样例输入
>
>```
>10 11
>..........
>....*.....
>..........
>...*.*....
>.......*..
>..*..*...H
>*.........
>...*...*..
>.K........
>...*.....*
>..*....*..
>```
>
>#### 样例输出
>
>```
>5
>```

```
#include<iostream>
#include<queue>
using namespace std;
int dir[8][2] = {
    1, 2, 1, -2, 2, 1, 2, -1,
    -1, 2, -1, -2, -2, 1, -2, -1
};

struct node {
    int x, y, step;
};

int n, m;
char mmap[200][200];
int main() {
    cin >> m >> n;
    queue <node> que;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> mmap[i][j];
            if (mmap[i][j] == 'K') {
                que.push({i, j, 0});
            }
        }
    }
    while (!que.empty()) {
        node temp = que.front();
        que.pop();
        for (int i = 0; i < 8; i++) {
            int x = temp.x + dir[i][0];
            int y = temp.y + dir[i][1];
            if (x < 1 || y < 1 || x > n || y > m) continue;
            if (mmap[x][y] == 'H') {
                cout << temp.step + 1 << endl;
                return 0;
            }
            if (mmap[x][y] == '.') {
                mmap[x][y] = 0;
                que.push({x, y, temp.step + 1});
            }
        }
    }
    return 0;
}
```

## 303 矩阵遍历一

就是看每个0到最近的1 距离，因为数据量大所以可以换一个方向看此题，就是将1视为起点，找距离他最近的0的距离，__从1的位置遍历，先提前将1所在位置置为-1，因为1到1的距离为0，为了区分是距离为0还是终点0，避免重复搜索__

> #### 题目描述
>
> 假设我们有一个矩阵，其元素值非 0 即 1：
>
> ```
> a11 … … a1m
> 
> … … … … …
> 
> an1 … … anm 
> ```
>
> 定义 aijaij 与 aklakl 之间的距离为 D(aij,akl)=abs(i−k)+abs(j−L)D(aij,akl)=abs(i−k)+abs(j−L)。
>
> 现求每个元素到最近的元素值为 11 的元素的距离。
>
> ------
>
> #### 输入
>
>  输入文件的第一行为两个整数，分别代表 nn 和 mm。
>
>  接下来的 nn 行，第 ii 行的第 jj 个字符代表 aijaij。
>
> #### 输出
>
>  输出包含 NN 行，每行 MM 个用空格分开的数字，其中第 ii 行第 jj 个数字代表 Min(D(aij,axy)1≤x≤N,1≤y≤mMin(D(aij,axy)1≤x≤N,1≤y≤m，且 axy=1axy=1。
>
> ------
>
> #### 样例输入
>
> ```
> 3 4
> 0001
> 0011
> 0110
> ```
>
> #### 样例输出
>
> ```
> 3 2 1 0
> 2 1 0 0
> 1 0 0 1
> ```

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#include<cmath>
using namespace std;
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
struct node {
    int x, y, step;
};
queue <node> que;
int n, m;
char mmap[1005][1005];
int ans[1005][1005];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> mmap[i][j];
            if (mmap[i][j] == '1') {
                que.push({i, j, 0});//将1压入队列
                ans[i][j] = -1;//置为-1
            }
        }
    }
    while(!que.empty()) {
        node temp = que.front();
        que.pop();
        for (int i = 0; i < 4; i++) {
            int x = temp.x + dir[i][0];
            int y = temp.y + dir[i][1];
            if (x < 1 || y < 1 || x > n || y > m || ans[x][y]) continue;
            ans[x][y] = temp.step + 1;
            que.push({x, y, ans[x][y]});
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j ++) {
            (j != 1) && cout << " ";
            if (ans[i][j] == -1) cout << 0;
            else cout << ans[i][j];
        }
        cout << endl;
    }
    return 0;
}
```



## 398 马的遍历

>  有一个 nn 行 mm 列的棋盘( 1<n,m≤4001<n,m≤400 )，在某个点上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。
>
> ------
>
> #### 输入
>
>  一行四个整数，分别表示棋盘大小 n,mn,m 和马的位置 x,yx,y。
>
> #### 输出
>
>  一个 n∗mn∗m 的矩阵，代表马到达某个点最少要走几步，每两个数之间用空格隔开，若此点不可达则输出 −1−1。
>
> ------
>
> #### 样例输入
>
> ```
> 3 3 1 1
> ```
>
> #### 样例输出
>
> ```
> 0 3 2    
> 3 -1 1    
> 2 1 4    
> ```

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#include<cmath>
using namespace std;
struct node {
    int x, y, step;
};
queue <node> que;
int dir[8][2] = {
    1, 2, 1, -2, 2, 1, 2, -1,
    -1, 2, -1, -2, -2, 1, -2, -1
};
int n, m, x, y;
int mmap[405][405];
int main() {
    cin >> n >> m >> x >> y;
    mmap[x][y] = -1;
    que.push({x, y, 0});
    while (!que.empty()) {
        node t = que.front();
        que.pop();
        for (int i = 0; i < 8; i++) {
            int x = t.x + dir[i][0];
            int y = t.y + dir[i][1];
            if (x < 1 || y < 1|| x > n || y > m || mmap[x][y]) continue;
            mmap[x][y] = t.step + 1;
            que.push({x, y, mmap[x][y]});
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            (j != 1) && cout << " ";
            if (mmap[i][j] == 0) cout << -1;
            else if (mmap[i][j] == -1) cout << 0;
            else cout << mmap[i][j];
        }
        cout << endl;
    }
    return 0;
}
```

## 305 乳草的入侵

__注意__坐标从左下角开始，所以y不变x= n - x + 1

> #### 题目描述
>
>  约翰一直努力让他的草地充满鲜美多汁的而又健康的牧草。可惜天不从人愿，他在植物大战人类中败下阵来。邪恶的乳草已经在他的农场的西北部份佔领了一片立足之地。
>
>  草地像往常一样，被分割成一个高度为 Y(1≤y≤100)Y(1≤y≤100)，宽度为 X(1≤x≤100)X(1≤x≤100) 的直角网格。(1,1)(1,1) 是左下角的格（也就是说坐标排布跟一般的 X,YX,Y 坐标相同）。乳草一开始占领了格 (Mx,My)(Mx,My)。每个星期，乳草传播到已被乳草占领的格子四面八方的每一个没有很多石头的格（包括垂直与水平相邻的和对角线上相邻的格）。11 周之后，这些新占领的格又可以把乳草传播到更多的格里面了。
>
>  骑士牛想要在草地被乳草完全占领之前尽可能的享用所有的牧草。她很好奇到底乳草要多久才能占领整个草地。如果乳草在 00 时刻处于格 (Mx,My)(Mx,My)，那么还在那个时刻它们可以完全占领入侵整片草地呢。草地由一个矩阵表示。.. 表示草，而 ∗∗ 表示大石。比如这个 X=4,Y=3X=4,Y=3的例子。
>
> ```
>  ....
>  ..*.
>  .**.
> ```
>
> 如果乳草一开始在左下角（第 11 排，第 11 列），那么草地的地图将会以如下态势发展：
>
> ```
>   ....  ....  MMM.  MMMM  MMMM  
>   ..*.  MM*.  MM*.  MM*M  MM*M  
>   M**.  M**.  M**.  M**.  M**M  
>    0     1     2     3     4    星期数
> ```
>
> 乳草会在4星期后占领整片土地。

```c++
#include<iostream>
#include<queue>
using namespace std;
int n, m, x, y;
char mmap[105][105];

struct node {
    int x, y, step; 
};
int dir[8][2] = {
    1, 0, 0, 1, -1, 0, 0, -1,
    1, 1, 1, -1, -1, 1, -1, -1
};
int main() {
    cin >> m >> n >> y >> x;
    for (int i = 1; i <= n ; i++) {
        cin >> &mmap[i][1];
    }
    queue <node> que;
    que.push({n - x + 1, y, 0});
    mmap[n - x + 1][y] = '*';
    int ans;
    while (!que.empty()) {
        node t = que.front();
        que.pop();
        ans = t.step;
        for (int i = 0; i < 8; i++) {
            int x = t.x + dir[i][0];
            int y = t.y + dir[i][1];
            if (mmap[x][y] == '.') {
                mmap[x][y] = '*';
                que.push({x, y, t.step + 1});
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```

## 527 鸟人

__去重数组第一一个三维的代表飞当前点剩余的能量，然后遍历，从2开始飞知道能量耗尽，然后在走__

>  在一片广阔的土地上，有一个鸟人，他需要从这里穿过原野，回到基地。这片原野上，有平地 (P)(P)、有湖泊 (L)(L)，因为鸟人可以飞，所以呢，有的时候，他可以飞越湖泊。现在，鸟人需要用最快的时间，回到基地。
>
>  假设原野是一个 m∗nm∗n 的矩阵，有两种地形，用 PP 和 LL 表示。鸟人只能停留在平地上。他目前处在 (1,1)(1,1) 这个位置，而目的地是 (m,n)(m,n)，起点和目的地必为平地。他可以向上下左右四个方向移动，或者飞行。每移动一格需要 11 个单位时间。而飞行无论飞多远，都只需要 11 个单位时间。飞行的途中不可以变方向，也就是说飞行也只能是上下左右四个方向。并且一次飞行最终必须降落在平地上。当然，受到能量的限制，鸟人不能无限制的飞行，他总共最多可以飞行的距离为 DD（总计飞行距离，不是一次飞行距离）。现求飞到目的地的最短时间，若无法到达则输出 impossibleimpossible。
>
> #### 样例输入
>
> ```
> 4 4 2
> PLLP
> PPLP
> PPPP
> PLLP
> ```
>
> #### 样例输出
>
> ```
> 5
> ```

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
using namespace std;
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
struct node {
    int x, y, s, d;
};
int n, m, d, check[105][105][105];//表示飞到当前这个点剩余能量
char mmap[105][105];


int main() {
    queue <node> que;
    cin >> n >> m >> d;
    for (int i = 1; i <= n; i++) {
        cin >> &mmap[i][1];
    }
    que.push({1, 1, 0, d});
    for (int i = 0; i <= d; i++) {
        check[1][1][i] = 1;//起点的所有情况都标记一下，可能飞回来
    }
    while (!que.empty()) {
        node temp = que.front();
        que.pop();
        for (int i = 0; i < 4; i++) {//飞
            for (int j = 2; j <= temp.d; j++) {//最起码飞2，一个就走了
                int x = temp.x + j * dir[i][0];//在当前方向上飞j步
                int y = temp.y + j * dir[i][1];
                if (x == n && y == m) {
                    cout << temp.s + 1 << endl;
                    return 0;
                }
                if (mmap[x][y] == 0) break;//边界直接，break
                //点可走并且没走过
                if (mmap[x][y] == 'P' && check[x][y][temp.d - j] == 0) {
                    check[x][y][temp.d - j] = 1;
                    que.push({x, y, temp.s + 1, temp.d - j});
                }
            }
            int x = temp.x + dir[i][0];
            int y = temp.y + dir[i][1];
            if (x == n && y == m) {
                cout << temp.s + 1 << endl;
                return 0;
            }
            if (mmap[x][y] == 'P' && check[x][y][temp.d] == 0) {
                check[x][y][temp.d] = 1;
                que.push({x, y, temp.s + 1, temp.d});
            }
        }
    }
    cout << "impossible" << endl;
    return 0;
}
```

## 379 龙与虫

__以敌人为起点，找到能杀死敌人的八个方向，只要虫子走到这八个当中的一个就可以杀死敌人，所以问题转变成找到这八个方向最近的点__

![529](/home/unique/Desktop/海贼/picture/529.png)

> #### 题目描述
>
>  给出一张 n∗mn∗m 的地图，在地图上有一只虫，样子却很像龙，而且嘴能快速的直射喷出一种毒液，瞬间杀死敌人。
>
>  现在假设虫的初始位置在 x1,y1x1,y1，另外在 x2,y2x2,y2 处有一个敌人。假设虫移动一步需要单位 11 的时间，而杀死敌人不需要时间，并且虫的毒液射程无穷大，但毒液不能穿透障碍物，虫可以向四个方向移动，向八个方向攻击，求虫最少需要多少时间才能消灭敌人。
>
> ------
>
> #### 输入
>
>  第一行两个整数 n,mn,m。（1≤n,m≤128）（1≤n,m≤128）
>
>  接下来是一个 n∗mn∗m 的矩阵，OO 表示空地，XX 表示障碍物。
>
>  再接下来每行对应一组数据，对于每组数据，一行四个整数分别表示 x2,y2,x1,y1x2,y2,x1,y1，数据不多于十组。
>
>  读入 0,0,0,00,0,0,0 表示程序结束。
>
> #### 输出
>
>  对于每组数据，输出一行一个数，表示消灭敌人的最短时间，若无法消灭敌人，则输出 Impossible!Impossible!。
>
> ------
>
> #### 样例输入
>
> ```
> 3 4
> OXXO
> XXOO
> XOOO
> 3 2 2 4
> 3 3 1 1
> 0 0 0 0
> ```
>
> #### 样例输出
>
> ```
> 1
> Impossible!
> ```

```c++
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;

struct node {
    int x, y, step;
};

int n, m, check[150][150];
char mmap[150][150];
int dir[8][2] = {
    0, 1, 1, 0, 0, -1, -1, 0,
    1, -1, 1, 1, -1, -1, -1, 1
};
int func() {
    int a, b, c, d;
    cin >> c >> d >> a >> b;
    if (!a) return 0;
    memset(check, 0, sizeof(check));
    for (int i = 0; i < 8; i++) {//找终点，也就是能杀死敌人的点
        for (int j = 1; 1; j++) {
            int x = c + j * dir[i][0];
            int y = d + j * dir[i][1];
            if (mmap[x][y] != 'O') break;//到头了或者走不了了
            check[x][y] = 2;//将终点标记为2
        }
    }
    check[c][d] = 2;//敌人所在的点也标记为2
    if (check[a][b] == 2) {//虫子和敌人在一个位置
        cout << 0 << endl;
        return 1;
    }
    queue <node> que;
    que.push({a, b, 0});
    check[a][b] = 1;
    while (!que.empty()) {
        node temp = que.front();
        que.pop();
        for (int i = 0; i < 4; i++) {
            int x = temp.x + dir[i][0];
            int y = temp.y + dir[i][1];
            if (check[x][y] == 2) {
                cout << temp.step + 1 << endl;
                return 1;
            }
            //能走并且没走过
            if (mmap[x][y] == 'O' && check[x][y] != 1) {
                check[x][y] = 1;
                que.push({x, y, temp.step + 1});
            }
        }
    }
    cout << "Impossible!" << endl;
    return 1;
}
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> &mmap[i][1];
    }
    while (func()) {  }//多组数据
    return 0;
}
```

## 81小明回家

![81](/home/unique/Desktop/海贼/picture/81.png)

__结构体多定义一个代表有没有手机，然后去重数组，为了能用一个数组标记1代表没手机时走过，2，代表有手机走过，3代表有无手机都走过，__

有手机时 23不能走  &2因为1&2 和3&2都等于2

没手机时13不能走  &1 因为1&1和3&1都等于1

> #### 题目描述
>
>  小明看完了电影，是时候回家了，可是这时他突然得知小米之家的小米9现货开卖了，这款手机小明已经想了一个多月，知道这个消息后的他十分兴奋，一定要在回家之前先去小米之家买手机（城市中有一个或多个小米之家），请计算小明从电影院到任意一个小米之家买手机后回家的最短距离（只能朝上下左右四个方向行走，除了障碍物外，其他地方都可以通过），数据保证可以买完手机后回家。
>
> ------
>
> #### 输入
>
>  第 1 行两个数 nn 和 mm 表示地图有 nn 行 mm 列 2≤n,m≤20002≤n,m≤2000 第 2 行至第 n+1n+1 行为地图 其中 SS 表示电影院 TT 表示家 PP 表示小米之家 . 为可以通过的点 # 为障碍物
>
> #### 输出
>
>  一个整数 表示小明从电影院去小米之家再回家的总距离
>
> ------
>
> #### 样例输入
>
> ```
> 5 5
> .S...
> ###..
> ....T
> .P##.
> P....
> ```
>
> #### 样例输出
>
> ```
> 11
> ```

```c++
#include<iostream>
#include<queue>
using namespace std;

struct node {
    int x, y, s, f;
};
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
int n, m, check[2005][2005];
char mmap[2005][2005];
int main() {
queue <node> que;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> mmap[i][j];
            if (mmap[i][j] == 'S') {
                que.push({i, j, 0, 0});
                check[i][j] = 1;//起点可能不止走一遍，所以也需要去重
            }
        }
    }
    while (!que.empty()) {
        node temp = que.front();
        que.pop();
        for (int i = 0; i < 4; i++) {
            int x = temp.x + dir[i][0];
            int y = temp.y + dir[i][1];
            //没手机情况下这个点走过了
            if (temp.f == 0 && check[x][y] & 1) continue;//无手机不能走1，3 1&1和3&1都等于1,而2&1=0
            //有手机情况下这个点走过了，
            if (temp.f == 1 && check[x][y] & 2) continue;//有手机不能走2，3 1&2 和3&2都等于2 而1&2=0
            if (temp.f == 1 && mmap[x][y] == 'T') {//买到手机到家了
                cout << temp.s + 1 << endl;
                return 0;
            }
            if (mmap[x][y] == '.' || mmap[x][y] == 'S' ||mmap[x][y] == 'T') {
                que.push({x, y, temp.s + 1, temp.f});
                //就相当于有手机temp.f等于1，走过这个点那么这个点就是2，有手机走过
                //没手机temp.f等于0，走过这个点那么这个点就是1，没手机走过
                check[x][y] += temp.f + 1;
            }
            //到手机店，temp.f置为1,表示有手机了
            if (mmap[x][y] == 'P') {
                que.push({x, y, temp.s + 1, 1});
                check[x][y] = 3;
            }
        }
    }
    return 0;
}
```

## 530 警察找车

> #### 题目描述
>
>  年轻的拉尔夫开玩笑地从一个小镇上偷走一辆车，但他没想到的是那车属于警察局。并且车上装有用于发身车子移动路线的装置。那个装置太旧了，以至于只能发射关于那辆车的移动路线的方向信息。
>
>  通过使用一张小镇的地图，帮助警察局找到那车。表示出该车最终所有可能的位置。
>
>  小镇的地图是矩形的，上面的符号用来标明那儿可以行车和那儿不行。“.”“.” 表示小镇上那块地方是可以行车的，符号 “X”“X” 表示此处不能行车。拉尔夫所开小车的初始位置，用字符的 “∗”“∗”，表示，且汽车能从初始位置通过。汽车能向四个方向移动：向北（上），南（下），西（左），东（右）；拉尔夫所开小车的行动路线是通过一组给定的方向来描述的，在每个给定的方向，拉尔夫驾驶小车通过小镇上的一个或更多的可行车地点。
>
> ------
>
> #### 输入
>
>  第一行两个整数 n,mn,m，表示小镇地图大小。（1≤n,m≤50）（1≤n,m≤50）
>
>  接下来是一个 n∗mn∗m 的矩阵，由 .∗X.∗X 组成，表示小镇的地图。
>
>  再接下来一行一个整数 NN，表示接下来有 NN 个方向。
>
>  接下来 NN 行，每行一个方向单词，NORTH,SOUTH,WEST,EASTNORTH,SOUTH,WEST,EAST 分别表示上下左右，代表汽车的移动方向，任何两个连续的方向都不相同。
>
> #### 输出
>
>  输出小镇的地图，在地图上，汽车最终可能出现的点用 ∗∗ 来表示。
>
> ------
>
> #### 样例输入
>
> ```
> 4  5
> .....
> .X...
> ...*X
> X.X..
> 3
> NORTH
> WEST
> SOUTH
> ```
>
> #### 样例输出
>
> ```
> .....
> *X*..
> *.*.X
> X.X..
> ```

```c++
#include<iostream>
#include<cstdio>
#include<string>
#include <cstring>
#include<queue>
#include<algorithm>
#include<cmath>
using namespace std;

struct node {
    int x, y;
};

int dir[4][2] = {-1, 0, 1, 0, 0, -1, 0, 1};
char mmap[60][60];
int n, m, cnt;
int check[60][60];

int main() {
    cin >> n >> m;
    queue <node> que;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j ++) {
            cin >> mmap[i][j];
            if (mmap[i][j] == '*') {
                que.push({i, j});
                mmap[i][j] = '.';
                check[i][j] = 1;
            }
        }
    }
    cin >> cnt;
    while (cnt--) {
        string t;
        cin >> t;
        int dir_num;
        if (t == "NORTH") {
            dir_num = 0;
        } else if (t == "SOUTH"){
            dir_num = 1;
        } else if (t == "WEST") {
            dir_num = 2;
        } else {
            dir_num = 3;
        }
        memset(check, 0, sizeof(check));//标记数组每层标记一次以免漏掉
        int times = que.size();
        for (int i = 0; i < times; i++) {
            node temp = que.front();
            que.pop();
            for (int j = 1; 1; j++) {
                int x = temp.x + j * dir[dir_num][0];
                int y = temp.y + j * dir[dir_num][1];
                if (mmap[x][y] != '.') break;
                if (!check[x][y]) {
                    que.push({x, y});
                    check[x][y] = 1;
                }
            }
        }
    }
    while (!que.empty()) {//最后队列中剩下的就是答案,将其标记为'*'
        node temp = que.front();
        que.pop();
        mmap[temp.x][temp.y] = '*';
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cout << mmap[i][j];
        }
        cout << endl;
    }
    return 0;
}
```

## 531 奇怪的电视

> 小明过年的时侯去如姥姥家，除夕之夜，大家都想看春节联欢晚会，而可以依赖的就是一台旧电视。
>
>  那一台旧电视不是遥控器控制的，上面有许多按钮，按下某一按钮，其他按钮都将被释放，只有被按的按钮工作（如果其他按钮本来就是释放的状态，那么它们保持不变，处于按下状态的按钮不能重复按下，这对下文依旧适用）。当小明到来的那一天，上面的许多按钮突然无法正常工作。现在按下某个按钮后，有一些按钮将被释放，而另外的一些按钮将不改变原状态。经过一番惨无人道的折腾，小明知道按下每一个按钮会产生什么样的效果。现在他只需要第3个按钮正常工作。
>
>  现在帮助小明计算，从给定的状态到只有按钮3工作，而其他按钮都被释放这个最终状态所需按下的按钮序列的最短长度。
>
> ------
>
> #### 输入
>
>  第一行一个整数 NN，表示按钮数。（3≤N≤20）（3≤N≤20）
>
>  第二行包含 NN 个数，表示各按钮的初始状态。00 表示相应的按钮是释放的，11 表示相应的按钮是按下的。
>
>  接下来的 NN 行，表示按下某个按钮时将有那些按钮被释放。第 M+2M+2 行由数字 KK 开头，紧跟着 KK 个数字（按升序排列），表示当按下按钮 MM 时被释放的按钮数及按钮号码（按钮号码用数字 1∼M1∼M 表示）。每个按钮不能释放其本身，也可能不释放任何按钮。
>
> #### 输出
>
>  输出一个数，表示从给定的状态到只有按钮3工作而其他按钮都被释放这个最终状态所需按下的按钮序列的最短长度。
>
> #### 样例输入
>
> ```
> 5
> 1 1 0 0 1
> 4 2 3 4 5
> 4 1 3 4 5
> 2 2 4
> 0
> 4 1 2 3 4
> ```
>
> #### 样例输出
>
> ```
> 3 
> ```

```C++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#include<cmath>
using namespace std;
struct node {
    int status, step;
};
int n, num[25], arr[25][25], check[2200000];

void init() {
    int t = 1;
    for (int i = 0; i < 21; i++) {
        num[i] = t;
        t *= 2;
    }
}

int main() {
    init();
    cin >> n;
    int start_status = 0;
    for (int i = 1; i <= n; i++) {
        int t;
        cin >> t;
        if (t == 1) start_status += num[i];//初始状态
    }
    for (int i = 1; i <= n; i++) {
        cin >> arr[i][0];//会有几个按钮被弹回来
        for (int j = 1; j <= arr[i][0]; j++) {
            cin >> arr[i][j];
            arr[i][24] += num[arr[i][j]];//按下第i个按钮会
        }
    }
    queue <node> que;
    que.push({start_status, 0});
    check[start_status] = 1;
    while (!que.empty()) {
        node temp = que.front();
        que.pop();
        if (temp.status == 8) {//终点也就是只有按钮3 按下去了01000
            cout << temp.step << endl;
            return 0;
        }
        for (int i = 1; i <= n; i++) {
            if ((temp.status & num[i]) == 0) {//该按钮没被按下去
                int status_temp = temp.status + num[i];
                //按i后被弹出来的按钮的二进制取反 那么应被弹出去的按钮所对应的二进制位就应该是0 在&上当前位置那么，应被弹出按钮二进制位置一定会变为0
                status_temp &= ~(arr[i][24]);//按i按钮后的状态
                if (!check[status_temp]) {//去重 
                    check[status_temp] = 1;
                    que.push({status_temp, temp.step + 1});
                }
            }
        }
    }
    return 0;
}
```

# 二分方法

## 387 吃瓜群众升级版

> 题目描述
>
> 某地总共有 MM 堆瓜，第 ii 堆瓜的数量为 XiXi。现有 NN 组群众现在想要吃瓜，第 ii 组群众想要吃的瓜的数量为 YiYi。现在对于每组想吃瓜的群众，需要在 MM 堆瓜中查找大于等于需要数量的第一堆瓜，并输出那堆瓜的编号，若所有瓜堆的数量均小于需要数量，则输出 00。
>
>------
>
>#### 输入
>
> 输入共 33 行。
>
> 第一行两个整数 M,NM,N。
>
> 第二行 MM 个整数分别表示 X1,X2......XMX1,X2......XM。（保证各不相同）
>
> 第三行 NN 个整数分别表示 Y1,Y2......YNY1,Y2......YN。（保证各不相同）
>
>#### 输出
>
> 对于每个 YiYi 输出一行一个整数为大于等于需要数量的第一堆瓜的编号，若所有瓜堆的数量均小于需要数量，则输出 00。
>
>------
>
>#### 样例输入
>
>```
>5 5
>1 3 26 7 15
>27 10 3 4 2
>```
>
>#### 样例输出
>
>```
>0
>5
>2
>4
>2
>```

```c++
#include<iostream>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
struct node {
    int num, val;
};

bool cmp (node a, node b) {
    return a.val < b.val;
}

node wm[100005];
int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        cin >> wm[i].val;
        wm[i].num = i + 1;
    }
    sort(wm, n + wm, cmp);
    for (int i = 0; i < m; i++) {
        int t;
        cin >> t;
        if (t > wm[n - 1].val) {    
            cout << 0 << endl;
            continue;
        }
        int l = 0, r = n - 1;
        while (l != r) {
            int mid = (l + r) / 2;
            if (wm[mid].val >= t) {//要找到第一个大于X的数，相当与于一堆0找第一个出现的1
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        cout << wm[l].num << endl;
    }
    return 0;
}
```

## 390 原木切割

>  某林业局现在 NN 根原木，长度分别为 XiXi，为了便于运输，需要将他们切割成长度相等的 MM 根小段原木（只能切割成整数长度，可以有剩余），小段原木的长度越大越好，现求小段原木的最大长度。例如，有 33 根原木长度分别为 6,15,226,15,22，现在需要切成 88 段，那么最大长度为 55。
>
> ------
>
> #### 输入
>
>  第一行两个整数 N,MN,M。（1≤N≤100,000，1≤M≤100,000,000）（1≤N≤100,000，1≤M≤100,000,000）
>
>  接下来 NN 行，每行一个数，表示原木的长度 XiXi。（1≤Xi≤100,000,0001≤Xi≤100,000,000）
>
> #### 输出
>
>  输出小段原木的最大长度，如果根本切不出 MM 段，则输出 00。
>
> ------
>
> #### 样例输入
>
> ```
> 3 8
> 6
> 15
> 22
> ```
>
> #### 样例输出
>
> ```
> 5
> ```

```c++
#include <iostream>
#include <algorithm>
using namespace std;

int n, m, num[100005], mmax;

int func(int len) {
    int cnt = 0;
    for (int i = 0; i < n ; i++) {
        cnt += num[i] / len;
    }
    return cnt;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        cin >> num[i];
        mmax = max(mmax, num[i]);
    }
    int l = 0, r = mmax;
    while (l != r) {
        int mid = (l + r + 1) / 2;
        int s = func(mid);
        if (s >= m) l = mid;//1111111000000找最后一个1
        else r = mid - 1;
    }
    cout << l << endl;
    return 0;
}
```

## 389 暴躁的程序员

> #### 题目描述
>
>  某公司的程序猿每天都很暴躁，因为他们每个人都认为其他程序猿和自己风格不同，无法一同工作，当他们的工位的编号距离太近时，他们可能会发生语言甚至肢体冲突，为了尽量避免这种情况发生，现在公司打算重新安排工位，因为有些关系户的工位是固定的，现在只有一部分工位空了出来，现在有 NN 个程序猿需要分配在 MM 个工位中，第 ii 个工位的编号为 XiXi，工位编号各不相同，现在要求距离最近的两个程序猿之间的距离最大，求这个最大距离是多少。XiXi 和 XjXj 工位之间距离为|Xi−Xj||Xi−Xj|。
>
> ------
>
> #### 输入
>
>  输入共 M+1M+1 行。
>
>  第一行两个整数 M,NM,N。（1≤N≤M≤100,000）（1≤N≤M≤100,000）
>
>  接下来 MM 行，每行一个数，表示剩余的工位的编号。
>
> #### 输出
>
>  输出距离最近的两个程序猿之间的最大距离。
>
> ------
>
> #### 样例输入
>
> ```
> 5 3
> 1
> 2
> 8
> 4
> 9
> ```
>
> #### 样例输出
>
> ```
> 3
> ```

```C++
#include<iostream>
#include <algorithm>
using namespace std;

int n, m, num[100005], mmax;

int func2(int len) {//当前值能安排多少人
    int cnt = 1, now = 0;//人数，上一个人位置
    for (int i = 1; i < n; i++) {
        if (num[i] - num[now] >= len) {
            cnt++;
            now = i;
        }
    }
    return cnt;
}

int func() {
    int l = 0, r = mmax;
    while (l != r) {
        int mid = (l + r + 1) / 2;
        int cnt = func2(mid);
        //当前mid可能是最终答案,1111111000000找最后一个1
        if (cnt >= m) l = mid;
        //小于m一定不是所求，故r = mid-1
        else r = mid - 1;
    }
    return l;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        cin >> num[i];
        mmax = max(mmax, num[i]);
    }
    sort(num, num + n);
    cout << func() << endl;

    return 0;
}
```

## 391. 数列分段

__求每段和的最大值最小，所以选好上下界,下界就是一段一个数，那么每段和最大的就是每段当中最大的内个数。上界就是所有的数放在一段里，也就是每个数加起来。然后二分每段的和，调用函数，看看用当前的和值能分成几段，最后和题中给的要求的段数作比较，如果当前mid>m,说明值小了，所以移L,想当于000001111，所以l = mid + 1__

>  对于给定的一个长度为 NN 的正整数数列 AiAi，现要将其分成 M(M≤N)M(M≤N) 段，并要求每段连续，且每段和的最大值最小。
>
> 关于最大值最小：
>
> 例如一数列 4 2 4 5 14 2 4 5 1 要分成 33 段
>
> 将其如下分段：
>
> [4 2][4 5][1][4 2][4 5][1]
>
> 第 11 段和为 66，第 22 段和为 99，第 33 段和为 11，和最大值为 99。
>
> 将其如下分段：
>
> [4][2 4][5 1][4][2 4][5 1]
>
> 第 11 段和为 44，第 22 段和为 66，第 33 段和为 66，和最大值为 66。
>
> 并且无论如何分段，最大值不会小于 66。
>
> 所以可以得到要将数列 4 2 4 5 14 2 4 5 1 要分成 33 段，每段和的最大值最小为 66。
>
> ------
>
> #### 输入
>
>  第一行两个整数 N,MN,M。（1≤M≤N≤100,000）（1≤M≤N≤100,000）
>
>  接下来 NN 行，每行一个数，表示 AiAi。（1≤Ai≤100,000,0001≤Ai≤100,000,000）
>
> #### 输出
>
>  一个正整数，即每段和最大值最小为多少。
>
> ------
>
> #### 样例输入
>
> ```
> 5 3
> 4
> 2
> 4
> 5
> 1
> ```
>
> #### 样例输出
>
> ```
> 6
> ```

```c++
#include <iostream>
using namespace std;
typedef long long ll;

ll n, m, num[100005], mmax, x;

ll check(ll mid) {//每段和为mid
    int now = 0, cnt = 0;
    for (int i = 0; i < n; i++) {
        if (now + num[i] == mid) {
            cnt++;
            now = 0;
        } else if (now + num[i] > mid) {
            cnt++;
            now = num[i];
        } else {
            now += num[i];
        }
    }
    if (now > 0) cnt++;
    return cnt;
}

ll func() {
    ll l = x, r = mmax;//和最大的最小值，所以下界是每个数字自己一段，那么下界就是最大的内个数‘
    while (l != r) {//二分答案
        ll mid = (l + r) / 2;
        ll cnt = check(mid);//cnt代表分成几段
        if (cnt > m) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }
    return l;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        cin >> num[i];
        mmax += num[i];//确定上下界
        x = max(x, num[i]);
    }
    cout << func() << endl;
    return 0;
}
```

## 392丢瓶盖

__二分距离，定好上下界__

>  小明小时候很贪玩，在他童年时期的某一天，他在地上丢了 个瓶盖，为了简化问题，我们可以当作这 个瓶盖丢在一条直线上，现在他想从这些瓶盖里找出 个，使得距离最近的 个距离最大，他想知道，最大可以到多少呢？
>
> ------
>
> #### 输入
>
>  第一行两个整数 。
>
>  接下来 行，每行一个数，表示瓶盖的位置坐标 。（）
>
> #### 输出
>
>  一个正整数，相邻的两个瓶盖的最大距离。
>
> ------
>
> #### 样例输入
>
> ```
> 5 3
> 1
> 2
> 3
> 4
> 5
> ```
>
> #### 样例输出
>
> ```
> 2
> ```

```c++
#include <iostream>
#include <algorithm>
using namespace std;

int n, m, num[100005], mmax;

int check(int mid) {
    int cnt = 1, now = 0;
    for (int i = 1; i < n; i++) {
        if (num[i] - num[now] >= mid) {
            cnt++;//用来记录瓶盖数
            now = i;//now用来记录上一个瓶盖位置
        }
    }
    return cnt;
}

int func() {
    int l = 1, r = mmax;
    while (l != r) {
        int mid = (l + r + 1) / 2;
        int cnt = check(mid);
        if (cnt >= m) {
            l = mid;
        } else {
            r = mid - 1;
        }
    }
    return l;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        cin >> num[i];
    }
    sort(num, num + n);
    mmax = num[n - 1] - num[0];
    cout << func() << endl;
    return 0;
}
```

## 393切绳子

>  有 NN 条绳子，它们的长度分别为 LiLi。如果从它们中切割出 KK 条长度相同的绳子，这 KK 条绳子每条最长能有多长？答案保留到小数点后 22 位(直接舍掉 22 位后的小数)。
>
> ------
>
> #### 输入
>
>  第一行两个整数 NN 和 KK，接下来 NN 行，描述了每条绳子的长度 LiLi。
>
> #### 输出
>
>  切割后每条绳子的最大长度。
>
> ------
>
> #### 样例输入
>
> ```
> 4 11
> 8.02
> 7.43
> 4.57
> 5.39
> ```
>
> #### 样例输出
>
> ```
> 2.00
> ```

```c++
#include <iostream>
#include <cstdio>
using namespace std;

int n, k;
double num[10005], mmax;

int check(double mid) {
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        cnt += num[i] / mid;
    }
    return cnt;
}

double func() {
    double l = 0, r = mmax;
    while (r - l > 0.00001) {
        double mid = (l + r) / 2;
        int x = check(mid);
        if (x >= k) {
            l = mid;
        } else {
            r = mid;
        }
    }
    return l;
}

int main() {
    cin >> n >> k;
    for (int i = 0; i < n ;i++) {
        cin >> num[i];
        mmax = max(mmax, num[i]);
    }
    double ans = func();
    printf("%d.%d%d\n", (int)ans, (int)(ans * 10) % 10, (int)(ans * 100) % 10);
    return 0;
}
```

# DP 动态规划

## 背包问题

### 讲解

#### 01背包

![深度截图_选择区域_20200422194718](/home/unique/Desktop/海贼/picture/深度截图_选择区域_20200422194718.png)

```
数组ans[x][y]表示前i件物品被包容量为y时的最大价值
当前物品x小于背包剩余容量，价值为ans[x-1][y]
不小于 要x   ans[x-1][y]  不取当前物品，所以是背包中取上一个物品的价值
	  不要x max(ans[x-1][y], ans[x - 1][y - w[x]] + v[x])，看看原来的状态和要第x个物品的状态哪个价值更高
	  
"max(ans[x-1][y], ans[x-1][y-w[x]]+v[x]])"前 x − 1 件物品放入容量为y的背
包中”，价值为 ans[x − 1, y]；如果放第 i 件物品，那么问题就转化为“前 x − 1 件物品放
入剩下的容量为 y − w[x] 的背包中”
```

![DP](/home/unique/Desktop/海贼/picture/DP.png)

#### 状态压缩

__可以将其降维成一维数组，因为x这一行只与x-1有联系，所以只要通过x-1来算第x件物品的最大价值，注意！！要从后往前算，因为用一维数组，所以在变化前当前数组表示的是x-1，当更新开始时，我们需要用到x-1的值，如果从前往后更新，那么当更新到后面时，再用前面的值时此时该值已经不是x-1状态下的价值了，已经被覆盖上了新值(x状态)，所以要从后往前算__

![降wei度](/home/unique/Desktop/海贼/picture/降wei度.png)

#### 完全背包

```
当前物品x小于背包剩余容量，价值为ans[x-1][y]
不小于 要x   ans[x-1][y]
	  不要x max(ans[x-1][y], ans[x][y - w[x]] + v[x])
```



![完全背包](/home/unique/Desktop/海贼/picture/完全背包.png)

#### 状态压缩

__与当前x相关的在x列和x - 1列，所以想算后面的前面的一定要先算出来，所以从前向后算__

![完全背包状态压缩](/home/unique/Desktop/海贼/picture/完全背包状态压缩.png)

### 47 01背包

> #### 输入
>
> 第一行输入两个数 $V, n$，分别代表背包的最大承重和物品数。
>
> 接下来$n$行，每行两个数$V_i, W_i$，分别代表第i件物品的重量和价值。
>
> $(V_i \le V \le 10000, n \le 100, W_i \le 1000000)$
>
> #### 输出
>
> 输出一个整数，代表在背包不超重情况下所装物品的最大价值。
>
> ------
>
> #### 样例输入1
>
> ```
> 15 4
> 4 10
> 3 7
> 12 12
> 9 8
> ```
>
> #### 样例输出1
>
> ```
> 19
> ```

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
int all, n, w[105], v[105], ans[105][10005];

int main() {
    cin >> all >> n;
    for (int i = 1; i <= n; i++) {
        cin >> w[i] >> v[i];
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= all; j++) {
            if (j < w[i]) {
                ans[i][j] = ans[i - 1][j];
            } else {
                ans[i][j] = max(ans[i - 1][j], v[i] + ans[i - 1][j - w[i]]);
            }
        }
    }
    cout << ans[n][all] << endl;
    return 0;
}
```

__降维版__

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
int all, n, w[105], v[105], ans[10005];

int main() {
    cin >> all >> n;
    for (int i = 1; i <= n; i++) {
        cin >> w[i] >> v[i];
    }
    for (int i = 1; i <= n; i++) {
        for (int j = all; j > 0; j--) {//反着算
            /*if (j < w[i]) {
                break;直接不用覆盖了，就是原来的值没变
                ans[j] = ans[j];
            }*/ 
            if (j >= w[i]) {
                ans[j] = max(ans[j], v[i] + ans[j - w[i]]);
            }
        }
    }
    cout << ans[all] << endl;
    return 0;
}
```

### 560. 开心的金明

>  金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 NN 元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 NN 元。于是，他把每件物品规定了一个重要度，分为 55 等：用整数 1−51−5 表示，第 55 等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过 NN 元（可以等于 NN 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。
>
>  设第 jj 件物品的价格为 v[j]v[j]，重要度为 w[j]w[j]，共选中了 kk 件物品，编号依次为 j1,j2,…,jkj1,j2,…,jk，则所求的总和为：
>
> v[j1]×w[j1]+v[j2]×w[j2]+…+v[jk]×w[jk]v[j1]×w[j1]+v[j2]×w[j2]+…+v[jk]×w[jk]
>
>  请你帮助金明设计一个满足要求的购物单。
>
> ------
>
> #### 输入
>
>  第一行两个正整数，用一个空格隔开：N,mN,m（其中 N(<30000)N(<30000) 表示总钱数，m(<25)m(<25) 为希望购买物品的个数。）
>
>  从第二行到第 m+1m+1 行，第 jj 行给出了编号为 j−1j−1 的物品的基本数据，每行有 22 个非负整数 v,pv,p（其中 vv 表示该物品的价格 (v≤10000)(v≤10000)，pp 表示该物品的重要度 (1−51−5)。
>
> #### 输出
>
>  输出一个整数，表示不超过总钱数的物品的价格与重要度乘积的总和的最大值 (≤100000000)(≤100000000)。
>
> ------
>
> #### 样例输入
>
> ```
> 1000 5
> 800 2
> 400 5
> 300 5
> 400 3
> 200 2
> ```
>
> #### 样例输出
>
> ```
> 3900
> ```

```c++
//欲求重要程度乘价格最大，就可把这点作为价值,总钱数相当于背包重量
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
#define MAX_N 30000
int value[MAX_N + 5], weight[MAX_N + 5], ans[MAX_N + 5];
int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        cin >> weight[i] >> value[i];
    }
    for (int i = 1; i <= m; i++) {
        for (int j = n; j > 0; j--) {
            if (j < weight[i]) break;
            else ans[j] = max(ans[j], ans[j - weight[i]] + (value[i] * weight[i]));
        }
    }
    cout << ans[n] << endl;
    return 0;
}
```

### 48 完全背包

> ### 题目描述
>
> 有N种物品和一个容量为 VV 的背包，每种物品都有无限件可用。
>
> 第 ii 种物品的体积是CiCi，价值是WiWi。求解在不超过背包容量的情况下，能够获得的最大价值。
>
> ![54E9C51263E1462585A8F6595841EEC0.jpg](http://47.93.11.51:88/img/2019-05-26/54E9C51263E1462585A8F6595841EEC0.jpg)
>
> 
>
> ### 样例输入
>
> ```
> 5 20
> 2 3
> 3 4
> 10 9
> 5 2
> 11 11
> ```
>
> #### 样例输出
>
> ```
> 30
> ```

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
int all, n, w[105], v[105], ans[105][10005];

int main() {
    cin >> n >> all;
    for (int i = 1; i <= n; i++) {
        cin >> w[i] >> v[i];
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= all; j++) {
            if (j < w[i]) {
                ans[i][j] = ans[i - 1][j];
            } else {
                ans[i][j] = max(ans[i - 1][j], v[i] + ans[i][j - w[i]]);
            }
        }
    }
    cout << ans[n][all] << endl;
    return 0;
}
```

__降维版__

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
int all, n, w[10005], v[10005], ans[10005];

int main() {
    cin >> n >> all;
    for (int i = 1; i <= n; i++) {
        cin >> w[i] >> v[i];
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= all; j++) {//正着算
            if (j >= w[i]) {
                ans[j] = max(ans[j], v[i] + ans[j - w[i]]);
            }
        }
    }
    cout << ans[all] << endl;
    return 0;
}
```

### 多重背包 49

![49](/home/unique/Desktop/海贼/picture/49.png)、

```
//公式推导做法
//V背包总量, n物品种类, v每个物品重量, w每个物品价值, s每种物品个数
int ans[100005];
int main() {
    int V, n;
    cin >> V >> n;
    for (int i = 0; i < n; i++) {
        int v, w, s;
        cin >> v >> w >> s;
        for (int j = V; j >= v; j--) {
            for (int k = 1; k <= s && k * v <= j; k++) {
            //选k种物品，k < s, 并且k * v < j小于当前背包剩余体积
            	ans[j] = max(ans[j], ans[j - v * k] + k * w);
            }
        }
    }
    cout << ans[V] <<endl;
    return 0; 
}
```

__将其转换成01背包问题后在解决__

> 给有一个能承重 VV 的背包，和n种物品，每种物品的数量有限多，我们用重量、价值和数量的三元组来表示一个物品，第 ii 件物品表示为（Vi，Wi，Si）（Vi，Wi，Si），问在背包不超重的情况下，得到物品的最大价值是多少？
>
> ![54E9C51263E1462585A8F6595841EEC0.jpg](http://47.93.11.51:88/img/2019-05-26/54E9C51263E1462585A8F6595841EEC0.jpg)
>
> ------
>
> #### 输入
>
> 第一行输入两个数V、nV、n，分别代表背包的最大承重和物品种类数。
>
> 接下来 nn 行，每行三个数 Vi、Wi、SiVi、Wi、Si，分别代表第 ii 种物品的重量、价值和数量。
>
> #### 输出
>
> 输出一个整数，代表在背包不超重情况下所装物品的最大价值。
>
> ------
>
> #### 样例输入1
>
> ```
> 15 4
> 4 10 5
> 3 7 4
> 12 12 2
> 9 8 7
> ```
>
> #### 样例输出1
>
> ```
> 37
> ```

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

int all, n, ind, w[100005], ans[100000], v[100005];
int main() {
    cin >> all >> n;
    for (int i = 0; i < n; i++) {
        int x, y, z;
        cin >> x >> y >> z;
        for (int i = 0; i < z; i++) {
            ind++;//拆开成一个一个的，Ind就记录个数
            w[ind] = x;
            v[ind] = y;
        }
    }//相当于ind个物品，每个价值在v[ind]中重量在w[ind]中
    for (int i = 1; i <= ind; i++) {//像解决01背包一样，解决ind个物品
        /*
        for (int j = all; j >= 0; j--) {
        	if (j < w[i]) ans[j] = ans[j]
        	ans[j] = max(ans[j], ans[j - w[i]] + v[i]);
        }
        */
        /*
        for (int j = all; j >= 0; j--) {
        	if (j > w[i] ans[j] = max(ans[j], ans[j - w[i]] + v[i]);
        }
        */
        for (int j = all; j >= w[i]; j--) {
            ans[j] = max(ans[j], ans[j - w[i]] + v[i]);
        }
    }
    cout << ans[all] << endl;
    return 0;
}
```

__二进制优化版__

__如果变成一个一个会有重复现象，所以以二进制方式分包__

![49二进制优化](/home/unique/Desktop/海贼/picture/49二进制优化.png)

```C++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

int all, n, ind, w[100005], ans[100005], v[100005];
int t[20];

int main() {
    int tt = 1;//temp
    for (int i = 0; i < 20; i++) {
        t[i] = tt;
        tt += 2;
    }
    cin >> all >> n;
    for (int i = 0; i < n; i++) {
        int x, y, z, temp = 0;
        cin >> x >> y >> z;
        while (z > 0) {
            ind++;
            if (z >= t[temp]) {//当前剩余包的个数还能分
                w[ind] = x * t[temp];//重量乘以分成的包的个数
                v[ind] = y * t[temp];//价值乘以分成的包的个数，就变成一个大包了
                z -= t[temp];
            } else {//当前剩余包的个数不能分了
                w[ind] = x * z;//重量乘以圣此奥德剩下的包数
                v[ind] = y * z;
                z = 0;
            }
            temp++;
        }
    }
    for (int i = 1; i <= ind; i++) {
        for (int j = all; j >= w[i]; j--) {
            ans[j] = max(ans[j], ans[j - w[i]] + v[i]);
        }
    }
    cout << ans[all] << endl;
    return 0;
}
```

## 43数字三角形

> 有一个由数字组成的三角形数塔，站在上一层的某个点，只能到达其下方左右的两个点。现在请找到一条从上到下的路径，使得路径上所有数字相加之和最大
>
> ![4274F9B8E6E14581A4EC851BCE349029.jpg](http://47.93.11.51:88/img/2019-05-26/4274F9B8E6E14581A4EC851BCE349029.jpg)
>
> ------
>
> #### 输入
>
> 第一行输入一个数字 n（1≤n≤1000）（1≤n≤1000）代表数塔层数
>
> 接下来n行，按数塔图形，每行有一个或多个的整数，表示该层节点的值（节点值≤100000）（节点值≤100000）
>
> #### 输出
>
> 输出一个整数，代表从上到下路径上所有数字相加和的最大值。
>
> ------
>
> #### 样例输入1
>
> ```
> 6
> 3
> 9 5
> 4 2 1
> 3 4 9 6
> 3 5 3 7 3
> 2 1 3 9 3 2
> ```
>
> #### 样例输出1
>
> ```
> 39
> ```

![43](/home/unique/Desktop/海贼/picture/43.png)

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
int n ,num[1005][1005], ans[1005][1005];
int main() {//从上到下
    cin >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            cin >> num[i][j];
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            ans[i][j] = max(ans[i - 1][j - 1], ans[i - 1][j]) + num[i][j];
        }
    }
    int t = 0;
    for (int i = 1; i <= n; i++) {
        t = max(i, ans[n][i]);
    }
    cout << t << endl;
    return 0;
}
/*从下到上
int n ,num[1005][1005], asn[1005][1005];
int main() {
    cin >> n
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            cin >> num[i][j];
        }
    }
    for (int i = n; i >= 1; i--) {
        for (int j = 1; j <= i; j++) {
            ans[i][j] = max(ans[i + 1][j + 1], ans[i + 1][j]) + num[i][j];
        }
    }
    int t = 0;
    for (int i = 1; i <= n; i++) {
        t = max(y, ans[n][i]);
    }
    cout << ans[1][1] << endl;
    return 0;
}*/
```

## 590. 树塔狂想曲

>  相信大家都学过树塔问题，题目很简单求最大化一个三角形数塔从上往下走的路径和。走的规则是：（i，j）（i，j） 号点只能走向 （i+1，j）（i+1，j） 或者 （i+1，j+1）（i+1，j+1）。如下图是一个数塔，映射到该数塔上行走的规则为：从左上角的点开始，向下走或向右下走直到最底层结束。
>
> 1
>
> 3 8
>
> 2 5 0
>
> 1 4 3 8
>
> 1 4 2 5 0
>
>  路径最大和是 1+8+5+4+4=221+8+5+4+4=22，1+8+5+3+5=221+8+5+3+5=22 或者 1+8+0+8+5=221+8+0+8+5=22。
>
>  小 SS 觉得这个问题 soeasysoeasy。于是他提高了点难度，他每次 banban 掉一个点（即规定哪个点不能经过），然后询问你不走该点的最大路径和。当然他上一个询问被 banban 掉的点过一个询问会恢复（即每次他在原图的基础上 banban 掉一个点，而不是永久化的修改）。
>
> ------
>
> #### 输入
>
>  第一行包括两个正整数 N,MN,M 分别表示数塔的高和询问次数。
>
>  以下 NN 行，第 ii 行包括用空格隔开的 i−1i−1 个数，描述一个高为 NN 的数塔。
>
>  而后 MM 行，每行包括两个数 X,YX,Y，表示第 XX 行第 YY 列的数塔上的点被小 SS banban 掉，无法通行。
>
>  （由于读入数据较大，请使用较为快速的读入方式）
>
> #### 输出
>
>  MM 行每行包括一个非负整数，表示在原图的基础上 banban 掉一个点后的最大路径和，如果被 banban 掉后不存在任意一条路径，则输出 −1−1。
>
> ------
>
> #### 样例输入
>
> ```
> 5 3
> 1
> 3 8
> 2 5 0
> 1 4 3 8
> 1 4 2 5 0
> 2 2
> 5 4
> 1 1
> ```
>
> #### 样例输出
>
> ```
> 17
> 22
> -1
> ```

![590-1](/home/unique/Desktop/海贼/picture/590-1.png)

![590-2](/home/unique/Desktop/海贼/picture/590-2.png)

上下各遍历一遍，可求得经过每个点得到的最大路径长度，进而也就得到了每一行上的最大值和第二大的值，所以如果被ban点为当前行最大值，所以直接用第二大的值，如果不是当前行最大值那么就直接用该行最大值算

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

int n, m, num[1005][1005], down[1005][1005], up[1005][1005], mmax[1005], mmax_ind[1005], mmax2[1005];

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            scanf("%d", &num[i][j]);
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            down[i][j] = max(down[i - 1][j - 1], down[i - 1][j]) + num[i][j];
        }
    }
    for (int i = n; i > 0; i--) {
        for (int j = 1; j <= i; j++) {
            up[i][j] = max(up[i + 1][j + 1], up[i + 1][j]) + num[i][j];
        }
    }
    for (int i = 2; i <= n; i++) {
        int ind1 = 0, max1 = 0, max2 = 0;
        //   坐标       最大值       次大值
        for (int j = 1; j <= i; j++) {
            int t = down[i][j] + up[i][j] - num[i][j];
            //经过ij的最大的点
            if (t > max1) {
            //如果t大于max就更新max
                max1 = t;
                ind1 = j;
            }
        }
        for (int j = 1; j <= i; j++) {
            int t = down[i][j] + up[i][j] - num[i][j];
            if (t > max2 && j != ind1) {//次大值
                max2 = t;
            }
        }
        mmax[i] = max1;//第i行最大值
        mmax_ind[i] = ind1;//第i行最大值坐标
        mmax2[i] = max2;//第i行次大值
    }
    for (int i = 0; i < m; i++) {
        int a, b;
        scanf("%d%d", &a, &b);
        if (a == 1 && b == 1) {
            printf("-1\n");
            continue;
        }
        if (mmax_ind[a] == b) {//如果第a行被Ban的点正好是该行最大值
            printf("%d\n", mmax2[a]);//输出次大值
        } else {
            printf("%d\n", mmax[a]);
        }
    }
    return 0;
}
```

## 561 猪猪存钱罐

>  小明决定存钱准备买房。但是他平时花钱如流水，所以也存不出什么钱。因此他决定从最小最小的零钱开始存。而小明为了不让自己乱用钱，决定用那种不砸破拿不出钱的猪猪储蓄罐。但是在砸碎储蓄罐之前，小明还是不能知道自己到底有多少钱。请帮他计算他储蓄罐里最少有多少钱。只要知道最少就好了，好让他可以知道离渺茫的房子还差多少钱。
>
> ------
>
> #### 输入
>
>  第一行两个正整数 E,F（1≤E≤F≤10000）E,F（1≤E≤F≤10000），表示空的猪猪储蓄罐的重量和存满了钱的重量，中间用一个空格隔开。
>
>  接下来一行一个正整数 N（1≤N≤500）N（1≤N≤500），表示有 NN 种硬币。
>
>  再接下来 NN 行数据，每行有两个正整数 P,W（1≤P≤50000,1≤W≤10000）P,W（1≤P≤50000,1≤W≤10000），PP 表示每种硬币的价值，WW 是每种硬币的重量，中间用一个空格隔开。
>
> #### 输出
>
>  输出重量 FF 的最小价格，如果能，则输出一行字符串 "The minimum amount of money in the piggy−bank is X.""The minimum amount of money in the piggy−bank is X."，XX 是最小的价值；
>
>  否则，输出 "This is impossible.""This is impossible." 注意字符串严格匹配。
>
> ------
>
> #### 样例输入
>
> ```
> 10 110
> 2
> 1 1
> 30 50
> ```
>
> #### 样例输出
>
> ```
> The minimum amount of money in the piggy-bank is 60.
> ```

```c++
//只告诉了重量求最小价值，也就是说一种硬币可以无限使用,所以是完全背包问题
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

int e , f, n, w[500], val[505], ans[10005];

int main(){
    memset(ans , 0x3F, sizeof(ans));
    ans[0] = 0;//不能从0开始初始化
    //求最小值如果ans数组为0那么最后输出的将会是全0，因为25行最开始是ans[1]和ans[0]比较取小的,所以除了0位置外的全部位置都设为最大值
    cin >> e >> f >> n;
    f -= e;
    for (int i = 1; i <=n ;i++) {
        cin >> val[i] >> w[i];
    }
    for (int i = 1; i <= n; i++) {
        for (int j = w[i]; j <= f; j++) {
            ans[j] = min(ans[j] , ans[j - w[i]] + val[i]);
        }
    }
    if (ans[f] == 0x3F3F3F3F) {
        cout << "This is impossible." << endl;
    }else {
        cout << "The minimum amount of money in the piggy-bank is "  << ans[f] << ".\n";
    }
    return 0;
}
```



## 41 -涂色

![41color-1](/home/unique/Desktop/%E6%B5%B7%E8%B4%BC/picture/41color-1.png)

![41-2](/home/unique/Desktop/%E6%B5%B7%E8%B4%BC/picture/41-2.png)

![41-3]()

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
#define MAX_N 1000

struct BigInt : public vector<int> {//大整数类
    BigInt(int x = 0) {//构造函数，使int可以赋值给大整数类型
        push_back(x);
        normal();//处理进位
    }

    BigInt operator*(int x) {
        //重载乘法运算符，为了支持68行的大整数乘法
        BigInt ret(*this);
        for (int i = 0; i < ret.size(); i++) ret[i] *= x;
        ret.normal();
        return ret;
    }

    BigInt operator+(const BigInt &a) {
        //重载加法运算符，为了支持68行的大整数加法
        BigInt ret(*this);
        for  (int i = 0; i < a.size(); i++) {
            if (i < ret.size()) ret[i] += a[i];//如123 存储就是321
            else ret.push_back(a[i]);//超过了最高位就在加一为
        }
        ret.normal();
        return ret;
    }

    void normal() {
        for (int i = 0; i < size(); i++) {
            if (at(i) < 10) continue;
            if (i + 1 == size()) push_back(0);
            at(i + 1) += at(i) / 10;
            at(i) %= 10;
        }
        return ;
    }
};

BigInt f[MAX_N + 5];


ostream &operator<<(ostream &out, const BigInt & a) {//重载运算符
    for (int i = a.size() - 1; i >= 0; --i) {
        out << a[i];//倒着输出大整数
    }
    return out;
}

int main() {
    int n, k;
    cin >> n >> k;
    f[1] = k;
    f[2] = (k - 1) * k;
    f[3] = k * (k - 1) * (k - 2);
    for (int i = 4; i <= n; i++) {
        f[i] = f[i - 1] * (k - 2) + f[i - 2] * (k - 1);
    }
    cout << f[n] << endl;
    return 0;
}
```

## 42 钱币问题

![money-1](/home/unique/Desktop/海贼/picture/money-1.png)

![42-1](/home/unique/Desktop/海贼/picture/42-1.png)

用第i种钱凑val(i)元，例用5块钱凑5块钱的方法总数为1种,即 `f[i][j-val(i)] = 1`，故`f[i][0]`=1

>某个国家的货币系统中，有 m 种面额的钱币，现在要用这 m 种面额的钱币凑足 n 元钱，问一共有多少种方法。m 种钱币不一定要都被用到。
>
>例如，有 3 种钱币，分别为1、2、5，那么有四种方法拼凑出5元钱
>
>1. `(1，1，1，1，1)` 全是1元钱
>2. `(1，2，2)`，`(1，1，1，2)` 使用1元和2元
>3. `(5)` 只用5元钱
>
>**注意：**方案中的钱币不分顺序，也就是说`（1，2，2）` 和`（2，1，2）`是同一种方法。
>
>------
>
>#### 输入
>
>输入两个数字 m, n$（1 \le m \le 20, 200 \le n \le 10000）$，第二行 m 个数字，代表 m 种钱币的面额，钱币面额大于0，数据中保证 m 种钱币各不相同。
>
>#### 输出
>
>输出一个整数，代表拼凑出 n 元钱的方法数，答案有可能过大，请对 9973 取余。
>
>------
>
>#### 样例输入1
>
>```
>8 200
>1 2 5 10 20 50 100 200
>```
>
>#### 样例输出1
>
>```
>3871
>```

```c++
/*f[i][j]代表用前i种钱币凑j元钱 f[i][j]=f[i-1][j]+f[i][j-val(i)]*/
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
#define MAX_M 2020
#define MAX_N 10000
int f[MAX_M + 5][MAX_N + 5];
int val[MAX_M + 5];

int main() {
    int n, m;
    cin >> m >> n;
    for (int i = 1; i <= m; i++) cin >> val[i];
    for (int i = 1; i <= m; i++) {
        f[i][0] = 1;
        for (int j = 1; j <= n; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= val[i]) f[i][j] += f[i][j - val[i]];//如果当前面值小于所凑钱数时才可以加,否则就是
            //只有当j大于i时才能使用i凑j
            f[i][j] %= 9973;
        }
    }
    cout << f[m][n] << endl;
    return 0;
}
```

## 490 新约瑟夫问题

![490](/home/unique/Desktop/海贼/picture/490.png)

f(n)代表n个人玩游戏最后剩下一个k。如果每次删去第k个人，则可以想象成k+1个人为第一个人k+2为第二个人，所以可以一一映射1=>k+1,2=>k+2,所以n个人玩最后如果剩下k+1则下一轮n-1个人玩最后剩下的就是第一个人。

故f(n)=(f(n-1) + k),在第n轮k+1的值在n-1轮为1,所以n轮第n个人在第n-1轮的位置为n-k,n轮n+1位置上的人在n-1轮的位置为n-k+1为1,所以说f(n-1)+k=>f(n-k+1)+k=>n+1=1所以最后得到递推式f(n)=f(n-1+k-1)%n+1

>  你一定听说过经典“约瑟夫”问题吧？现在来组织一个皆大欢喜的新游戏：假设 个人站成一圈，从第 人开始交替的去掉游戏者，但只是暂时去掉（例如，首先去掉 ），直到最后剩下唯一的幸存者为止。幸存者选出后，所有比幸存者号码高的人每人将得到 块钱，并且永久性地离开，其余剩下的人将重复以上过程，比幸存者号码高的人每人将得到 块钱后离开。一旦经过这样的过程后，人数不再减少，最后剩下的那些人将得到 块钱。请计算一下组织者一共要付出多少钱？
>
>  例如，第一轮有 人，幸存者是 ，所以 得到 块钱后离开，下一轮幸存者仍然是 ，因此没有人离开，所以每人得到 块钱，总共要付出 块钱。
>
> ------
>
> #### 输入
>
>  输入一个整数 。
>
> #### 输出
>
>  一个整数，表示总共要付出多少钱。
>
> ------
>
> #### 样例输入
>
> ```
> 10
> ```
>
> #### 样例输出
>
> ```
> 13
> ```

```c++
//也就是说每个参与游戏的n个人都会得到钱,只是留到最后的人比其让人多一块钱,所以支出的钱为n+ans(留到最后的人数)
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
#define MAX_N 32767
int f[MAX_N + 5];

int main() {
    int n;
    cin >> n;
    f[1] = 1;//一个人玩游戏剩下的就是他自己
    for (int i = 2; i <= n; i++) {
        f[i] = (f[i - 1] + 2 - 1) % i + 1;
    }
    int x = n;
    while (f[x] - x) x = f[x];
    //大于剩下的人编号的人被淘汰，所以人数x变为上一轮剩下人的编号
    cout << n + x << endl;
    return 0;
}
```

## 559. 小毛的交易

本题关键在于求性价比最高的先买，例第一个仓库用2个食物可换7个豆，相当于一个食物可换3.5个，所以算出每个仓库一个食物能换多少豆，在排序，最后依次换

> 小毛准备了 MM 磅的猫咪食物去和猫咪交易他最喜欢的食物爪哇豆。猫咪有 NN 间仓库，其中第 ii 间仓库包含着 s[i]s[i] 磅的爪哇豆，但要花费 f[i]f[i] 磅的猫咪食物去和他们交换。小毛很聪明，经过他的各种交换，发现自已没有必要把每一个仓库的食物全部买下，他可以偷偷地买下一部分。也就是说，他可以获得 s[i]∗as[i]∗a 磅的爪哇豆而只花费 f[i]∗af[i]∗a 磅的猫咪食物。但是，他不知道该怎么买才能买到最多的爪哇豆。请帮他计算一下。
>
> ------
>
> #### 输入
>
>  第一行有两个整数 M,NM,N。
>
>  接下来的 NN 行，每行两个非负整数 s[i],f[i]s[i],f[i]。
>
>  注：所有整数不超过 10001000。
>
> #### 输出
>
>  输出一个实数，保留小数点后三位，表示小毛最多能买到多少磅的爪哇豆。
>
> ------
>
> #### 样例输入
>
> ```
> 5 3
> 7 2
> 4 3
> 5 2
> ```
>
> #### 样例输出
>
> ```
> 13.333
> ```

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

typedef struct Treat {
    double s;
    double f;
    double val;
}Treat;

bool cmp(Treat x, Treat y) {
    return x.val > y.val;
}

int main() {
    int m, n;
    double get = 0;
    cin >> m >> n;
    Treat a[1005];
    for (int i = 0; i < n; i++) {
        cin >> a[i].s >> a[i].f;
        a[i].val = a[i].s / a[i].f;
    }
    sort(a, a + n, cmp);
    for (int i = 0; i < n; i++) {
        get += m > a[i].f ? a[i].s : (m * a[i].val);
        m -= m > a[i].f ? a[i].f : m;
        if (m == 0) break;
    }   
    printf("%.3f", get);
    return 0;
}
```

## 最长上升子序列

__讲解__

> https://blog.csdn.net/lxt_Lucia/article/details/81206439

```
让我们举个例子：求 2 7 1 5 6 4 3 8 9 的最长上升子序列。我们定义d(i) (i∈[1,n])来表示前i个数以A[i]结尾的最长上升子序列长度。
　　前1个数 d(1)=1 子序列为2；
　　前2个数 7前面有2小于7 d(2)=d(1)+1=2 子序列为2 7
　　前3个数 在1前面没有比1更小的，1自身组成长度为1的子序列 d(3)=1 子序列为1
　　前4个数 5前面有2小于5 d(4)=d(1)+1=2 子序列为2 5
　　前5个数 6前面有2 5小于6 d(5)=d(4)+1=3 子序列为2 5 6
　　前6个数 4前面有2小于4 d(6)=d(1)+1=2 子序列为2 4
　　前7个数 3前面有2小于3 d(3)=d(1)+1=2 子序列为2 3
　　前8个数 8前面有2 5 6小于8 d(8)=d(5)+1=4 子序列为2 5 6 8
　　前9个数 9前面有2 5 6 8小于9 d(9)=d(8)+1=5 子序列为2 5 6 8 9
　　d(i)=max{d(1),d(2),……,d(i)} 我们可以看出这9个数的LIS为d(9)=5
```

> #### 题目描述
>
> 有一个数字序列，求其中最长严格上升子序列的长度
>
> ## ![B28E0055CAC24D4D8F260936BD6F358F.jpg](http://47.93.11.51:88/img/2019-05-26/B28E0055CAC24D4D8F260936BD6F358F.jpg)
>
> #### 输入
>
> 输入一个数字n $ (1\le n \le 1000000)$，代表数字序列的长度。
>
> 后跟 $n$ 个整数，第 $i$ 个整数 $a_i (1\le a_i \le 10000) $，代表数字序列中的第 $i$ 个值。
>
> #### 输出
>
> 输出一个整数，代表所求的最长严格上升子序列的长度。
>
> ------
>
> #### 样例输入
>
> ```
> 10
> 3 2 5 7 4 5 7 9 6 8
> ```
>
> #### 样例输出
>
> ```
> 5
> ```

![44-1](/home/unique/Desktop/海贼/picture/44-1.png)

__普通解法：两个for 循环，i = 1~n , j = 1~i ,找到i前面的的小于i的数，分别接在他们后面，然后取最大长度__

```c++
int main() {
    int n, ans = 0;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        dp[i] = 1;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j < i; j++) {
            if (a[j] >= a[i]) continue;
            dp[i] = max(dp[i], dp[j] + 1);
        }
        ans = max(ans, dp[i]);
    }
    cout << ans << endl;
    return 0;
}
```

![44-2](/home/unique/Desktop/海贼/picture/44-2.png)

__len数组一定是单调的 例 (假设x > 6 序列为4并且末位为6的序列的第三位为y ,那么y 大于6 ,因为 x 大于 6 ,所以x也大于y,如果存在x大于y,那么len[3]上的值应为y而不是x, 所以len数组一定是单调递增的)__

![44-3](/home/unique/Desktop/海贼/picture/44-3.png)

__优化版：引进len数组y_数组用来记录每一个长度相应序列的末尾最小值(如序列长度为4的序列有3个末尾值分别是6 8 9，则len[4]=6),可以直接在len数组中找到第一个大于等于a[i]的值，并取代他，然后更新len数组__

```c++
*/
 //dp[i]表示以i为结尾你能形成的最大上升子序列长度
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
#define MAX_N 1000000
#define INF 0x3f3f3f3f
int dp[MAX_N + 5];
int len[MAX_N + 5], ans = 0;
//len数组用来记录每一个长度相应序列的末尾最小值,ans len数组中记录的数量
int a[MAX_N + 5];

int bs(int *arr, int l, int  r, int x) {
    if (l == r) return l;
    int mid = (l + r) >> 1;
    if (arr[mid] < x) return bs(arr, mid + 1, r, x);
    return bs(arr, l, mid, x);
}

int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        dp[i] = 1;
        len[i] = INF;//极大值
    }
    len[++ans] = a[1];
    for (int i = 2; i <= n; i++) {
        dp[i] = bs(len, 1, ans + 1, a[i]);//找到第一个大于等于a[i]的值，并且替代它
        //例(len[4]=6 len[5]=9 ,a[i]=7，所以第一个大于a[i]的值为9,下标为5，也就是说7可以插在序列长度为4末位值为6的后面)
        len[dp[i]] = a[i];//更新相应的值
        //(更新所以len[5]=7)
        ans = max(dp[i], ans);//找最大值
    }
    cout << ans << endl;
    return 0;
}
```

## 45 最长公共子序列

> #### 题目描述
>
> 给出两个字符串，求其两个的最长公共子序列长度。
>
> ![img](http://jisuanke.oss-cn-beijing.aliyuncs.com/19-1-4/55649855.jpg)
>
> ------
>
> #### 输入
>
> 第一行输入一个字符串s1，第二行输入一个字符串s2 $(字符串长度 \le 1000)$ ，两个字符串长度可以不相同。
>
> #### 输出
>
> 输出一个整数，代表两个字符串的最长公共子序列的长度。
>
> ------
>
> #### 样例输入1
>
> ```
> sehuaizexi
> yhaizeyiux
> ```
>
> #### 样例输出1
>
> ```
> 6
> ```

![45-1](/home/unique/Desktop/海贼/picture/45-1.png)

```
        (因为不相同的话ij不影响最后公共子序列的长度，所以就还是上一个长度)         
        第i位和第j位不相同 可以看做没有第i位     或 没有第j位
        		dp[i][j]=dp[i-1][j] 或 dp[i][j]=[i][j-1]               
dp[i][j] 
        dp[i - 1][j - 1] + 1
        第i位和第j位相同
        (最后的ij相同，那么最长公共子序列的长度就为前dp[i-1][j-1]加上因为ij相等的1) 
```

```c++
//dp[i][j]代表第一个序列长度为i第二个序列长度为j
//dp[i][j]第一个字符串以i结尾第二个字符串以j结尾的最长公共子序列
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
#define MAX_N 1000
int dp[MAX_N + 5][MAX_N + 5];
string s1, s2;
int main() {
    cin >> s1 >> s2;
    for (int i = 1; i <= s1.size(); i++) {
        for (int j = 1; j <= s2.size(); j++) {
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);//先按照不想等算
            if (s1[i - 1] - s2[j - 1]) continue;//最后一位不相同直接continue
            dp[i][j] = dp[i - 1][j - 1] + 1;//相等就更新
        }
    }
    cout << dp[s1.size()][s2.size()] << endl;
    return 0;
}
```

## 343 最长公共上升子序列

> #### 输入
>
>  第一行N，表示A，B的长度。
>
>  第二行，N个由空格分开的数字，代表串A。
>
>  第三行，N个由空格分开的数字，代表串B。
>
>  (1≤N≤3000)(1≤N≤3000),A,BA,B中的数字不超过long long int范围。
>
> #### 输出
>
>  输出最长公共上升子序列长度。
>
> #### 输入样例1
>
> ```
> 4
> 2 2 1 3
> 2 1 2 3
> ```
>
> #### 输出样例1
>
> ```
> 2
> ```

![343-1](/home/unique/Desktop/海贼/picture/343-3.png)

![343-1](/home/unique/Desktop/海贼/picture/343-1.png)

```c++
#include <iostream>
using namespace std;
#define MAX_N 3000
int a[MAX_N + 5], b[MAX_N + 5]; 
int n, ans = 0;;
//A序列前i位，B序列前j位，并且以A序列第i位作为结尾的公共上升子序列
int dp[MAX_N + 5][MAX_N + 5];
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int j = 1; j <= n; j++) cin >> b[j];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = dp[i][j - 1];
            if (a[i] - b[j]) continue;
            dp[i][j] = max(1, dp[i][j]);//如果不相等默认最小等于1
            for (int k = 1; k < i; k++) {
                if (a[k] >= a[i]) continue;
        //k不能超过i的因为dp[i][j]是以!i!结尾的公共上升子序列的值
                dp[i][j] = max(dp[i][j], dp[k][j - 1] + 1);
            }
            ans = max(ans, dp[i][j]);
//执行34行说明a[i]=b[j]，不等于的情况(dp[i][j])被continu了
//但是这种情况还是包括了，因为不相等时dp[i][j]=dp[i][j-1],dp[i][j]虽没执行到34行，
            //但是dp[i][j-1]执行过，所以在34行可以判断出全局最大值

        }
    }
    cout << ans << endl;
    return 0;
}
```

## 50 扔鸡蛋

> #### 题目描述
>
> 定义鸡蛋的硬度为 kk，则代表鸡蛋最高从 kk 楼扔下来不会碎掉，现在给你 nn 个硬度相同的鸡蛋，楼高为 m，问最坏情况下最少测多少次，可以测出鸡蛋的硬度。
>
> ![2FB2A117A30743DDB39CA46A537BADD2.jpg](http://47.93.11.51:88/img/2019-05-26/2FB2A117A30743DDB39CA46A537BADD2.jpg)
>
> ------
>
> #### 输入
>
> 输入两个数字 n,m（1≤n≤32,1≤m<231）n,m（1≤n≤32,1≤m<231），代表 nn 个鸡蛋和 mm 层楼。
>
> #### 输出
>
> 输出一行整数，代表最坏情况下最少测多少次可以测出鸡蛋的硬度。
>
> ------
>
> #### 样例输入1
>
> ```
> 2 100
> ```
>
> #### 样例输出1
>
> ```
> 14
> ```
>
> #### 样例输入2
>
> ```
> 1 5
> ```
>
> #### 样例输出2
>
> ```
> 5
> ```

![50-1](/home/unique/Desktop/海贼/picture/50-1.png)

![50-1](/home/unique/Desktop/海贼/picture/50-2.png)

​           __int val = max(dp[i - 1][k - 1], dp[i][j - k]) + 1;鸡蛋从i层扔下去，如果碎了就是剩下i-1个鸡蛋测k-1层楼，没碎就是剩i个鸡蛋测j-k层楼，取最大值，就是运气不好的情况__

![50-1](/home/unique/Desktop/海贼/picture/50-3.png)

```c++
//鸡蛋碎了就向下测，没碎就向上测
//填空题做法：假设做大最小测试x次，那么第一次应该从x楼开始测因为如果从x+1开始，如果鸡蛋碎了，那就要往下测x+1层，就超过了x次，所以要从x楼开始测
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
#define MAX_N 32
#define MAX_M 10000
int dp[MAX_N + 5][MAX_M + 5];//dp[n][m]代表n个鸡蛋测m层最多最少多少次
int f[MAX_N + 5][MAX_M + 5];
int main() {
    int n, m;
    cin >> n >> m;
    //dp[i][0]=0
    for  (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (i == 1) {
                dp[i][j] = j;//1个鸡蛋测j层最多j次，每次都测
                f[i][j] = 1;
                continue;
            }
            dp[i][j] = j;//一开始极大值
            for (int k = 1; k <= j; k++) {
            //鸡蛋从i层扔下去，如果碎了就是剩下i-1个鸡蛋测k-1层楼
            //没碎就是剩i个鸡蛋测j-k层楼
            //取最大值，就是运气不好的情况，
                int val = max(dp[i - 1][k - 1], dp[i][j - k]) + 1;
        //最大最小值就是在运气不好情况下取最小的
                if (val < dp[i][j]) {
                    f[i][j] = k;
                    dp[i][j] = val;
                }
            }
        }
    }
    cout << dp[n][m] << endl;
    cout << f[n][m] << endl;
    return 0;
}
```

__优化版 dp[n[m]=k本题中m范围很大k变化小，m变化大n变化小，而m越大k越大，说明两个变量正相关，所以可以把两个相关量交换位置变为dp[n[k] = m,n个鸡蛋扔m次最多测k层楼__

![50-4](/home/unique/Desktop/海贼/picture/50-4.png)

![50-5](/home/unique/Desktop/海贼/picture/50-5.png)

```c++
#include <iostream>
using namespace std;
#define MAX_N 32
#define MAX_M 65536
typedef long long ll;
//dp[n][k]=m代表i个鸡蛋测j次能测m层楼
//假如3个鸡蛋扔一次测1层楼，扔6次测10层楼，7次测30层楼，那么20层楼最大最小测试次数应为7次,也就是找到第一所测楼层数大于所给楼层数的
ll dp[MAX_N + 5][MAX_M + 5];

int main() {
    ll  n, m;
    cin >> n >> m;
    if (n == 1) {
        cout << m << endl;
        return 0;
    }
    for (ll k = 1; k <= MAX_M; k++) dp[1][k] = k;
    //一个鸡蛋测k次,只能测k层楼
    for (ll i = 2; i <= n; i++) {
        for (ll k = 1; k <= MAX_M; k++) {//测k次
            //dp[i-1][k-1]鸡蛋碎了剩下i-1还能测k-1次的楼层数
            //dp[i][k-1]鸡蛋没碎仍剩下i个还能测k-1次的楼层数
            dp[i][k] = dp[i - 1][k - 1] + dp[i][k - 1] + 1;
        }
    }
    ll p = 1;
    while (dp[n][p] < m) p++;
    cout << p << endl;
    return 0;
}
```

## 51 矩形(求有多少个矩形)

> #### 题目描述
>
> 在一个黑白相间的矩形中，问有多少个全白色的子矩形。
>
> ## ![18475740.jpg](http://jisuanke.oss-cn-beijing.aliyuncs.com/19-1-11/18475740.jpg)
>
> #### 输入
>
> 第一行输入两个数字 n,m（2≤n,m≤1000）n,m（2≤n,m≤1000），代表矩形的长和宽。
>
> 接下来 nn 行，每行 mm 个数字，00 代表黑色格子，11 代表白色格子。
>
> #### 输出
>
> 输出一个整数，代表全白色子矩形的数量，结果可能过大，输出时请对 100007100007 取余。
>
> ------
>
> #### 样例输入1
>
> ```
> 6 6
> 0 1 1 1 1 1
> 1 1 0 1 1 1
> 1 1 1 1 1 1
> 1 1 1 0 1 1
> 1 1 1 1 0 1
> 1 0 1 1 1 1
> ```
>
> #### 样例输出1
>
> ```
> 152
> ```

__a数组为每一列白色小矩形个数__

![51-2](/home/unique/Desktop/海贼/picture/51-1.png)

__f数组为，以每一列作为合并后大矩形的起始点坐标(大矩形的左上角)能合成的矩形个数__

![51-1](/home/unique/Desktop/海贼/picture/51-2.png)

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
#define MAX_N 1000
int f[MAX_N + 5];
int a[MAX_N + 5];//第a[i]列向下数联系白色格子的数量
int s[MAX_N + 5], top = -1;//单调栈

int main() {
    int n, m, ans = 0;
    cin >> n >> m;
    a[m + 1] = -1;
    f[m + 1] = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1, val; j <= m; j++) {
            cin >> val;
            if (val == 1) a[j] += 1;//一个白色就加一个
            else a[j] = 0;
        }
        top = -1;
        s[++top] = m + 1;
        for (int j = m; j >= 1; j--) {
            while (a[s[top]] >= a[j]) top--;//维护一个单调栈
    //找到第一个小与他的列减去该列求得矩形长，该列白色小矩形数量为宽，在加上第一个小于他的列的最大矩形数
            f[j] = (s[top] - j) * a[j] + f[s[top]];
            f[j] %= 100007;
            s[++top] = j;
            ans += f[j];
            ans %= 100007;
        }
    }
    cout << ans << endl;
    return 0;
}
```

## 342 照相的排列数(到哪去的递推)

![342](/home/unique/Desktop/海贼/picture/342.png)

> 由题意可知最高的人在左下角所以如果想在第一排插入一个高个同学在图中n的位置那么第i排人数一定大于其他排，以此类推

__动态规划分为两种从哪来，到哪去，从哪来指得就是可通过上一次或上一轮的旧的数据计算出当前的数据(i-1行推导出i行)，到哪去指的就是当前行会导致后面哪些数据的改变(i行推导出i+1行)__

> #### 题目描述
>
>  有NN个学生合影，战成左端对齐的kk排，每排分别有N1,N2,…,NkN1,N2,…,Nk 个人， 第一排站在最后面，第k排站在最前面。学生的身高互不相同，把他们从高到低依次标记为1,2,…,N1,2,…,N. 在合影时要求每一排从左到右身高依次递减，每一列从后到前身高也递减，问一共有多少种安排合影位置的方案？(1≤N≤30,1≤k≤5)(1≤N≤30,1≤k≤5)
>
> ------
>
> #### 输入
>
>  多组样例输入
>
>  对于每组数据，第一行有一个整数k(k≤5)k(k≤5)，代表所要排的队数。
>
>  第二行k个由空格分开的整数，代表每排所要的学生人数。
>
>  (各排所需要的人数之和NN不超过30)
>
>  当k等于0时结束输入。
>
> #### 输出
>
>  按题目描述输出。
>
> #### 输入样例1
>
> ```
> 1
> 30
> 5
> 6 6 6 6 1
> 0
> ```
>
> #### 输出样例1
>
> ```
> 1
> 2103447060
> ```

```c++
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <queue>
using namespace std;
#define MAX_N 5
int cnt[MAX_N + 5] = {0};//第i排人数

void solve(int k) {
    if (k == 0) return ;
    memset(cnt, 0, sizeof(cnt));
    for (int i = 0; i < k; i++) cin >> cnt[i];
    long long f[cnt[0] + 1][cnt[1] + 1][cnt[2] + 1][cnt[3] + 1][cnt[4] + 1];
    memset(f, 0, sizeof(f));
    f[0][0][0][0][0] = 1;
    for (int i0 = 0; i0 <= cnt[0]; i0++) {
        for (int i1 = 0; i1 <= cnt[1]; i1++) {
            for (int i2 = 0; i2 <= cnt[2]; i2++) {
                for (int i3 = 0; i3 <= cnt[3]; i3++) {
                    for (int i4 = 0; i4 <= cnt[4]; i4++) {
                        long long val = f[i0][i1][i2][i3][i4];
    //如果将新加进来的最高的人放在第一排，那么第一排人数一定大于2345排
                        //并且不能超过第一排所能放的人数
                        if (i0 >= i1 && i0 >= i2 && i0 >= i3 && i0 >= i4 && i0 < cnt[0])
                            f[i0 + 1][i1][i2][i3][i4] += val;
    //如果将新加进来的最高的人放在第二排，那么第二排人数一定大于345排
                        if (i1 >= i2 && i1 >= i3 && i1 >= i4 && i1 < cnt[1])
                            f[i0][i1 + 1][i2][i3][i4] += val;
    //如果将新加进来的最高的人放在第三排，那么第三排人数一定大于45排
                        if (i2 >= i3 && i2 >= i4 && i2 < cnt[2])
                            f[i0][i1][i2 + 1][i3][i4] += val;
                        if (i3 >= i4 && i3 < cnt[3])
                            f[i0][i1][i2][i3 + 1][i4] += val;
                        if (i4 < cnt[4])
                            f[i0][i1][i2][i3][i4 + 1] += val;
                    }
                }
            }
        }
    }
    cout << f[cnt[0]][cnt[1]][cnt[2]][cnt[3]][cnt[4]] << endl;
    return ;
}

int main() {
    int k;
    while (cin >> k) solve(k);
    return 0;
}
```

# 动态规划优化及解题方法

```
确定状态定义
推导状态转移方程
用数学归纳法进行正确性证明
程序实现
```

## 程序实现方面

```
如背包问题中2二维数组优化为一维 ，仅是优化了空间，状态数量没有变化，程序执行效率也没有变化
```

__与状态定义变化维度改变的区别，背包问题中仅仅是降维了，但是计算的状态数量并没有改变，i-1，j-1的值还是要算，二状态定义优化中的降维计算的次数也减小了__

## 状态定义的优化

```
状态定义的优化，分为两类，一种是不改变状态维度，一种是改变

不改变：如43数字三角形，dp[i][j]两种含义，从顶点到(i,j)点的路径最大值最，从(i,j)到底边的路径最大值，两种不同的状态定义就有两种不同的代码实现，并且实现难度也不同	
改变：如41墙壁涂色中第一种状态定义方式有三种f[n][i][j],f[n][i],f[n]，每个状态定义所求的状态数量也不同，状态定义的不同直接影响了求解的状态数量，也就影响了程序执行的效率
```

## 状态转移过程中的优化

```
如最长上升子序列的优化借助了一个len数组(存放了到每个数的最长的上升子序列长度)再用二分，直接将时间复杂度优化成(nlongn)
再如52古老的打印机用来单调对列，用了斜率优化，并没有改变状态定义
```

# 斜率优化 52

> #### 题目描述
>
> 有一台古老的打字机和一篇待打印的文章，文章中有 $n$ 个字符，每个字符会有一个消耗值 $C_i$, 打字机工作一次会打印若干连续的 $k$ 个字符，同时打字机会有磨损，打字机的单次磨损计算公式为：
>
> $$ (\sum_{i={begin}}^{begin+k-1}C_i)^2 + M $$
>
> 其中 $M$ 是打字机启动一次的固定磨损值，现在给你 $n$ 个字符的消耗值，问你打字机顺序打印出这 $n$ 个字符的最小磨损值为多少？
>
> ------
>
> #### 输入
>
> 第一行输入两个数字，$n, M(1 \le n \le 10^{6}, 1 \le M \le 10^{4})$ 代表文章中字符数量和打字机单次启动的固定磨损值。
>
> 第二行输入 $n$ 个数字，第 $i$ 个数字代表文章中第 $i$ 个字符的磨损值 $C_i(1 \le C_i \le 100)$。
>
> #### 输出
>
> 输出一个整数，代表打字机顺序打完 $n$ 个字符的最小磨损值
>
> ------
>
> #### 样例输入1
>
> ```
> 6 40
> 3 3 6 5 1 2
> ```
>
> #### 样例输出1
>
> ```
> 256
> ```

![52-1](/home/unique/Desktop/海贼/picture/52-1.png)

__普通做法__

```C++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
#define MAX_N 1000000
long long dp[MAX_N + 5];
//dp[i]表示打印前i个字符的最小磨损值
long long c[MAX_N + 5];
//c[i]打印第i个字符的消耗，后变为前缀和

inline long long S(long long x) {
    return x * x;
}

int main() {
    long long n, M;
    cin >> n >> M;
    c[0] = 0;//前缀和第一位特殊定义
    for (long long i = 1; i <= n; i++) {
        cin >> c[i];
        c[i] += c[i - 1];//前i个元素的和
    }
    for (long long i = 1; i <= n; i++) {
        dp[i] = dp[i - 1] + S(c[i] - c[i - 1]) + M;
        //初始化，意为一次只打印一个字符，算出每个字符的磨损值
        for (long long j = 0; j < i - 1; j++) {
            dp[i] = min(dp[i], dp[j] + S(c[i] - c[j]) + M);
        }
    }
    cout << dp[n] << endl;
    return 0;
}
```

__用斜率优化__

1、原来的状态转换方程

![52-2](/home/unique/Desktop/海贼/picture/52-2.png)

2、将其展开 (因为j是改变的，所以sum[i] *sum[i] + M 化简后可以约掉)

![52-2](/home/unique/Desktop/海贼/picture/52-3.png)

3、化简 f[j] = dp[j] + sum[j] * sum[j]

![52-2](/home/unique/Desktop/海贼/picture/52-4.png)

![52-2](/home/unique/Desktop/海贼/picture/52-5.png)

3、通过斜率判断,如果f[i]-f[k]/sum[i]-sum[j] < 2sum[i] 也就是小于等于一个固定值，那么就说明i 优于j

![52-2](/home/unique/Desktop/海贼/picture/52-6.png)

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
#define MAX_N 1000000
#define S(a) ((a) * (a))
typedef long long ll;
ll sum[MAX_N + 5];
ll f[MAX_N + 5], dp[MAX_N + 5];
int q[MAX_N + 5], head = 0, tail = 0;
ll n, M;

void set(int i, int j) {
    dp[i] = dp[j] + S(sum[i] - sum[j]) + M;
    f[i] = dp[i] + S(sum[i]);
    return ;
}

double slope(int i, int j) {//求斜率
    return 1.0 * (f[i] - f[j]) / (sum[i] - sum[j]);
}

int main() {
    cin >> n >> M;
    for (int i = 1; i <= n; i++) cin >> sum[i], sum[i] += sum[i - 1];
    q[tail++] = 0;
    for (int i = 1; i <= n; i++) {
        while (tail - head >= 2 && slope(q[head], q[head + 1]) <= 2 * sum[i]) ++head;
        //找到第一个大于2 * sum[i]的点
        set(i, q[head]);
        while (tail - head >= 2 && slope(q[tail - 1], q[tail - 2]) > slope(q[tail - 1], i)) --tail;
        //如果斜率先上升再下降那么中间的点就可以不要了
        q[tail++] = i;
    }
    cout << dp[n] << endl;
    return 0;
}
```

# 前缀和和差分序列

![前缀和](/home/unique/Desktop/海贼/picture/前缀和.png)

`由上到下是差分得来的，由下到上是求前缀和得到的`

原序列 <=> 前缀和序列可转换__前缀和序列相邻两项做差就能得到原序列，原序列可生成前缀和序列__

差分序列就是原序列相邻两项相减

原序列相当于前缀和的差分序列

```
与数组的区间加相当于给差分数组的单点操作 差分数组用来处理区间价减 前缀和是为了方便求出区间和
```

## 270 最大子序和

> #### 题目描述
>
>  输入一个长度为 $n$ 的整数序列，从中找出一段不超过 $M$ 的连续子序列，使得整个序列的和最大。
>
>  例如 $1，-3,5,1，-2,3$：
>
>  当 $m=4$ 时，$S=5+1-2+3=7$；
>
>  当 $m=2$ 或 $m=3$ 时，$S=5+1=6$。
>
> ------
>
> #### 输入
>
>  第一行两个数 $n,m$。
>
>  第二行有 $n$ 个数，要求在 $n$ 个数找到最大子序和。
>
> #### 输出
>
>  一个数，数出他们的最大子序和。
>
> ------
>
> #### 样例输入
>
> ```
> 6 4
> 1 -3 5 1 -2 3
> ```
>
> #### 样例输出
>
> ```
> 7
> ```

```c++
//本题思路就是维护一个存放前缀和的单调队列，算出每个值 的当前值减去队列的队首元素(即m范围内最小的前缀和)，每个答案比较取出最大的
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
#define MAX_N 300000
int s[MAX_N + 5];
int q[MAX_N + 5], head = 0, tail = 0;

int main() {
    int n , m, ans;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> s[i];
        s[i] = s[i] + s[i - 1];
    }
    q[tail++] = 0;
    ans = s[1];//为了防止都是负数，一个都不选所以先让ans=s[1]
    for (int i = 1; i <= n; i++) {
        if (i - q[head] > m) head++;//不超过m
        ans = max(ans , s[i] - s[q[head]]);
        while (tail - head && s[i] < s[q[tail - 1]]) tail--;//维护队列单调性
        q[tail++] = i;
    }
    cout << ans << endl;
    return 0;
}
```



# 单调栈和单调队列

![单调栈单调队列](/home/unique/Desktop/海贼/picture/单调栈单调队列.png)

__单调队列求区间最值，单调栈是求最近最值__

## 271 滑动窗口

>  给出一个长度为 NN 的数组，一个长为 KK 的滑动窗口从最左移动到最右，每次窗口移动，如下图：
>
> ![img](http://haizei.oss-cn-beijing.aliyuncs.com/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/2823-1.png)
>
> #### 样例输入
>
> ```
> 8 3
> 1 3 -1 -3 5 3 6 7
> ```
>
> #### 样例输出
>
> ```
> -1 -3 -3 -3 3 3
> 3 3 5 5 6 7
> ```

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#include <cmath>
using namespace std;
#define MAX_N 300000
int a[MAX_N + 5];
int q[MAX_N + 5], head = 0, tail = 0;//单调队列中存下标

int main() {
    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) {
        while (tail - head && a[q[tail - 1]] >= a[i]) tail--;//维护队列单调性
        q[tail++] = i;//入队列
        if (q[head] <= i - k) head++;//维护窗口大小
        if (i < k) continue;//小于窗口大小就下一个
        i == k || cout << " ";//说明此时i=k
        cout << a[q[head]];//输出对手元素，即最小值
    }
    cout << endl;
    head = tail = 0;
    for (int i = 1; i <= n; i++) {
        while (tail - head && a[q[tail - 1]] <= a[i]) tail--;//同上
        q[tail++] = i;
        if (q[head] <= i - k) head++;
        if (i < k) continue;
        i == k || cout << " ";
        cout << a[q[head]];
    }
    cout << endl;
    return 0;
}
```

## 264 矩形最大面积

正着遍历出每个元素左边第一个小于他的值放在l数组中，反着遍历出每个元素右边第一个小于他的值放在r数组中，最后遍历最大面积即可

>  给定从左到右多个矩形，已知这此矩形的宽度都为 $1$，长度不完全相等。这些矩形相连排成一排，求在这些矩形包括的范围内能得到的面积最大的矩形，打印出该面积。所求矩形可以横跨多个矩形，但不能超出原有矩形所确定的范围。
>
> ![img](http://haizei.oss-cn-beijing.aliyuncs.com/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/2559_1.jpg)
>
> ------
>
> #### 输入
>
>  输入共一行，第一个数表示矩形的个数 $N$。接下来 $N$ 个数表示矩形的大小。$（1\le N\le 100000）$
>
> #### 输出
>
>  输出最大矩形面积。
>
> ------
>
> #### 样例输入
>
> ```
> 7
> 2 1 4 5 1 3 3
> ```
>
> #### 样例输出
>
> ```
> 8
> ```

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
#define MAX_N 100000
long long a[MAX_N + 5];//每一块墙的高度
long long s[MAX_N + 5], top = -1;
long long l[MAX_N + 5], r[MAX_N + 5];

int main() {
    long long n;
    cin >> n;
    for (long long i = 1; i <= n; i++) cin >> a[i];
    a[0] = a[n + 1] = -1;//哨兵元素，控制边界
    s[top = 0] = 0;
    for (long long i = 1; i <= n; i++) {
        while (a[s[top]] >= a[i]) --top;
        //维护单调性，递增前面大于当前值的元素就不要--top
        l[i] = s[top];//先把当前top存起来，比它矮的第一个木板
        s[++top] = i;//再入栈
    }
    s[top = 0] = 0;
    for (long long i = n; i >= 1; i--) {//求右边第一个小的元素
        while (a[s[top]] >= a[i]) --top;
        r[i] = s[top];
        s[++top] = i;
    }
    long long ans = 0;
    for (long long i = 1; i <= n; i++) {
        ans = max(ans, a[i] * (r[i] - l[i] - 1));//遍历找出最大面积
    }
    cout << ans << endl;
    return 0;
}
```

## 372 双生序列

例 	3 1 5 2 4  RMQ(0, 2) = 1 意味下标为0到2 的范围内最小的值在a[1]的位置
	5 2 4 3 1  RMQ(1, 2) = 1 

__本题意思就是RMQ(l,r),l r取任何值都相等的序列称为双生序列，本题要求找到最后一个最大的p,p之后两个序列就不是双生序列了，也就是找到两个序列的单调栈，然后数量不一样的位置即是所求__

>  u，vu，v 两个序列趋势相同，当且仅当对于任意 ll 和 rr，均有 RMQ(u,l,r)=RMQ(v,l,r)RMQ(u,l,r)=RMQ(v,l,r) (1≤l≤r≤n)(1≤l≤r≤n)，
>
>  其中 nn 是序列长度，RMQ(u,l,r)RMQ(u,l,r) 是 uu 序列从 ll 到 rr 中的最小值（有可能有多个最小值）的最大下标。
>
>  现有两个序列 A={a1,a2,a3,…,an}，B={b1,b2,b3,…,bn}A={a1,a2,a3,…,an}，B={b1,b2,b3,…,bn} 两个序列
>
>  请求出最大的 pp，使得A‘={a1,a2,a3,…,ap}A‘={a1,a2,a3,…,ap} 与B‘={b1,b2,b3,…,bp}B‘={b1,b2,b3,…,bp} 趋势相同。
>
> ------
>
> #### 输入
>
>  第一行输入一个整数 n(1≤n≤500000)n(1≤n≤500000)，代表 A、BA、B 序列长度。
>
>  接下来两行，每行 nn 个正整数，分别代表两个序列相应位置的值。
>
>  序列中数字大小均在 int32int32 范围内。
>
> #### 输出
>
>  输出一个整数，代表满足题意的最大 pp 值。
>
> ------
>
> #### 样例输入
>
> ```
> 5
> 3 1 5 2 4
> 5 2 4 3 1
> ```
>
> #### 样例输出
>
> ```
> 4
> ```

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
#define MAX_N 500000
int a[MAX_N + 5], b[MAX_N + 5];
int x[MAX_N + 5], y[MAX_N + 5];
int top1 = 0, top2 = 0;
int main() {
    int n, ans = 0;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> b[i];
    for (int i = 1; i <= n; i++) {
        while (top1 && x[top1] >= a[i]) --top1;
        while (top2 && y[top2] >= b[i]) --top2;
        if (top1 != top2) {
            //cout <<"1=" << top1 << "2=" << top2 <<endl;
            cout << ans << endl;
            return 0;
        }
        x[++top1] = a[i];
        y[++top2] = b[i];
        ans++;
    }
    
    return 0;
}
```

__优化版__

```C++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
#define MAX_N 500000
int a[MAX_N + 5], b[MAX_N + 5];
int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
    for (int i = 0; i < n; i++) cin >> b[i];
    int p = 0, top1 = 0, top2 = 0;
    while (p < n) {
        while (top1 >= 0 && a[top1] >= a[p]) --top1;
        while (top2 >= 0 && b[top2] >= b[p]) --top2;
        if (top1 - top2) break;
        a[++top1] = a[p];
        b[++top2] = b[p];
        p++;
    }
    cout << p << endl;
    return 0;
}
```

# 带权并查集

## 加权并查集模板

```c++
void init(int n) {//初始化
    for (int i = 1; i <= n; i++) {
        fa[i] = i;
        val[i] = 0;
    }
    return ;
}

int get(int x) {
    if (x == fa[x]) return x;
    int root = get(fa[x]);
    val[x] += val[fa[x]];//(2)
    val[x] %= 2;//此处的值取决于本题有几种状态
    return fa[x] = root;
}

int merge(int x, int y, int t) {
    int a = get(x), b = get(y);
    if (a == b) {
        return (val[x] - val[y] - t) % 2 == 0;//下图(1)
        //若x y 关系等于t 返回true，否则返回false
    }
    fa[a] = b;
    val[a] = (t + val[y] - val[x] + 3) % 3;//下图(6)
    return 1;
}
```



## 326 食物链



![326_3](/home/unique/Desktop/海贼/picture/326_3.png)

![326_4](/home/unique/Desktop/海贼/picture/326_4.png)



> 动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$吃$B$，$B$吃$C$，$C$吃$A$。
>
>  现有$N$个动物，以$1－N$编号。每个动物都是$A,B,C$中的一种，但是我们并不知道它到底是哪一种。
>
>  有人用两种说法对这$N$个动物所构成的食物链关系进行描述： 第一种说法是“$1\ X\ Y$”，表示$X$和$Y$是同类。 第二种说法是“$2\ X\ Y$”，表示$X$吃$Y$。
>
>  此人对$N$个动物，用上述两种说法，一句接一句地说出$K$句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。
>
>  当前的话与前面的某些真的话冲突，就是假话；
>
>  当前的话中$X$或$Y$比$N$大，就是假话；
>
>  当前的话表示$X$吃$X$，就是假话。
>
>  你的任务是根据给定的$N（1<=N<=50,000）$和$K$句话$（0<=K<=100,000）$，输出假话的总数。
>
> ------
>
> #### 输入
>
>  第一行是两个整数$N$和$K$，以一个空格分隔。
>
>  以下K行每行是三个正整数 $D$，$X$，$Y$，两数之间用一个空格隔开，其中D表示说法的种类。
>
>  若$D=1$，则表示$X$和$Y$是同类。
>
>  若$D=2$，则表示$X$吃$Y$。
>
> #### 输出
>
>  只有一个整数，表示假话的数目。
>
> #### 输入样例1
>
> ```
> 100 7
> 1 101 1 
> 2 1 2
> 2 2 3 
> 2 3 3 
> 1 1 3 
> 2 3 1 
> 1 5 5
> ```
>
> #### 输出样例1
>
> ```
> 3
> ```
>
> 

![326_1](/home/unique/Desktop/海贼/picture/326_1.png)__1__![326_5](/home/unique/Desktop/海贼/picture/326_5.png)__1__

![326_2](/home/unique/Desktop/海贼/picture/326_2.png)__2__

![326_6](/home/unique/Desktop/海贼/picture/326_6.png)__6__

```c++
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;
#define MAX_N 50000
// 0 a b ab同类 
// 1 a b a吃b
// 2 a b a被吃b
int fa[MAX_N + 5], val[MAX_N + 5];

void init(int n) {
    for (int i = 1; i <= n; i++) {
        fa[i] = i;
        val[i] = 0;
    }
    return ;
}

int get(int x) {
    if (x == fa[x]) return x;
    int root = get(fa[x]);
    val[x] += val[fa[x]];//(2)
    val[x] %= 3;
    return fa[x] = root;
}

int merge(int x, int y, int t) {
    int a = get(x), b = get(y);
    if (a == b) {
        return (val[x] - val[y] - t) % 3 == 0;//(1)
        //若x y 关系等于t 返回true，否则返回false
    }
    fa[a] = b;
    val[a] = (t + val[y] - val[x] + 3) % 3;//(6)
    return 1;
}

int main() {
    int n, k, ans = 0;
    cin >> n >> k;
    init(n);
    for (int i = 0; i < k; i++) {
        int x, y, t;
        cin >> t >> x >> y;
        t -= 1;
        /*ab同类
         * if (t == 1) t = 0;
         * a吃b
         * if (t == 2) t = 1
        * */
        if (x <= n && y <= n && merge(x, y, t)) continue;
        ans += 1;
    }
    cout << ans << endl;
    return 0;
}
```

## 325 parity_game

![325-2](/home/unique/Desktop/海贼/picture/325-2.png)

![325-1](/home/unique/Desktop/海贼/picture/325-1.png)

![325-3](/home/unique/Desktop/海贼/picture/325-3.png)

>  现在你和你的朋友正在玩一种游戏。 你的朋友写下一串0和1的序列，然后你选择其中一串子序列（如$[3,5]$）并且问他这个序列是包含奇数个1还是偶数个1（和是奇数还是偶数）。 你可以问你的朋友任意个问题，而你的朋友会回答你的问题。 你的任务是猜出整个朋友的序列。
>
>  但是，你发现你的朋友告诉你的信息可能有误，所以你想写一个程序来指出他的错误。这个程序应该接受一系列你的问题和答案。程序的目标是找到第一个错误的答案。
>
> ------
>
> #### 输入
>
>  输入的第1行是序列长度$L(L ≤ 1000000000)$
>
>  输入的第2行是问题的数量$Q(Q ≤ 5000) $
>
>  接下来$Q$行包括所有的问题
>
>  每一行由两个整数 $l,r$ 和描述奇偶的一个单词$even$或者$odd$组成
>
>  当单词为 $even$ 时 $[l,r]$ 的和为偶数。
>
>  当单词为 $odd$ 时 $[l,r]$ 的和为奇数。
>
> #### 输出
>
>  输出只有一行，输出一个整数$X$，表明该序列符合了前$X$个问题和答案。（不满足第$X+1$个问题）
>
>  如果序列符合所有问题的要求，应输出问题的数量$Q$。
>
> #### 输入样例1
>
> ```
> 10
> 5
> 1 2 even
> 3 4 odd
> 5 6 even
> 1 6 even
> 7 10 odd
> ```
>
> #### 输出样例1
>
> ```
> 3
> ```

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<map>
using namespace std;
#define MAX_N 10000
int fa[MAX_N + 5],val[MAX_N + 5];

void init(int n) {
    for (int i = 1; i <= n; i++) {
        fa[i] = i;
        val[i] = 0;
    }
    return ;
}

int get(int x) {
    if (x == fa[x]) return x;
    int root = get(fa[x]);
    val[x] += val[fa[x]];
    val[x] %= 2;
    return fa[x] = root;//路径压缩
}

int merge (int x, int y, int t) {//0为偶数个1,1为奇数个1
    int a = get(x), b = get(y);
    if  (a == b) {//xy处于同一个集合
        return (val[x] - val[y] - t) % 2 == 0;
    }
    fa[a] = b;
    val[a] = (t + val[y] - val[x] + 2) % 2;
    return 1;
}

map<int, int> ind;
int ind_cnt = 0;

struct Date {
    int x, y;
    string t;
}arr[MAX_N + 5];


int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> arr[i].x >> arr[i].y >> arr[i].t;
        arr[i].y += 1;//将点由闭区间变为半开半闭区间 如[1,2]变为[1,3)
        ind[arr[i].x] = 0;
        ind[arr[i].y] = 0;
    }
    for (auto iter = ind.begin(); iter != ind.end(); iter++) {
        iter->second= (++ind_cnt);
        //将点离散化 如区间为[1,999][1000,100000]变为[1,2][2,3]图三
    }
    init(ind_cnt);
    for (int i = 0; i < m; i++) {
        if (merge(ind[arr[i].x], ind[arr[i].y], arr[i].t[0] == 'o')) continue;
                                            //为odd奇数,arr[i].t[0]等于1，为偶数even,arr[0].t=0
        cout << i << endl;
        return 0;
    }
    cout << m << endl;
    return 0;
}
```

## 327 关押罪犯

>  $S$ 城现有两座监狱，一共关押着$N$ 名罪犯，编号分别为$1$~$N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为$c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为$c$ 的冲突事件。
>
>  每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到$S$ 城$Z$ 市长那里。公务繁忙的$Z$ 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。
>
>  在详细考察了$N$ 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。那么，应如何分配罪犯，才能使$Z$ 市长看到的那个冲突事件的影响力最小？这个最小值是多少？
>
> ------
>
> #### 输入
>
>  第一行为两个正整数$N(N \le 20000)$ 和$M(M \le 100000)$，分别表示罪犯的数目以及存在仇恨的罪犯对数。
>
>  接下来的$M$ 行每行为三个正整数$a_j，b_j，c_j$，表示$a_j$ 号和$b_j$ 号罪犯之间存在仇恨，其怨气值为$c_j$。数据保证$1\le a_j < b_j < N , 0 < c_j \le 1,000,000,000$ 且每对罪犯组合只出现一次。
>
> #### 输出
>
> 输出共$1$行，为$Z$ 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出$0$。
>
> #### 输入样例1
>
> ```
> 4 6
> 1 4 2534
> 2 3 3512
> 1 2 28351
> 1 3 6618
> 2 4 1805
> 3 4 12884
> ```
>
> #### 输出样例1
>
> ```
> 3512
> ```

```C++
*/
/*将所有怒气值排序，依次从上往下分配，看看是否为1(是否能分到不同监狱),直到第一个无法分到不同监狱的罪犯的怒气值即为所求
* */
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
#define MAX_N 20000
#define MAX_M 100000
int fa[MAX_N + 5], val[MAX_N + 5];

void init(int n) {
    for (int i = 1; i <= n; i++) {
        fa[i] = i;
        val[i] = 0;
    }
    return ;
}

int get(int x) {
    if (x == fa[x]) return x;
    int root = get(fa[x]);
    val[x] += val[fa[x]];
    val[x] %= 2;
    return fa[x] = root;
}

int merge(int a, int b, int t) {
    int x = get(a), y = get(b);
    if (x == y) {
        return (val[a] - val[b] - t) % 2 == 0;
    }
    fa[x] = y;
    val[x] = (t + val[b] - val[a] + 2) % 2;
    return 1;
}

struct Data {
    int x, y, c;
} arr[MAX_M + 5];

bool cmp(const Data &a, const Data &b) {
    return a.c > b.c;
}

int main() {
    int n, m;
    cin >> n >> m;
    init(n);
    for (int i = 0; i < m; i++) {
        cin >> arr[i].x >> arr[i].y >> arr[i].c;
    }
    sort(arr, arr + m, cmp);
    arr[m].x = arr[m].y = 1;//如果所有罪犯都能放在不同监狱中，应输出0，而当前arr[m].x和arr[i].y是不可能为0的所以会输出0(小技巧)
    arr[m].c = 0;
    for (int i = 0; i <= m; i++) {
        if (merge(arr[i].x, arr[i].y, 1)) continue;
        //如果可以将当前两个犯人放在两个监狱就continune
        cout << arr[i].c << endl;//说明不能放在两个监狱里
        break;
    }
    //cout << 0 << endl;
    return 0;
}
```

# 模拟

## 591 游戏

![591-1](/home/unique/Desktop/海贼/picture/591-1.png)

![591-2](/home/unique/Desktop/海贼/picture/591-2.png)

![591-3](/home/unique/Desktop/海贼/picture/591-3.png)

__由题意可知想求得胜率最大的点，游戏规则|c−a|<|c−b|，也就是任意c减去两个值最小的获胜，也就可以抽象成一个线段，如上图a为另一个人选的点，只要满足在线段中到b点最近的位置多于在线段中到a点最近的位置多(到a点最近，也就是减去a < 减去b 的值)，也就是即为所求。所以b若是想胜算最大，也就是要a右边(或左边)一点点的位置，有一种特殊情况就是n为奇数时,a为线段的中点时，b胜算最大的点有两个如图二，题中要求取小的即选左边的__

> #### 题目描述
>
>  FleaFlea 和 CricketCricket 喜欢一起玩游戏。两人的游戏规则是这样的，FleaFlea 从 1∼n1∼n 选择一个整数 aa，CricketCricket 从 1∼n1∼n 选择一个整数 bb，然后在 1∼n1∼n 中随机得到一个整数 cc，若 |c−a|<|c−b||c−a|<|c−b|，则 FleaFlea 赢，否则 CricketCricket 赢。FleaFlea 非常想赢，他已经通过他智慧的大脑了解到了 CricketCricket 将会选择的数 b=mb=m，但他仍然不知道那个随机出来的数是多少。因此他想知道，他选择的数 aa 等于多少时，他获胜的概率最大。如果满足条件的 aa 有多个，输出最小的一个。
>
> ------
>
> #### 输入
>
>  第一行两个整数 nn 和 mm，含义见问题描述。
>
> #### 输出
>
>  一行一个整数 aa，表示 FleaFlea 应该选择的数。
>
> ------
>
> #### 样例输入
>
> ```
> 3 1
> ```
>
> #### 样例输出
>
> ```
> 2
> ```

```c++
#include <iostream>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    if (n % 2 == 0) {//a如果在mid左边就选a右边的 a如果在mid右边就选a左边的
        int mid = n / 2;
        if (m <= mid) cout << m + 1 << endl;
        else cout << m - 1 << endl;
    } else {//奇数个a有可能指向中间
        int mid = (n + 1) / 2;
        if (m < mid) cout << m + 1 << endl;
        else cout << m - 1 << endl;
    }
}
```

## 587 环

> #### 题目描述
>
>  有一个圆，1∼N1∼N 共 NN 个数在圆环上顺时针排列着。
>
>  现在给你 a,b,ca,b,c 三个数，问 a −> b −> ca −> b −> c 的顺序是顺时针还是逆时针。
>
> ------
>
> #### 输入
>
>  第一行包括四个正整数 N,a,b,cN,a,b,c。
>
> #### 输出
>
>  一行一个整数，00 或 11，00 表示逆时针，11 表示顺时针。
>
> ------
>
> #### 样例输入
>
> ```
> 5 1 4 2
> ```
>
> #### 样例输出
>
> ```
> 0
> ```
>
> #### 样例说明
>
>  如图，顺序是逆时针。
>
>  ![img](http://47.93.11.51:88/img/2019-10-05/%E5%9B%BE%E7%89%871.png)

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
int main() {
    int a, b, c, d = 0;
    cin >> a >> a >> b >> c;
    if (a > b) d++;
    if (b > c) d++;
    if (c > a) d++;
    if (d == 2) cout << 0 << endl;
    else cout << 1 << endl;
    return 0;
}
```

## 588 数列

>  题目描述
>
>  小 SS 今天给你出了一道找规律题，题目如下：
>
>  有如下的数列 1，11，21，1211，111221，312211，……1，11，21，1211，111221，312211，……
>
>  小 SS 问你这个数列的第 NN 项是多少，而你一头雾水根本找不出规律。
>
>  聪明的小 RR 悄悄地告诉你是这样的：
>
>  11，
>
>  上一个数是一个 11，写作 1111，
>
>  上一个数是两个 11，写作 2121，
>
>  上一个数是一个 22，一个 11，写作 12111211，
>
>  上一个数是一个 11，一个 22，两个 11，写作 111221111221，
>
>  …………
>
>  相信聪明的你一定可以解决这个问题。
>
> ------
>
> #### 输入
>
>  第一行包括一个正整数 NN。
>
> #### 输出
>
>  一行一个正整数（注意数字可能会超过长整形，请注意用数组或者字符串存储）。
>
> ------
>
> #### 样例输入
>
> ```
> 6
> ```
>
> #### 样例输出
>
> ```
> 312211
> ```

```c++
#include <iostream>
using namespace std;

int ans[31][10005] = {{}, {1}}, n;
//第0行为空第一行为1

int main() {
    cin >> n;
    for (int i = 2; i <= n; i++) {
        int ind = 0;
        for (int j = 0; ans[i - 1][j] != 0; j++) {
            //根据上一行算当前行
            int x = 1;//x用来记录有几个相同的 
            while (ans[i - 1][j] == ans[i - 1][j + 1]) {//当上一行两个数相同时
                x++;//例3个1 x就=3，j就=1
                j++;
            }
            ans[i][ind++] = x;//所以当前行就应该是3 1
            ans[i][ind++] = ans[i - 1][j];
        }
    }
    for (int i = 0; ans[n][i] != 0; i++) {
        cout << ans[n][i];
    }
    cout << endl;
    return 0;
}
```

## 589  看电影

> #### 题目描述
>
>  听说 NOIP2019NOIP2019 模拟赛大家都考得不错，于是胡船长奖励了 KK 张的电影票奖励 OIOI 队的同学去看电影。可是 OIOI 队的同学们共有 N（N≥K）N（N≥K） 人。于是机智的你想到了一个公平公正的方法决定哪 KK 人去看电影。
>
>  NN 个人排成一圈，按顺时针顺序标号为 1−N1−N，每次随机一个还存活的人的编号，将这个人踢出。继续上述操作，直到剩下 KK 个人。
>
>  但这样显然太无聊了，于是你又想出一个牛逼的方法。
>
>  NN 个人排成一圈，按顺时针顺序标号为 1−N1−N，每次随机一个 1−N1−N 的编号，假设随机到的编号是 XX，如果编号为 XX 人还未踢出，则将这个人踢出，否则看编号为 X%N+1X%N+1（即顺时针顺序下一个编号）的人是否存活，如果还未踢出则将他踢出，否则继续看编号 （X+1）%N+１（X+1）%N+１ 的人，如果已被踢出看顺时针的下一个…………，以此类推，直到踢出一个人为止。重复上述操作，直到剩下 KK 个人。
>
>  已知你的编号是 IdId，问按照你的方法来你有多少的概率可以不被踢出，成功得到看电影的机会。
>
> ------
>
> #### 输入
>
>  第一行包括三个正整数 N,K,IdN,K,Id。（1≤K≤N≤10,1≤Id≤N）（1≤K≤N≤10,1≤Id≤N）
>
> #### 输出
>
>  一行一个最简分数，表示你可以看到电影的概率。（如果概率为 11 或 00，请输出 1/11/1 或 0/10/1）
>
> ------
>
> #### 样例输入
>
> ```
> 2 1 2
> ```
>
> #### 样例输出
>
> ```
> 1/2
> ```

__分析题意可知，要求出成功看上电影的概率，需要注意的是，不管用什么方法踢人，最后每个人选中看电影的概率都是一样的为k/n，所以本题只要求得k/n的分数最简形式即可，还要加上两个特判因为如果概率为 1或 0，请输出 1/1 或 0/1__

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}
int main() {
    int n, k, id;
    cin >> n >> k >> id;
    if (n == k) cout << "1/1" << endl;
    else if (k == 0) cout << "0/1" << endl;
    else {
        int c = gcd(n, k);
        cout << k / c << "/" << n / c << endl;
    }
    return 0;
}
```

## 592 六十四进制

![592](/home/unique/Desktop/海贼/picture/592.png)

__由题意可知z64进制代表十进制数61 ，想找到有多少对数加起来进行&运算等于该值，首先应把z化为二进制即111101，由上图可知a b&运算若结果为z那么每一位是1 相应为才是1也就是说z二进制位上为1的位置ab的对应位置也应该为1 ，z二进制位为0的位置a b相应位置一个为0一个为1 挥着两个都为0，所以所求就等于z二进制表示0位的个数个3种 ，设0的个数为n ,所求即为3^n__

> #### 题目描述
>
>  CricketCricket 给了 FleaFlea 一个六十四进制数 xx。
>
>  FleaFlea 想知道有多少对长度与 xx 相同的六十四进制数 (y,z)(y,z)，满足 yy 和 zz 求 ANDAND 的结果等于 xx。这里的 ANDAND 即二进制下的按位与（cc 语言的 &&）。yy 和 zz 可以有前导零。为了方便表示一个六十四进制数，我们作如下规定：
>
>  数字 ′0′∼′9′′0′∼′9′：表示 0∼90∼9；
>
>  大写字母 ′A′∼′Z′′A′∼′Z′：表示 10∼3510∼35；
>
>  小写字母 ′a′∼′z′′a′∼′z′：表示 36∼6136∼61；
>
>  字符 ′−′′−′：表示 6262；
>
>  字符 ′_′′_′：表示 6363。
>
> ------
>
> #### 输入
>
>  输入一行一个仅包含数字、小写字母、大写字母、减号和下划线的字符串，表示一个六十四进制数 xx。
>
> #### 输出
>
>  输出一行一个整数，表示有多少对满足条件的六十四进制数 (y,z)(y,z)。答案对 109+7109+7 取模。
>
> ------
>
> #### 样例输入
>
> ```
> z
> ```
>
> #### 样例输出
>
> ```
> 3
> ```
>
> #### 样例说明
>
>  1 . z AND _ = z
>
>  2 . z AND z = z
>
>  3 . _ AND z = z

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

char str[100005];
int num[64], num2[10] = {1, 2, 4, 8, 16, 32};
long long ans = 1;

int main() {
    cin >> str;
    for (int i = 0; i <= 63; i++) {
        int t = i;
        for (int j = 5; j >= 0; j--) {//求i二进制1的个数
            if (t >= num2[j]) {
                num[i]++;
                t -= num2[j];
            }
        }
    }
    for (int i = 0; str[i]; i++) {
        int t;
        if (str[i] >= '0' && str[i] <= '9') {
            t = str[i] - '0';
        } else if (str[i] >= 'A' && str[i] <= 'Z') {
            t = str[i] - 'A' + 10;
        } else if (str[i] >= 'a' && str[i] <= 'z') {
            t = str[i] - 'a' + 36;
        } else if (str[i] == '-') {
            t = 62;
        } else {
            t = 63;
        }
        t = 6 - num[t];//2的6次幂是64 故只有6位,用总位数-1的个数就是0的个数
        for (int i = 0; i < t; i++) {
            ans = ans * 3 % 1000000007;
        }
    } 
    cout << ans << endl;
    return 0;
}
```

## 最近点

> 给一堆点求距离最近的两个点的距离

![最近点](/home/unique/Desktop/海贼/picture/最近点.png)

__如上图所示，可以先将其从中间分开，分成两部分即s1 s2并对点照着大小排序，然后求得s1 s2集合中的最短距离分别为p1 p2，设d = min(p1, p2) 然后接下来算s1s2中最短距离，两种情况，一小于d,所以结果还是d，二小于d 所以还要继续选两个点并求最小距离，这两个点的选取范围应在(p1-mid ~ mid+p2)，因为这个范围外的点到另一个集合中的任何一个点一定都大于最小值d__

```c++
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <cmath>
using namespace std;

struct node {
    double x, y;  
};

int n;
node p[100005];

double dis(int p1, int p2) {//求两点距离
    return sqrt((p[p1].x - p[p2].x) * (p[p1].x - p[p2].x) + (p[p1].y - p[p2].y) * (p[p1].y - p[p2].y) ) ;
}

double func(int l, int r) {
    if (l == r) return 210000000000;//若只有一个点，随便设一个最大值
    if (l + 1 == r) {//若是两个点，那最小距离就是两个点的距离
        return dis(l, r);
    }
    int mid = (l + r) / 2;
    double d = min(func(l, mid), func(mid + 1, r));
    //l~mid 最小距离 和 mid+1~r最小距离，d为两部分中中小的那个，
    for (int i = mid; i >= 0 && p[mid].x - p[i].x < d; i--) {//范围
        //求左边这一块距离中间小于d之内的点
        for (int j = mid + 1; j < r && p[j].x - p[mid].x < d; j++) {
            //求右边这一块距离中间小于d之间的点
            d = min(d, dis(i, j));
        }
    }
    return d;
}

bool cmp(node a, node b) {
    if (a.x == b.x) return a. y > b.y;
    return a.x > b.x;
}

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%lf%lf", &p[i].x, &p[i].y);
    }
    sort(p, p + n, cmp);
    double ans = func(0, n - 1);
    printf("%lf\n", ans);
    return 0;
}
```

## 241 最近点对

> #### 题目描述
>
>  有 两组点，每组点的数量为 ，从 中选一个点，再从 中选一个点，求这两个点之间的最短距离是多少。
>
> ------
>
> #### 输入
>
>  第一行输入一个 。
>
>  接下来 行每行两个数代表 组每个点的横纵坐标 。
>
>  再接下来 行每行两个数代表 组每个点的横纵坐标 。
>
> #### 输出
>
>  输出最短距离，结果保留三位小数。
>
> ------
>
> #### 样例输入
>
> ```
> 4
> 0 0
> 0 1
> 1 0
> 1 1
> 2 2
> 2 3
> 3 2
> 3 3
> ```
>
> #### 样例输出
>
> ```
> 1.414
> ```

__本题大体解法上和最近点一样，只不过本题直接给了两部分，在两部分中分别找到两个点的最小距离，所以可在最近点的基础上判断这两个点是否属于一个集合，不在就要当前的距离，在一个集合就直接不要这个距离了__

```c++
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
using namespace std;

int n;
struct node {
    double x, y, z;//xy代表坐标z代表所属集合
};
node p[200005];

bool cmp(node a, node b) {
    if (a.x == b.x) return a.y < b.y;
    return a.x < b.x;
}

double dis(int p1, int p2) {//距离
    return sqrt((p[p1].x - p[p2].x) * (p[p1].x - p[p2].x) + (p[p1].y - p[p2].y) * (p[p1].y - p[p2].y));
}

double func(int l, int r) {
    if (l == r) {//一个点，设为最大值
        return 2100000000;
    }
    if (l + 1 == r) {//两个点时,需判断是否在一个集合
        if (p[l].z != p[r].z) return dis(l, r);
        return 2100000000;
    }
    int mid = (l + r) / 2;
    double d = min(func(l, mid), func(mid + 1, r));
    for (int i = mid; i >= l && p[mid].x - p[i].x < d; i--) {
		 //求左边这一块距离中间小于d之内的点
        for (int j = mid + 1; j <= r && p[j].x - p[mid].x < d; j++) {
			            //求右边这一块距离中间小于d之间的点
            if (p[i].z != p[j].z) d = min(d, dis(i, j));
        }
    }
    return d;
}

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {//规定集合1
        scanf("%lf%lf", &p[i].x, &p[i].y);
        p[i].z = 1;
    }
    for (int i = 2 * n - 1; i >= n; i--) {//集合2
        scanf("%lf%lf", &p[i].x, &p[i].y);
        p[i].z = 2;
    }
    sort(p, p + 2 * n, cmp);
    double ans = func(0, 2 * n - 1);
    printf("%.3lf\n", ans);
    return 0;
}
```

### 另一种解法

__在原来的范围基础上，算每个点向上距离小于等于d之内的点的距离__

![241-2](/home/unique/Desktop/海贼/picture/241-2.png)

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

struct node {
    double x, y, z;
};

bool cmp(node a, node b) {
    if (a.x == b.x) return a.y < b.y;
    return a.x < b.x;
}

int n, px_ind, px[1600005];
node p[200005];

bool cmp2(int a, int b) {
    return p[a].y < p[b].y;
}

double dis(int p1, int p2) {
    return sqrt((p[p1].x - p[p2].x) * (p[p1].x - p[p2].x) + (p[p1].y - p[p2].y) * (p[p1].y - p[p2].y));
}

double func(int l, int r) {
    if (l >= r) {
        return 2100000000;
    }
    if (l + 1 == r) {
        if (p[l].z != p[r].z) return dis(l, r);
        return 2100000000;
    }
    int mid = (l + r) / 2;
    double d = min(func(l, mid), func(mid + 1, r));
    int raw = px_ind;
    for (int i = mid; i >= l && p[mid].x - p[i].x < d; i--) {
        px[px_ind++] = i;//把横着符合左边条件的带你存起来
    }
    for (int j = mid + 1; j <= r && p[j].x - p[mid].x < d; j++) {
        px[px_ind++] = j;//把横着符合右边条件的带你存起来
    }
    sort(px + raw, px + px_ind, cmp2);
    for (int i = raw; i < px_ind; i++) {
        for (int j = i + 1; j < px_ind && p[px[j]].y - p[px[i]].y < d; j++) {
            //每个点与向上d内的点求最小距离
            if (p[px[i]].z != p[px[j]].z) d = min(d, dis(px[i], px[j]));
        }
    }
    return d;
}

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%lf%lf", &p[i].x, &p[i].y);
        p[i].z = 1;
    }
    for (int i = 2 * n - 1; i >= n; i--) {
        scanf("%lf%lf", &p[i].x, &p[i].y);
        p[i].z = 2;
    }
    sort(p, p + n * 2, cmp);
    double ans = func(0, 2 * n - 1);
    printf("%.3f\n", ans);
    return 0;
}
```

# 593. 魔法项链

> #### 题目描述
>
>  FleaFlea 来找 CricketCricket 询问怎么给妹子制作项链。CricketCricket 给 FleaFlea 提供了一个由小写字母组成的字符串作为制作项链的原材料。FleaFlea 平时也会收集原料，因此有时会把新的材料（一个字符）加在原材料的末尾。
>
>  FleaFlea 每次可以从这个字符串中选择一个子串，制作成一条项链。子串不能是空串。
>
>  FleaFlea 制作的项链长度都是偶数。由于 FleaFlea 致力于成为一个魔法师，因此每条项链都带有一个魔力值——这条项链前半段和后半段的相似度。两个字符串的相似度定义为，将两个字符串从左到右逐位匹配后，字符相同的位数。例如，zrlzrl 和 djldjl 的相似度是 11，而 wangyuhanwangyuhan 和 wangyuzhongwangyuzhong 的相似度是 6。
>
>  FleaFlea 只在妹子发出请求时为她制作项链。妹子的要求非常苛刻，她总是要求 FleaFlea 为她制作特定魔力值的项链。
>
>  FleaFlea 想知道，每次妹子发出请求时，他有多少种方法为她制作项链。两种制作方法不同，当且仅当两个子串的起始位置和结束位置至少有一个不同。然而 CricketCricket 作为一只单身狗，无法预见 FleaFlea 的妹子的各种奇怪的要求。因此这次 FleaFlea 只能靠自己。
>
> ------
>
> #### 输入
>
>  第一行两个正整数 nn 和 mm，表示 CricketCricket 给 FleaFlea 的原材料的长度，以及之后的操作总数。
>
>  第二行一个长度为 nn 的字符串 ss，表示原材料。
>
>  第三行至第 m+2m+2 行，每行两个元素 typetype 和 cc：
>
>  若 type=1type=1，则 cc 为一个字符，表示 FleaFlea 在原材料的末尾加了一个小写字母 cc；
>
>  若 type=2type=2，则 cc 为一个整数，表示 FleaFlea 的妹子想要魔力值为 cc 的项链。
>
> #### 输出
>
>  对于每个 type=2type=2 的操作，输出一行一个整数，表示 FleaFlea 有多少种制作项链的方法。
>
> ------
>
> #### 样例输入
>
> ```
> 6 6
> aababa
> 2 1
> 1 b
> 2 3
> 2 2
> 1 c
> 2 1
> ```
>
> #### 样例输出
>
> ```
> 3
> 0
> 3
> 4
> ```
>
> #### 样例说明
>
>  对应每一个输出，合法的方案分别是：
>
> 1. aa, aaba, aababa
> 2. “empty”
> 3. abab, baba,abab
> 4. aa, aaba, babc, aababa

![539-2](/home/unique/Desktop/海贼/picture/593-2.png)

__加进来一个字符后要判断当前总长度为多少，如果加上新来的之后为偶数就要在枚举长度一次，如果算上新来的是奇数那么就直接砍断一次就好__

![539-3](/home/unique/Desktop/海贼/picture/593-3.png)

__第一次先算好当前枚举长度个字符的值，在用当前长度枚举起点，之后就可以一个一个算了如下图__

![539-1](/home/unique/Desktop/海贼/picture/593-1.png)

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
int n, m, ans[30005], mem[30005];
//mem数组存魔力值为x的字符串个数
char str[30005];
int main() {
    cin >> n >> m >> &str[1];
    for (int i = 1; i <= n / 2; i++) {//枚举长度
        int same = 0;
        for (int j = 1, k = i + 1; j <= i; j++, k++) {//起点为1的情况
            if (str[j] == str[k]) same++;
        }
        ans[same]++;
        for (int j = 2; j + 2 * i - 1 <= n; j++) {//枚举起点，开始一次比一个，公共部分已判断完
            if (str[j - 1] == str[j - 1 + i]) same--;
            //上一次和这一次比除去公共部分的数如果相同就说明魔法值中有1个是从它哪里来的，就要减下去，求得公共部分魔法值
            if (str[j + i - 1] == str[j + 2 * i - 1]) same++;
            //这一次新加进来的比除去公共部分的数如果相同就说明应该在原有魔法值基础上加1个
            ans[same]++;
        }
        mem[i] = same;
//因为后面还可能加新字符，为了方便可直接记录下原字符串最后一块的魔法值然后直接比较新进来的字符是否和对应位置上的字符相等就可以
    }
    for (int i = 0; i < m; i++) {//m次操作
        int t;
        cin >> t;
        if (t == 2) {
            cin >> t;//t=2是输出答案
            cout << ans[t] << endl;
            continue;
        }
        char l;
        cin >> l;//新加入一个字符
        str[++n] = l;
        if (n % 2 == 0) {
            int same = 0, mid = n / 2;
            //若加入后长度为偶数，则计算新长度子串
            //例原来字符串长度为7枚举最大长度为6，加一个变8个了就能枚举8个了
            for (int j = 1, k = 1 + mid; j <= mid; k++, j++) {
                if (str[j] == str[k]) same++;
            }
            ans[same]++;
            mem[mid] = same;
        }
        for (int j = 1; j <= (n - 1) / 2; j++) {
        //将之前所有长度最后状态取出，向后移动
            if (str[n - j - j] == str[n - j]) mem[j]--;
            if (str[n] == str[n - j]) mem[j]++;
            ans[mem[j]]++;
        }
    }
    return 0;
}
```

# 枚举

> # #517. 三角形个数
>
>  统计
>
>  下一题
>
>  上一题
>
> - [ 描述](http://oj.haizeix.com/problem/517#tab-statement)
> - [ 提交](http://oj.haizeix.com/problem/517#tab-submit-answer)
> - [ 在线 IDE](http://oj.haizeix.com/problem/517#tab-custom-test)
> - [题解视频](http://oj.haizeix.com/problem/517##)
>
> ------
>
> #### 题目描述
>
>  输入一根木棒的长度 nn，将其分成三段，每段的长度是正整数，输出由这三小段木棒组成的不一样的三角形个数。
>
> ------
>
> #### 输入
>
>  第一行一个整数 nn。（1≤n≤104）（1≤n≤104）
>
> #### 输出
>
>  输出组成的不一样的三角形的个数。
>
> ------
>
> #### 样例输入
>
> ```
> 10
> ```
>
> #### 样例输出
>
> ```
> 2
> ```
>
> #### 样例说明
>
>  两个能组成的三角形边长分别为 2,4,42,4,4 和 3,3,43,3,4。

__要确定好枚举边界，不可挨个边枚举，会有很多重复，首先应先枚举三角形中最短边，最短边长应为当组合起来的三角形是等边三角形时，即范围为1~n/3 次短边长为1~(n-i)/2，最后一个边就是总长度减去前两个边的长度，最后判断一下是否可以组成三角形即可__

![517](/home/unique/Desktop/海贼/picture/517.png)

```c++
#include <iostream>
using namespace std;

int n, ans;

int main() {
    cin >> n;
    for (int i = 1; i <= n / 3; i++) {
        for (int j = i; j <= (n - i) / 2; j++) {
            int y = n - i - j;
            if (i + j > y) {
                ans++;
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```

## 599 两数之和

> #### 题目描述
>
>  给定一个从小到大的数组和一个目标数 tt，在其中找到两个数，使得两数之和与目标数相等，输出两个数在数组中的位置。
>
> ------
>
> #### 输入
>
>  第一行两个整数 n,tn,t。（1≤n≤1000000,1≤t≤20000000）（1≤n≤1000000,1≤t≤20000000）
>
>  接下来一行 nn 个数，均小于 1000000010000000。
>
> #### 输出
>
>  输出两个用空格隔开的数表示位置（从零开始计数），答案有唯一解。
>
> ------
>
> #### 样例输入
>
> ```
> 6 15
> 1 5 6 7 10 26
> ```
>
> #### 样例输出
>
> ```
> 1 4
> ```

__三种解法，件下图第一种暴力求解每个都遍历一次，时间复杂度n^2 。第二种方法遍历一次第一个数，然后target-第一个数然后二分时间复杂度nlogn。第三种，两个指针，头尾指针所指向的值相加小于target就头指针右移，如果大于target就尾指针左移__

![599](/home/unique/Desktop/海贼/picture/599.png)

```c++
#include<iostream>
using namespace std;
int n, num[10000005], target;

int main() {
	cin >> n >> target;
	for (int i = 0; i < n; i++) {
		cin >> num[i];
	}
	int l = 0, r = n - 1;
	while (l < r) {
		int sum = num[l] + num[r];
		if (sum == target) {
			cout << l << " " << r << endl;
			return 0;
		}
		if (sum < target) l++;
		else r--;
	}
	return 0;
}
```

## 600 杨氏矩阵

> #### 题目描述
>
>  给定一个 nn 行 mm 列的二维矩阵和一个目标数 tt，二维矩阵中对于每一行从左到右不下降（右边的数大于等于左边的数），对于每一列从上到下不下降（下边的数大于等于上边的数）。现要在数组中找到目标数 tt，并输出其所在位置的行数和列数。
>
> ------
>
> #### 输入
>
>  第一行三个整数 n,m,tn,m,t。（1≤n,m≤3000,1≤t≤200000）（1≤n,m≤3000,1≤t≤200000）
>
>  接下来一个二维矩阵，矩阵内所有数均小于 200000200000。
>
> #### 输出
>
>  输出两个用空格隔开的数表示位置（从一开始计数），答案有唯一解。
>
> ------
>
> #### 样例输入
>
> ```
> 3 4 15
> 1 2 3 4
> 5 6 15 20
> 7 10 20 25
> ```
>
> #### 样例输出
>
> ```
> 2 3
> ```

```c++
#include <stdio.h>
int n, m , t, num[3005][3005];

int main() {
	scanf("%d%d%d", &n, &m, &t);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			scanf("%d", &num[i][j]);
		}
	}
	int x = n, y = 1;//可以从矩阵的左下角或者右上角开始找
	while (x > 0 && y <= m) {
		if (num[x][y] == t) {
			printf("%d %d\n", x, y);
			return 0;
		}
		if (num[x][y] > t) {
			x--;
		} else {
			y++;
		}
	}
	return 0;
}
```

## 516 奶牛碑文

> #### 题目描述
>
>  约翰和他的奶牛在大草原漫游，在一块石头上发现了一些有趣的碑文。碑文似乎是一个神秘古老的语言，只包括三个大写字母 C,O,WC,O,W。尽管约翰看不懂，但是令他高兴的是，C,O,WC,O,W 的顺序形式构成了一句他最喜欢的奶牛单词 “COW”“COW”。现在，他想知道有多少次 COWCOW 出现在文本中。如果 COWCOW 内穿插了其他字符，只要 COWCOW 字符出现在正确的顺序，约翰也不介意。甚至，他也不介意出现不同的 COWCOW 共享一些字母。例如，CWOWCWOW 出现了 11 次 COWCOW，CCOWCCOW 算出现了 22 次 COWCOW，CCOOWWCCOOWW 算出现了 88 次 COWCOW。
>
> ------
>
> #### 输入
>
>  第一行一个整数 NN。（1≤N≤105）（1≤N≤105）
>
>  第二行为含有 NN 个字符的字符串，字符只可能是 C,O,WC,O,W。
>
> #### 输出
>
>  输出 COWCOW 作为输入字符串的字串出现的次数（不一定是连续的）。
>
>  答案可能会很大。
>
> ------
>
> #### 样例输入
>
> ```
> 6
> COOWWW
> ```
>
> #### 样例输出
>
> ```
> 6
> ```

__可以遍历两次分别从头遍历有多少个C，再从尾遍历字符串中有多少个W，然后分别用数组numC，numO，numW标记COW内个字符出现的位置，O出现过的位置上的numW和numC相加即可。因为能组成cow的数量就可以理解为每个O有多少种不同的CW与其搭配__

![516](/home/unique/Desktop/海贼/picture/516.png)

```c++
#include <iostream>
#include <string>
using namespace std;
string str;
typedef long long ll;
ll n, ans, numc[100005], numw[100005], nc, nw; 
int main() {
	cin >> n >>str;
	for (int i = 0; i < n; i++) {
		if (str[i] == 'C') nc++;
		numc[i] = nc;
	}
	for (int i = n - 1; i >= 0; i--) {
		if (str[i] == 'W') nw++;
		numw[i] = nw;
	}
	for (int i = 0; i < n; i++) {
		if (str[i] == 'O') {
			ans += numc[i] * numw[i];
		}
	}
	cout << ans << endl;
	return 0;
} 
```

## 519 优雅数

>  题目描述
>
>  给定两个数 L,RL,R，求 L,RL,R 之间（含）有多少个“优雅数”。
>
>  优雅数的定义：把一个数看做一个长度为 nn 的字符串（没有前导零），nn 个字符中 n−1n−1 个全相同，有且仅有一个字符不同。例如 33323,11933323,119 都是优雅的，99999,233299999,2332 都是不优雅的。
>
> ------
>
> #### 输入
>
>  输入一行两个整数 L,RL,R。（100≤L≤R≤1016）（100≤L≤R≤1016）
>
> #### 输出
>
>  输出两数间优雅数的个数。
>
> ------
>
> #### 样例输入
>
> ```
> 110 133
> ```
>
> #### 样例输出
>
> ```
> 13
> ```
>
> #### 样例说明
>
> ```
> 110,112,113,114,115,116,117,118,119,121,122,131,133
> ```

__由于数据较大，不能挨个枚举，可直接将优雅数都枚举出来，然后在判断在lr范围内有多少个__

![519](/home/unique/Desktop/海贼/picture/519.png)

```c++
#include <iostream>
#include <string>
using namespace std;
long long a, b, ans;

int main() {
	cin >> a >> b;
	for (int i = 0; i <= 9; i++) {//一堆数 
		for (int j = 0; j <= 9; j++) {//一个数 
			if (i == j) continue;
			for (int k = 3; k <= 17; k++) {//数的总长度 
				for (int l = 1; l <= k; l++) {//一个数的位置 
					if (j == 0 && l == 1) continue;//一个数为0位置在第一个
					if (i == 0 && l != 1) break;//数为0并且第一位不为0，说明有前置0
					long long t = 0;
					for (int m = 1; m <= k; m++) {
						if (m != l) {
							t = t * 10 + i;
						} else {
							t = t * 10 + j;
						}
					}
					if (t >= a &&t <= b) ans++;
				}
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```

# 贪心

## 508 两人过河

> #### 题目描述
>
>  有 nn 个人希望在晚上通过一座桥。在任何时刻，最多只能有两个人在桥上，并且必须要带着手电筒才能过桥。现在只有一个手电筒，所以必须安排某种顺序，使得手电筒可以被带回去让更多的人过桥。每个人都有不同的过桥时间，两个人一起过桥所用的时间等于其中较慢的一个人的过桥时间。现求所有人过桥的最短时间。
>
> ------
>
> #### 输入
>
>  第一行一个整数 nn。（1≤n≤1000）（1≤n≤1000）
>
>  接下来 nn 行，每行一个整数表示第 ii 人的过桥时间 TiTi。（1≤Ti≤100）（1≤Ti≤100）
>
> #### 输出
>
>  输出所有人过桥的最短时间。
>
> ------
>
> #### 样例输入
>
> ```
> 4
> 1
> 5
> 2
> 10
> ```
>
> #### 样例输出
>
> ```
> 17
> ```
>
> #### 样例说明
>
>  让 1,2 先过桥，然后让 1 回来，让 5,10 过桥，然后 2 回来再和 1 一起过桥，时间为 2+1+10+2+2=17。

![508](/home/unique/Desktop/海贼/picture/508.png)



```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
int n, num[1005], ans = 0;

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> num[i];
    }
    sort(num, num + n);
    //主要用两种策略挨个送，每次送走两个最慢的人直到剩下1，2或3个人
    for (int i = n - 1; i >= 0; i -= 2) {
        if (i == 0) {//剩一个人
            ans += num[0];
            break;
        }
        if (i == 1) {//剩两个人
            ans += num[1];
            break;
        }
        if (i == 2) {//剩三个人
            ans += num[0] + num[1] + num[2];
            break;
        }
        //两种策略取最小值的办法送走当前最慢的两个人
//策略一，最快+次快先走，最块回来，最慢+次慢去，次快回来
//策略二，最慢+次慢先走，最快回来，次慢+最快去，最快回来
                  //次快  + 最快   + 最慢   + 次快    最慢   + 最快   + 次慢       + 最快
        ans += min(num[1] + num[0] + num[i] + num[1], num[i] + num[0] + num[i - 1] + num[0]);
    }
    cout << ans << endl;
    return 0;
}
```

## 505 最大整数

> #### 题目描述
>
>  现在有 nn 个正整数，将他们连成一排，组成一个最大的整数。
>
>  例如，现在有三个整数 13,312,34313,312,343，连接成最大整数为 3433121334331213。
>
> ------
>
> #### 输入
>
>  第一行一个整数 nn。（1≤n≤100000）（1≤n≤100000）
>
>  第二行 nn 个不超过 intint 类型范围的正整数。
>
> #### 输出
>
>  输出一个数表示组成的最大整数。
>
> ------
>
> #### 样例输入
>
> ```
> 3
> 121 12 96
> ```
>
> #### 样例输出
>
> ```
> 9612121
> ```

__本题应找到a+b和b+a哪个大，然后用打的哪个方法拼接两个字符串,例a=12 b=21 1221 > 2112 即b+a > a+b,所以采用b+a,也就是把a字符放在b字符后面__

```c++
//本题可将数看成是字符串
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>//类
using namespace std;

int n;
string str[100005];

bool cmp(string a, string b) {//a是对象 string类中重载了+,就直接把两个字符串连起来
    return a + b > b + a;//排序方式为两个数组合起来更大，就用那种方式排
}

int main() {
    cin >> n;
    for  (int i = 0; i < n; i++) {
        cin >> str[i];
    }
    sort(str, str + n, cmp);
    for (int i = 0; i < n; i++) {
        cout << str[i];
    }
    cout << endl;
    return 0;
}
```

## 504 删数

> #### 题目描述
>
>  输入一个高精度的正整数 nn（长度不大于 240240 位），去掉其中任意 ss 个数字后剩下的数字按原左右次序将组成一个新的正整数，现求一种方案，使得新的正整数数值最小。
>
> ------
>
> #### 输入
>
>  第一行一个整数 nn。
>
>  第二行一个正整数 ss。
>
> #### 输出
>
>  输出一个数表示最小值，输出时忽略数字的前导零。
>
> ------
>
> #### 样例输入1
>
> ```
> 179566
> 4
> ```
>
> #### 样例输出1
>
> ```
> 15
> ```
>
> #### 样例输入2
>
> ```
> 903071
> 3
> ```
>
> #### 样例输出2
>
> ```
> 1
> ```

__本题正确做法应是是让数字符合小的数字在前大的在后的规则，不符合就删除如果都符合了，但是删除的次数还剩下例1566剩两次，就从后面删，因为大的在后面。而不能一个个看，那个字符大删哪个，例：903071删除两个数 错误做法删除后得到的答案为301 而正确则为71__

```c++
//本题主要解法是让数字符合小的数字在前大的在后的规则，不符合就删除
//如果都符合了，但是删除的次数还剩下例1566剩两次，就从后面删，因为大的在后面
#include<iostream>
//例903071
#include<string>
using namespace std;
string str;
int n;
int main() {
    cin >> str >> n;
    for (int i = 0; i  < n; i++) {
        int ind = str.size() - 1;//默认删最后面的数
        for (int j = 0; j < str.size() - 1; j++) {
            if (str[j] > str[j + 1]) {//不符合小的在前打的在后
                ind = j;
                break;
            }
        }
        str.replace(ind, 1, "");//替换为空串相当于删了
    }
    int flag = 0;
    for (int i = 0; i < str.size(); i++) {
        if (str[i] != '0') flag = 1;
        if (flag) cout << str[i];
    }
    cout << endl;
    return 0;
}
```

## 509 智力大冲浪

> #### 题目描述
>
>  小伟报名参加中央电视台的智力大冲浪节目。本次挑战赛吸引了众多参赛者，主持人为了表彰大家的勇气，先奖励每个参赛者 mm 元。接下来主持人宣布了比赛规则：
>
>  首先，比赛时间分为 nn 个时段 (n≤500)(n≤500)，它又给出了很多小游戏，每个小游戏都必须在规定期限 titi 前完成 (1≤ti≤n)(1≤ti≤n)。如果一个游戏没能在规定期限前完成，则要从奖励费 mm 元中扣去一部分钱 wiwi，wiwi 为自然数，不同的游戏扣去的钱是不一样的。当然，每个游戏本身都很简单，保证每个参赛者都能在一个时段内完成，而且都必须从整时段开始。主持人只是想考考每个参赛者如何安排组织自己做游戏的顺序。作为参赛者，小伟很想赢得冠军，当然更想赢取最多的钱！注意：比赛绝对不会让参赛者赔钱！
>
> ------
>
> #### 输入
>
>  第一行为 mm，表示一开始奖励给每位参赛者的钱；
>
>  第二行为 nn，表示有 nn 个小游戏；
>
>  第三行有 nn 个数，分别表示游戏 11 到 nn 的规定完成期限；
>
>  第四行有 nn 个数，分别表示游戏 11 到 nn 不能在规定期限前完成的扣款数。
>
> #### 输出
>
>  输出小伟能赢取最多的钱。
>
> ------
>
> #### 样例输入
>
> ```
> 10000
> 7
> 4 2 4 3 1 4 6
> 70 60 50 40 30 20 10
> ```
>
> #### 样例输出
>
> ```
> 9950
> ```

__只需将每件任务对应的扣得钱进行一个排序，把扣得钱多的任务先做完，再定义一个标记数组，用来标记某个时间段上是否有任务正在进行，如果有那就不能将该任务放在当前时间段上，因为要在限定的前几个小时内昨晚所以应该在做钱多任务的基础上，把其安排在最晚的时间做，例4 70 梭子在第四个小时做该任务就可，这样就留下前三个空闲时间可以做别的任务__

```c++
//只需将每件任务对应的扣得钱进行一个排序，把扣得钱多的任务先做完，再定义一个标记数组，用来标记某个时间段上是否有任务正在进行，如果有那就不能将该任务放在当前时间段上，因为要在限定的前几个小时内昨晚所以应该在做钱多任务的基础上，把其安排在最晚的时间做，例4 70 梭子在第四个小时做该任务就可，这样就留下前三个空闲时间可以做别的任务
#include <iostream>
#include <algorithm>
using namespace std;

struct node {
    int t, m;
};

int n, m, mark[10000] = {1};
bool cmp(node x, node y) {
    if (x.m == y.m) return x.t > y.t;
    return x.m > y.m;
}
node game[505];

int main() {
    cin >> m >> n;
    for (int i = 0; i < n; i++) {
        cin >> game[i].t;
    }
    for (int i = 0; i < n; i++) {
        cin >> game[i].m;
    }
    sort(game, game + n, cmp);
    for (int i = 0; i < n; i++) {
        for (int j = game[i].t; j >= 0; j--) {
            if (!mark[j]) {
                mark[j] = 1;
                break;
            }
            if (!j) m -= game[i].m;
        }
    }
    cout << m << endl;
    return 0;
}
```

# 字符串匹配算法

## 暴力

暴力陪陪就是从第一位对齐，开始挨个比较如果比较到不同的就从上一次对齐元素的下一个的开始对齐，继续向下比较直到模式串T都比较完了

![暴力匹配-1](/home/unique/Desktop/海贼/picture/暴力匹配-1.png)

![暴力匹配-1](/home/unique/Desktop/海贼/picture/暴力匹配-2.png)

![暴力匹配-1](/home/unique/Desktop/海贼/picture/暴力匹配-3.png)

![暴力匹配-1](/home/unique/Desktop/海贼/picture/暴力匹配-4.png)

## KMP算法

__观察可知母串和模式串中都有Sa Sb Ta Tb这四个部分__

![KMP-1](/home/unique/Desktop/海贼/picture/KMP-1.png)

__如果到黄色格子的位置失配，则模式串向后移动一位，移动后如果匹配，则说明模式串匹配上的最后一个元素一定超过了蓝色虚线，则说明蓝色虚线之前的部分就等于Ta 即Sb = Ta ，而Ta = Sa Tb = Sb __

![KMP-2](/home/unique/Desktop/海贼/picture/KMP-2.png)

__说明本是在母串中的信息Sb可以再模式串中找到__

![KMP-3](/home/unique/Desktop/海贼/picture/KMP-3.png)

__若不想漏掉答案，则在下图的情况中应还是用Sb和Ta匹配	即Ta 就是最长前缀 Tb就是最长后缀__

![KMP-4](/home/unique/Desktop/海贼/picture/KMP-4.png)

__由以上推导可得，当黄色格子失配时，无需一个一个的移动，直接从模式串中的红色格子和母串中的黄色格子开始匹配就行。如果还是失配，那么就选择母擦混中的黄色格子和移动过的模式串的大Ta 里面的小Ta'和小Tb'中间的格子来进行匹配__

![KMP-5](/home/unique/Desktop/海贼/picture/KMP-5.png)

## Sunday算法

__找到黄金对齐点位，并让其对齐再从头比较，黄金对齐点位为母串中当前正在比较的最后 一个元素的下一个，下图的黄金对齐点位就是e __

![SUNDAY-1](/home/unique/Desktop/海贼/picture/SUNDAY-1.png)

__以黄金对齐点位进行对齐，然后从头比较__

![SUNDAY-1](/home/unique/Desktop/海贼/picture/SUNDAY-2.png)

__比较到不匹配的元素时就重新找新的黄金对齐点位，当前匹配元素的下一个，即a,模式串中的黄金对齐点位，就是从后往前的第一个等于母串中的黄金对齐点位的元素__

![SUNDAY-1](/home/unique/Desktop/海贼/picture/USNDAY-3.png)

![SUNDAY-1](/home/unique/Desktop/海贼/picture/UNDAY-4.png)

+ 算法最佳时间复杂度为o(n/m)
+ 用于文档匹配中
+ 例：图中情况黄金对齐点位为h但是模式串中根本没有h,所以模式串将直接向后推进到h+1的位置，也就是移动了m位，最好的情况就是一共移动了n/m次

![SUNDAY-5](/home/unique/Desktop/海贼/picture/SUNDAY-5.png)

## SHIFT-AND 算法

+ 首先先对模式串进行预处理 d[i]表示的是每个字符在哪个位置上出现过
+ ![SHIFT-AND-1](/home/unique/Desktop/海贼/picture/SHIFT-AND-1.png)
+ 再用母串进行比较，用p数组p[i]表示的是以当前位结尾能匹配模式串字符的数量,新近母串的字符进来后，哪个位置为1就代表着母串相应位置，匹配成功了元模式串的第几位。p[3] = 1代表你呢匹配三位
+ (p << 1 | 1 & d[s[i]] )状态转移.  (p << 1) 代表新进来一个字符可能会让p能匹配的数量加1 ，(|1)值得就是进来的字符模式串的第一个字符，所以只能匹配一位 .&d[s[i]]值得是两个数匹配成功的条件就是s[i]上曾出现过该字符
+ (p & (1 << ( n - 1)) ?= 1)终态判断.判断已经在母串中找到了模式串。假如模式串长度为n，p的二进制表示n位为1就说明匹配成功
+ ![SHIFT-AND-2](/home/unique/Desktop/海贼/picture/SHIFT-AND-2.png)

# 马拉车算法

![马拉车-1](/home/unique/Desktop/海贼/picture/马拉车-1.png)

![马拉车-1](/home/unique/Desktop/海贼/picture/马拉车-2.png)

__以j为回文中心，p为关键回文中心，即当前回文中心能到达的最远的距离c[i]便是回文半径，因为是对称的，所以存在i'点(已经算过了)如果c[i']没有超过p'则c[i]==c[i'],如果超过了p'则应云鬟向后尝试__

```c++
LeetCode 5
class Solution {
public:
    string get_new_str(string &s) {
        string new_s = "#";
        for (int i = 0; i < s.size(); i++) {
            new_s += s[i];
            new_s += "#";
        }
        return new_s;
    }
    string longestPalindrome(string s) {
        int r[2010] = {0};
        string new_s = get_new_str(s);
        int ans = 0, ind = 0;
        for (int i = 0, j = 0, p = 0; new_s[i]; i++) {
            r[i] = 1;
            if (i <= p && i + r[2 * j - i] - 1 < p) {//计算r[i]的值
                r[i] = r[2 * j - i];//对称点i撇没有超过p
            } else {
                r[i] = max(1, p - i + 1);//跟新r[i]回文半径长度
                while (i - r[i] >= 0 && i + r[i] < new_s.size()
                && new_s[i + r[i]] == new_s[i - r[i]]) {//
                    r[i]++;
                }
            }
            if (i + r[i] - 1 > p) {
                j = i, p = i + r[i] - 1;
            }//整理好了关键性信息
            if (r[i] > ans) {
                ans = r[i], ind = i;
            }
        }
        string sub_str = new_s.substr(ind - ans + 1, 2 * ans - 1);
        //截取字符串从ind - ans + 1开始,截取2 * ans - 1个字符
        string ret = "";
        for (int i = 1; i < sub_str.size(); i += 2) ret += sub_str[i];
        return ret;
        }
};
```

# 字符串

> #### [165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)
>
> 难度中等79
>
> 比较两个版本号 *version1* 和 *version2*。
> 如果 `*version1* > *version2*` 返回 `1`，如果 `*version1* < *version2*` 返回 `-1`， 除此之外返回 `0`。
>
> 你可以假设版本字符串非空，并且只包含数字和 `.` 字符。
>
>  `.` 字符不代表小数点，而是用于分隔数字序列。
>
> 例如，`2.5` 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。
>
> 你可以假设版本号的每一级的默认修订版号为 `0`。例如，版本号 `3.4` 的第一级（大版本）和第二级（小版本）修订号分别为 `3` 和 `4`。其第三级和第四级修订号均为 `0`。
>
> **示例 1:**
>
> ```
> 输入: version1 = "0.1", version2 = "1.1"
> 输出: -1
> ```
>
> **示例 2:**
>
> ```
> 输入: version1 = "1.0.1", version2 = "1"
> 输出: 1
> ```
>
> **示例 3:**
>
> ```
> 输入: version1 = "7.5.2.4", version2 = "7.5.3"
> 输出: -1
> ```
>
> **示例 4：**
>
> ```
> 输入：version1 = "1.01", version2 = "1.001"
> 输出：0
> 解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。
> ```
>
> **示例 5：**
>
> ```
> 输入：version1 = "1.0", version2 = "1.0.0"
> 输出：0
> 解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。
> ```
>
>  
>
> **提示：**
>
> 1. 版本字符串由以点 （`.`） 分隔的数字字符串组成。这个数字字符串**可能**有前导零。
> 2. 版本字符串不以点开始或结束，并且其中不会有两个连续的点。

```c++
class Solution {
public:
    int getNext(string &str, int i, int &val) {//&val 引用相当于穿进去的不是val的值，而是val这个变量，所以下面的val会随着这个val的改变而改变
        val = 0;
        while (str[i] && str[i] <= '9' && str[i] >= '0') {
            val = val * 10 + str[i] - '0';
            i++;
        }
        if (str[i]) ++i;
        return i;//返回处理好当前位后的下标
    }
    int compareVersion(string version1, string version2) {
        int i = 0, j = 0, val1, val2;
        while (version1[i] || version2[j]) {
            i = getNext(version1, i, val1);//i为处理好之后的下标
            j = getNext(version2, j, val2);//while 循环时就可直接继续往下处理
            if (val1 - val2) return val1 > val2 ? 1 : -1;
        }
        return 0;
    }
};
```

## 205 同构字符串

> #### [205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)
>
> 难度简单193
>
> 给定两个字符串 **\*s*** 和 **t**，判断它们是否是同构的。
>
> 如果 **\*s*** 中的字符可以被替换得到 **t** ，那么这两个字符串是同构的。
>
> 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。
>
> **示例 1:**
>
> ```
> 输入: s = "egg", t = "add"
> 输出: true
> ```
>
> **示例 2:**
>
> ```
> 输入: s = "foo", t = "bar"
> 输出: false
> ```
>
> **示例 3:**
>
> ```
> 输入: s = "paper", t = "title"
> 输出: true
> ```

```c++
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if (s.size() - t.size()) return false;
        int s_code[256] = {0}, t_code[256] = {0};
         //s_code代表s的第i位对应着t的哪个字符，c_code代表c的第i位对应着s的哪个字符
        for (int i = 0; s[i]; i++) {
            if (s_code[s[i]] == 0) {//i还未绑定，即s[i]还没有与相对应的t[i]绑定
                if (t_code[t[i]]) return false;//对应t[i]上的值已经被绑定
                s_code[s[i]] = t[i];//绑定
                t_code[t[i]] = s[i];
            }
            int val = s_code[s[i]];
            if (val - t[i]) return false;
            //如果s[i]绑定的对应的t[i]不等于当前的t[i]
        }
        return true;
    }
};
```

## 290 单词规律

> #### [290. 单词规律](https://leetcode-cn.com/problems/word-pattern/)
>
> 难度简单150
>
> 给定一种规律 `pattern` 和一个字符串 `str` ，判断 `str` 是否遵循相同的规律。
>
> 这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `str` 中的每个非空单词之间存在着双向连接的对应规律。
>
> **示例1:**
>
> ```
> 输入: pattern = "abba", str = "dog cat cat dog"
> 输出: true
> ```
>
> **示例 2:**
>
> ```
> 输入:pattern = "abba", str = "dog cat cat fish"
> 输出: false
> ```
>
> **示例 3:**
>
> ```
> 输入: pattern = "aaaa", str = "dog cat cat dog"
> 输出: false
> ```
>
> **示例 4:**
>
> ```
> 输入: pattern = "abba", str = "dog dog dog dog"
> 输出: false
> ```
>
> **说明:**
> 你可以假设 `pattern` 只包含小写字母， `str` 包含了由单个空格分隔的小写字母。    

```c++
class Solution {
public:
    string getNext(string &s, int &i) {//找到第一个单词的第一个字符的位置
        while (s[i] == ' ') ++i;
        string ret = "";
        while (s[i] && s[i] != ' ') ret += s[i++];
        return ret;
    }
    bool wordPattern(string p, string s) {
        string p_code[256], temp;
        unordered_map<string, char> s_code;
        int ind = 0;
        for (int i = 0; p[i]; i++) {//pattern中的字符，让每个字符对单词进行一一绑定,例a绑定dog
            temp = getNext(s, ind);//例：dog
            if (temp == "") return false;
            if (p_code[p[i]] == "") {//说明pattern中的第i个字符还未绑定单词
                if (s_code.find(temp) != s_code.end()) return false;//例b应该绑定cat，但是发现cat 已经被别的字符绑定
                p_code[p[i]] = temp;//p[i]绑定上对应的单词
                s_code[temp] = p[i];//每个单词也绑定上对应的字符
            }
            if (p_code[p[i]] != temp) return false;//例b应该绑定cat，但是b绑定的值不等于cat
            //cout << ind << endl;
        }
        if (s[ind]) return false;
        return true;
    }
};
```

## 128 最长连续序列

> #### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)
>
> 难度困难331收藏分享切换为英文关注反馈
>
> 给定一个未排序的整数数组，找出最长连续序列的长度。
>
> 要求算法的时间复杂度为 *O(n)*。
>
> **示例:**
>
> ```
> 输入: [100, 4, 200, 1, 3, 2]
> 输出: 4
> 解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
> ```

__以为本题要求时间复杂度为o(n)，所以不能用排序，采取并查集和哈希表的做法，用并查集o(n)连接用哈希表查找o(1)，把数组分为处理过的和未处理的两个部分，然后用哈希表查找当前待处理元素的前一位和后一位是否存在存在就直接连接起来，并查集连接的应是数组下标而不是元素的值，例3，就在哈希表中查找2 4 查到了4 就把3与4相连，下一元素为2哈希表中查找1 3就直接1连2 2连3 1234就都连起来了__

![128](/home/unique/Desktop/海贼/picture/128.png)

```c++
class Solution {
public:
    struct UnionSet {
        int *fa, *cnt;
        UnionSet(int n) {
            fa = new int[n + 1];
            cnt = new int[n + 1];
            for (int i = 0; i <= n; i++) {
                fa[i] = i;
                cnt[i] = 1;//cnt[i]记录的是在这个集合中以i作为根节点的这棵子树的结点的数量
            }
        }
        bool isroot(int x) {
            return x == fa[x];
        }
        int get(int x) {//路径优化
            return (fa[x] = (x == fa[x] ? x : get(fa[x])));
        }
        void merge(int a, int b) {//合并
            int aa = get(a), bb = get(b);
            if (aa == bb) return ;//ab已经在同一个集合中就continue
            fa[aa] = bb;//b当父节点
            cnt[bb] += cnt[aa];//b的结点个数跟更新
            return ;
        }
        ~UnionSet() {//析构函数
            delete[] fa;
            delete[] cnt;
        }
    };

    int longestConsecutive(vector<int>& nums) {
        UnionSet u(nums.size());
        unordered_map<int, int> h;
        for (int i = 0; i < nums.size(); i++) {
            if (h.find(nums[i]) != h.end()) continue;//当前数字在哈希表中存在，即已经处理过了
            if (h.find(nums[i] - 1) != h.end()) {//查找当前数字的前一位是否存在
                u.merge(i, h[nums[i] - 1]);
            }
            if (h.find(nums[i] + 1) != h.end()) {//查找当前数字的后一位是否存在
                u.merge(i, h[nums[i] + 1]);
            }
            h[nums[i]] = i;//当前数字存到哈希表中，说明i已经处理过了
        }
        int ans = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (!u.isroot(i)) continue;//如果不是根节点continue
            ans = max(ans, u.cnt[i]);//找最长的连续序列
        }
        return ans;
    }
};
```

## 130 被围绕的区域

> #### [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)
>
> 难度中等215收藏分享切换为英文关注反馈
>
> 给定一个二维的矩阵，包含 `'X'` 和 `'O'`（**字母 O**）。
>
> 找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。
>
> **示例:**
>
> ```
> X X X X
> X O O X
> X X O X
> X O X X
> ```
>
> 运行你的函数后，矩阵变为：
>
> ```
> X X X X
> X X X X
> X X X X
> X O X X
> ```
>
> **解释:**
>
> 被围绕的区间不会存在于边界上，换句话说，任何边界上的 `'O'` 都不会被填充为 `'X'`。 任何不在边界上，或不与边界上的 `'O'` 相连的 `'O'` 最终都会被填充为 `'X'`。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。

__本题用并查集，将相邻的o相连，边上的o与虚拟0编号相连，就可区分哪个该改，哪个不该改__

```c++
class Solution {
public:
    struct UnionSet {
        int *fa, *cnt;
        UnionSet(int n) {
            fa = new int[n + 1];
            cnt = new int[n + 1];
            for (int i = 0; i <= n; i++) {
                fa[i] = i;
                cnt[i] = 1;
            }
        }
        bool isroot(int x) {
            return x == fa[x];
        }
        int get(int x) {
            return (fa[x] = (x == fa[x] ? x : get(fa[x])));
        }
        void merge(int a, int b) { 
            int aa = get(a), bb = get(b);
            if (aa == bb) return ;
            fa[aa] = bb;
            cnt[bb] += cnt[aa];
            return ;
        }
        ~UnionSet() {
            delete[] fa;
            delete[] cnt;
        }
    };
    int n, m;
    int ind(int i, int j) {
        return (i * m) + j + 1;
    }
    void solve(vector<vector<char>>& board) {
        if (board.size() == 0) return ;
        n = board.size();
        m = board[0].size();
        UnionSet u(n * m);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (board[i][j] == 'X') continue;
                if (i && board[i - 1][j] == 'O') u.merge(ind(i, j), ind(i - 1, j));
                //将o的上面左面如果是o就连接起来，下面右边不用连接，因为连接是相互的
                if (j && board[i][j - 1] == 'O') u.merge(ind(i, j), ind(i, j - 1));
                if (i == 0 || i == n - 1) u.merge(ind(i, j), 0);//嘴上或最下边
                //在边上的o不需要改，为了区分让边上的o与虚拟0编号相连接
                if (j == 0 || j == m - 1) u.merge(ind(i, j), 0);//最左或最右边
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (board[i][j] == 'X') continue;//是x就忽略
                if (u.get(ind(i, j)) == u.get(0)) continue;//与虚拟0编号相连的即边上的o就忽略
                board[i][j] = 'X';
            }
        }
        return ;
    }
};
```

# 堆与优先队列

# 查找

## 349 交集

> 给定两个数组，编写一个函数来计算它们的交集。
>
> 示例 1:
>
> 输入: nums1 = [1,2,2,1], nums2 = [2,2]
> 输出: [2]
> 示例 2:
>
> 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出: [9,4]

```C++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> h;//哈希表
        vector<int> ret;
        for (int i = 0; i < nums1.size(); i++) {
            h[nums1[i]] = 1;//降低一个数组都添加2进哈希表中
        }
        for (int i = 0; i < nums2.size(); i++) {
            if (h.find(nums2[i]) == h.end()) continue;//num2[i]不存在,说明不是交集中的
            if (h[nums2[i]] == 0) continue;//num2[i]存在,是交集,但是结果数组中已经添加过了
            ret.push_back(nums2[i]);
            h[nums2[i]] = 0;
        }
        return ret;
    }
};
```

## 杨氏矩阵中第k 小的元素

> #### [378. 有序矩阵中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)
>
> 难度中等210
>
> 给定一个 *n x n* 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。
> 请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。
>
> **示例:**
>
> ```
> matrix = [
>    [ 1,  5,  9],
>    [10, 11, 13],
>    [12, 13, 15]
> ],
> k = 8,
> 
> 返回 13。
> ```

__矩阵中小于等于5 6 7 的个数为6个，小于等于8的个数为10个，所以8就是第7小的数__

![378-1](/home/unique/Desktop/海贼/picture/378-1.png)

__因为杨氏矩阵的每一行每一列的值都是递增的，所以每一列小于x的数一定呈阶梯状，如下图__

![378-2](/home/unique/Desktop/海贼/picture/378-2.png)

```
class Solution {
public:

    int check(vector<vector<int>>& matrix, int x, int n, int m) {
        int cnt = 0, j = n;
        for (int i = 0; i < m; i++) {
            while (j && matrix[j - 1][i] > x) --j;//从向至上找到第一个小于等于x的值
            cnt += j;
        }
        return cnt;
    }
    int kthSmallest(vector<vector<int>>& matrix, int k) {
                    //一个vector里面还有一个vector
        int n = matrix.size(), m = matrix[0].size();
        int l = matrix[0][0], r = matrix[n - 1][m - 1];
        //matrix[0][0]大数组里存了多少个数组就相当于矩阵的行
        //matrix[n - 1][m - 1]大数组中的每个小数组有多大,相当于矩阵的列
        int mid, ret;
        while (l < r) {
            mid = (l + r) >> 1;
            ret = check(matrix, mid, n, m);
            if (ret < k) l = mid + 1;
            else r = mid;
        }
        return l;
    }
};
```

## 8字符串转换

```
判断溢出 将num存起来，再对num做了相应操作后(例乘10)得num2，num2做相反的操作(除10)，看看num是否还等于num2 
```

> #### [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)
>
> 难度中等697
>
> 请你来实现一个 `atoi` 函数，使其能将字符串转换成整数。
>
> 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：
>
> - 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
> - 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
> - 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。
>
> 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。
>
> 在任何情况下，若函数不能进行有效的转换时，请返回 0 。
>
> **提示：**
>
> - 本题中的空白字符只包括空格字符 `' '` 。
> - 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。
>
>  
>
> **示例 1:**
>
> ```
> 输入: "42"
> 输出: 42
> ```
>
> **示例 2:**
>
> ```
> 输入: "   -42"
> 输出: -42
> 解释: 第一个非空白字符为 '-', 它是一个负号。
>      我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
> ```
>
> **示例 3:**
>
> ```
> 输入: "4193 with words"
> 输出: 4193
> 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
> ```
>
> **示例 4:**
>
> ```
> 输入: "words and 987"
> 输出: 0
> 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
>      因此无法执行有效的转换。
> ```
>
> **示例 5:**
>
> ```
> 输入: "-91283472332"
> 输出: -2147483648
> 解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 
>      因此返回 INT_MIN (−231) 。
> ```

```c++
class Solution {
public:
    int myAtoi(string str) {
        int flag = 1, num = 0, i = 0, pre_max = INT_MAX / 10, d = INT_MAX % 10;
        //pre_max = INT_MAX / 10代表的就是最大值的倒数第二位, d = INT_MAX % 10最大值最后一位数
        //也就是说用来判断，当前值如果大于pre_max并且待连接的值又大于d那么两个数连接起来就一定会溢出
        while (str[i] == ' ') ++i;
        if (str[i] == '-') flag = -1, ++i;
        else if (str[i] == '+') flag = 1, ++i;
        while (str[i]) {
            if (str[i] < '0' || str[i] > '9') break;
            if (num > pre_max || 
                (num == pre_max && (str[i] - '0') > d)) {//判断溢出
                return flag == 1 ? INT_MAX : INT_MIN;
            }
            num = num * 10 + (str[i] - '0');
            i++;
        }
        return num * flag;
    }
};
```

# 树状数组

> <https://www.cnblogs.com/xenny/p/9739600.html>

树状数组求和公式 Si = Ci + S(i - lobit(i)) 例 S7 = C7 + C6 + C4

![树状数组](/home/unique/Desktop/海贼/picture/树状数组.png)

若要修改一个值，那么所需要修改的树状数组的值的公式为 i + lowbit(i) ,例修改了C5 那么需要修改的值分别是C6(5 + lowbit5) C8(6 + lowbit6) C16(8 + lowbit8) ,每个都等于上一个i + lowbit(i)

![树状数组-2](/home/unique/Desktop/海贼/picture/树状数组-2.png)

### 328楼兰图腾

> #### 题目描述
>
>  在完成了分配任务之后，西部314314来到了楼兰古城的西部。相传很久以前这片土地上(比楼兰古城还早)生活着两个部落，一个部落崇拜尖刀(‘V’)，一个部落崇拜铁锹(‘∧’)，他们分别用V和∧的形状来代表各自部落的图腾。 西部314314在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了NN个点，经测量发现这NN个点的水平位置和竖直位置是两两不同的。西部314314认为这幅壁画所包含的信息与这NN个点的相对位置有关，因此不妨设坐标分别为(1,y1),(2,y2),…,(n,yn),(1,y1),(2,y2),…,(n,yn),其中y1...yny1...yn是11到nn的一个排列。
>
>  西部314打算研究这幅壁画中包含着多少个图腾，其中V图腾的定义如下（注意：图腾的形式只和这三个纵坐标的相对大小排列顺序有关）1≤i<j<k≤n1≤i<j<k≤n且yi>yj,yj<ykyi>yj,yj<yk;
>
>  而崇拜∧的部落的图腾被定义为1≤i<j<k≤n1≤i<j<k≤n且yi<yj,yj>ykyi<yj,yj>yk;
>
>  西部314314想知道，这nn个点中两个部落图腾的数目。因此，你需要编写一个程序来求出V的个数和∧的个数。
>
> ------
>
> #### 输入
>
>  第一行一个整数nn，代表点的个数n≤200000n≤200000
>
>  第二行是由空格分割开的nn个数，分别代表y1，y2……yny1，y2……yn
>
> #### 输出
>
> 两个由空格分隔开的整数，代表V的个数和∧的个数，答案不超过(long long)(long long)范围
>
> #### 输入样例1
>
> ```
> 5
> 1 5 3 2 4
> ```
>
> #### 输出样例1
>
> ```
> 3 4
> ```

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
long long c[200005] = {0};
long long lowbit(int x) {//求二进制位最后一个1位的权值
    return x & (-x);
}

void add(long long i, int val, int n) {//更新
    while (i <= n) c[i] += val, i += lowbit(i);
}

long long qurry(int i) {//求和
    long long sum = 0;
    while (i) sum += c[i], i -= lowbit(i);
    return sum;
}

int main() {
    long long n, a, A, V;
    cin >> n;
    for (long long i = 1; i <= n ;i++){
        cin >> a;
        //cout << qurry(a) << endl;
        long long frontsmaller = qurry(a);//对于当前a前面小于a的数有几个
        long long backsmaller = (a - 1 - frontsmaller);//因为是1～n的序列所以a-1代表一共有多少个数小于当前数例，3有两个数小于即1,2，一共a-1个数小于a,所以总数减去前面小于的数量就是后面小于a的数量
        long long frontbiger = (i - 1 - frontsmaller);//前面大于a的数量就是，前面的数减去前面小于a的数就得到前面大于a的数
        long long backbiger = (n - a - frontbiger);//总数减去小于a的总数得到大于a的总数再减去前面大于a的数就是后面大于a的数
        A += frontsmaller * backsmaller;
        V += frontbiger * backbiger;
        add(a, 1, n);
    } 
    cout << V << " " << A << endl;
    return 0;
}
```

# STL

> <http://oj.haizeix.com/problem/379>

```
某仓库购入新的货物（每次购入的货物均不同）并将一部分老货物发出，这个过程会有软件对数据以日志形式保存，规则如下：
 该日志记录了两类操作：第一类操作为入库操作，以及该次入库的货物数量；第二类操作为出库操作。这些记录都严格按时间顺序排列。入库和出库的规则为先进后出，即每次出库操作货物为当前在仓库里所有货物中最晚入库的货物。
 为了便于分析，现在加入了第三类查询操作，每次查询时，输出当前仓库数量最多的货物的数量。
输入
 包含 N+1N+1 行：
 第一行为 11 个正整数 NN，对应于日志内所含操作的总数。
 接下来的 NN 行，分别属于以下三种格式之一：
 格式 11: 0 X0 X //一次入库操作，正整数 XX 表示该次入库的货物的数量
 格式 22: 11 //一次出库操作，（就当时而言）最后入库的货物出库
 格式 33: 22 //一次查询操作，要求分析程序输出当前仓库内数量最多的货物的数量
 当仓库为空时你应该忽略出库操作，当仓库为空查询时你应该输出 00。
 初始时仓库状态为空。
输出
 输出行数等于日志中查询操作的次数。每行为一个正整数，表示查询结果。
样例输入
13
0 1
0 2
2
0 4
0 2
2
1
2
1
1
2
1
2
样例输出
2
4
4
1
0
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

int n,top,x,op;
int stack[200050]; //注意！！！这里是数组！！！

int main()
{
    memset(stack,0,sizeof(stack));
    scanf("%d",&n);
    top=0;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&op);
        switch(op)
        {
            case 0:    scanf("%d",&x);
                    stack[++top]=max(x,stack[top-1]);
                    //看看上一个和当前的这个哪个大，再让大的“入站”，就是所谓的进入数组
                    break;
            case 1: top--; break;
            case 2: printf("%d\n",stack[top]); break;
        }//top相当于指针，最后输出top 所指向的数
    }
    return 0;
}
```

## 小技巧

#####约瑟夫环公式

```
f(N,M)=(f(N−1,M)+M)%N
int cir(int n,int m)
{
	int p=0;
	for(int i=2;i<=n;i++)
	{
		p=(p+m)%i;
	}
	return p+1;
}
```



![约瑟夫环公式](/home/unique/Desktop/海贼/picture/约瑟夫环公式.png)

### 抽屉原理

```
int num[10] = {1, 0};
while (tmp) {
        if (num[tmp % 10]) return 0;
        num[tmp % 10] += 1;
        tmp /= 10;
    }
```



###翻转数

```
for (int i = 1; i < digit; i++) {
        tmp = (tmp % 10) * h + tmp / 10;
        if (is_prime[tmp]) return 0;
 }
 123 312 231 
    
```

###交换

```
void swap(int a, int b) {//异或运算
    a ^= b;
    b ^= a;
    a ^= b;
    return ;
}
……………………………………………………………………………………………………………………………………………………………………
void swap(int* a, int* b) {//指针变量
    int t;
    t = *a;
    *a = *b;
    *b = t;
}
……………………………………………………………………………………………………………………………………………………………………
void swap(int &a, int &b) {//通过引用
    int t;
    t = a;
    a = b;
    b = t;
}
……………………………………………………………………………………………………………………………………………………………………
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b, b = __temp;\
}
```

### 如何实现将一个n位整数拼到m位整数后面的方法？并返回n+m?

```
while (digits(ans) < 9) {
        ans *= pow(10, digits(x * n));
        ans += n * x;
        n += 1;
    }
    if (digits(ans) - 9) return 0;
```

### 大整数运算中处理进位框架

```
  处理进位框架
  for (int i = 1; i <= ans[0]; i++) {
            if (ans[i] < 10) continue;
            ans[i + 1] += ans[i] / 10;
            ans[i] %= 10;
            /*if (i == 10) {
                ans[0] += 1;
            }*/
            ans[0] += (i == ans[0]);
        }
```

### 求数的素因子个数

```
int prime[max_n + 5] = {0};
void init() {
    for (int i = 2; i <= max_n; i++) {
        if (prime[i]) continue;
        for (int j = i; j <= max_n; j += i) {
            prime[j] += 1;
        }
    }
    return ;
}
```

# leedcode

### 链表

#### 19删除倒数第N个元素

> <https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/>

对于此题，定义虚拟头结点并指向头结点，定义两个指针 p, q, p先走n 步， 然后在多走一步，然后p与q开始同时走，当p走到NULL时，q 就会走到倒数第n 个元素(也就是待删除元素的前一个元素)，然后让p 指向q的下一个元素即待删除元素，然后让q 指向p的下一个元素，释放p

1->2->3->4->5 删除倒数第2个元素4， 就相当于删除第4个元素

即长度为L的链表，如果向删除第n个元素，就相当于删除第(L - n + 1) 个元素, 所以先让p走n + 1步，然后p和q 同时走，也就是说当p走到NULL时，就说明q正好走了(L - n + 1)步，就在带删除元素的前一个

```c
struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
   struct ListNode f, *p, *q;
    f.next = head;
    p = q = &f;
    while (n--) p = p->next;
    p = p->next;
    while (p) {
        q = q->next;
        p = p->next;
    }
    p = q->next;
    q->next = p->next;
    free(p);
    return f.next;
}
```

#### 24两两交换链表中结点

> <https://leetcode-cn.com/problems/swap-nodes-in-pairs/>

1->2->3->4  =>   2->1->4->3

定义虚拟头结点指向头结点，p为虚拟节点的地址，q指向头结点，p指向q 的下一个(链表的第二个)相当于虚拟头结点的第一个元素为2,然后接下来让q指向虚拟头结点的next next, 让1和3连接上。最后让2脸上3，循环下去直至NULL

```c
struct ListNode* swapPairs(struct ListNode* head){
    struct ListNode ret, *p, *q;
    ret.next = head;
    p = &ret;
    q = head;
    while (q && q->next) {
        p->next = q->next;
        q->next = p->next->next;
        p->next->next = q;
        p = q;
        q = q->next;
    }
    return ret.next;
}
```

#### 141环形链表

> <https://leetcode-cn.com/problems/linked-list-cycle/>

![141leedcode](/home/unique/Desktop/海贼/picture/141leedcode.png)

运用快慢指针，快指针走两步，慢指针一次走一步，只要有环那快慢指针终会相遇

```c
bool hasCycle(struct ListNode *head) {
    struct ListNode *a = head, *b = head;
    if (a == NULL) return false;
    do {
        a = a->next;
        b = b->next;
        if (b == NULL || b->next == NULL) return false;
        b = b->next;
    } while (a != b);
    return true;
}
```

#### 160相交链表

> leedcode 160.相交链表<https://leetcode-cn.com/classic/problems/intersection-of-two-linked-lists/description/>

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct ListNode *p = headA, *q = headB;
    while (p != q) {
        p = p ? p->next : headB;
        q = q ? q->next : headA;
    }
    return q;
}
```

#### 234 回文链表

> <https://leetcode-cn.com/problems/palindrome-linked-list/submissions/>

```c
int length(struct ListNode *head) {//获取长度
    int len = 0;
    while (head) len += 1, head = head->next;
    return len;
}

struct ListNode *getNode (struct ListNode *head, int ind) {//找到链表的最后一个元素
    while (ind--) head = head->next;
    return head;
}

struct ListNode *reverse(struct ListNode *head) {//将原链表翻转
    struct ListNode *p = head, *q, ret;
    ret.next = NULL;
    while (p) {
        q = p->next;
        p->next = ret.next;
        ret.next = p;
        p = q;
    }
    return ret.next;
}
bool isPalindrome(struct ListNode* head){
    int len = length(head);
    struct ListNode *p = head, *q = reverse(getNode(head, (len + 1) / 2));
    //翻转后的链表和原链表比较，相同则为回文链表
    while (q) {
        if (p->val - q->val) return false;
        p = p->next;
        q = q->next;
    }
    return true;
}
```

#### 669 修剪二叉搜索树

> <https://leetcode-cn.com/problems/trim-a-binary-search-tree/>

```c
给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。
三种情况：
0 [1,2, 3]
root->val　< L, root及左枝剪掉，右枝提升为root; 
2 [1,2,3] 
: L <= roor->val <= R, 正常修剪
4 [1,2,3]
: root->val > R ,root及右枝剪掉，左枝提升为root.

作者：anribras
链接：https://leetcode-cn.com/problems/trim-a-binary-search-tree/solution/zhi-guan-de-di-gui-jie-fa-c-100-faster-by-anribras/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int L, int R) {
        if(!root ) return nullptr;
        //剪枝分三种情况 0 [1,2, 3,] 2 [1,2,3] 4 [1,2,3]
        // 0 [1,2,3] ,左枝都不要了 root不要了，root=右枝
        if ( root->val < L) {
            root->left = nullptr;
            root = trimBST(root->right,L,R);
            return root;
        }
        // 2 [1,2,3];
        if ( root->val >= L && root->val <= R) {
            root->left = trimBST(root->left,L,R);
            root->right = trimBST(root->right,L,R);
            return root;
        }
        // 4 [1,2,3];
        if ( root->val > R) {
            root->right  = nullptr;
            root = trimBST(root->left,L,R);
            return root;
        }
        
        return root;      
        
    }
};
```

#### 142 环形链表

> <https://leetcode-cn.com/problems/linked-list-cycle-ii/>

![leedcode 142](/home/unique/Desktop/海贼/picture/leedcode 142.png)

```c
struct ListNode *detectCycle(struct ListNode *head) {
    struct ListNode *p, *q;
    q = p = head;
    if (head == NULL) return NULL;
    do {
        p = p->next;
        q = q->next;
        if (q == NULL || q->next == NULL) return NULL;
        q = q->next;
    } while (q != p);
    int cnt = 0;
    do {
        cnt++;
        p = p->next;
    } while (p != q);
    q = p = head;
    while (cnt--) p = p->next;
    while (q != p) p = p->next, q = q->next;
    return p;
}
```

#### 142 环形链表2

> <https://leetcode-cn.com/problems/linked-list-cycle-ii/>

用快慢指针先看看该链表是否有环，然后一个指针不动，另一个指针走到两个指针相遇为止，这样就知道环内有几（cnt）个元素，然后让两个指针在同时指向头结点，一个先走cnt步，然后开始两个指针一起走，两个指针相遇的地方就是开始入环的第一个节点

```c
struct ListNode *detectCycle(struct ListNode *head) {
    struct ListNode *p, *q;
    q = p = head;
    if (head == NULL) return NULL;
    do {
        p = p->next;
        q = q->next;
        if (q == NULL || q->next == NULL) return NULL;
        q = q->next;
    } while (q != p);
    int cnt = 0;
    do {
        cnt++;
        p = p->next;
    } while (p != q);
    q = p = head;
    while (cnt--) p = p->next;
    while (q != p) p = p->next, q = q->next;
    return p;
}


/*struct ListNode *detectCycle(struct ListNode *head) {
    struct ListNode *p = head, *q = head;
    if (p == NULL) return NULL;
    do {
        p = p->next;
        q = q->next;
        if (q == NULL || q->next == NULL) return NULL;
        q = q->next;
    } while (p != q);
    int cnt = 0;
    do {
        cnt++;
        p = p->next;
    } while (p != q);
    p = head, q = head;
    while (cnt--) q = q->next;
    while (p != q) p = p->next, q = q->next;
    return p;
}*/
```



#### 160 相交链表

> <https://leetcode-cn.com/problems/intersection-of-two-linked-lists/>

![160leedcode](/home/unique/Desktop/海贼/picture/160leedcode.png)

定义两个指针p 指向A ， p指向B，假设A链表相交前长度为 a B链表相交前长度为b 公共部分为为x。 所以A的长度为(a + x)，B的长度为(b + x)，可得

(a + x) + b = (b + x) + a, 也就是说两个指针从头开始走, p走到头后在从B的头走，q走到头后从A的头开始走。如果相遇了（相等）就代表这两条链表是相交的

```c
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct ListNode *p = headA, *q = headB;
    while (p != q) {
        p = p ? p->next : headB;
        q = q ? q->next : headA;
    }
    return q;
}
```

#### 202 快乐数

> <https://leetcode-cn.com/problems/happy-number/>

可将其看成链表，如果直到最后某个数的按位平方和相加为1为普通链表，如果一直在两个数循环就是带环的链表，可用快慢指针。

```c
/*
编写一个算法来判断一个数是不是“快乐数”。
一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。
输入: 19
输出: true
解释: 
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1*/
int solve(int n) {
    int sum = 0;
    while (n) {
        sum += (n % 10) * (n % 10);
        n /= 10;
    }
    return sum;
}

bool isHappy(int n){
    int a = n, b = n;
    while (b != 1) {
        a = solve(a);
        b = solve(solve(b));
        if (a == b) break;//在两个数之间循环那么快慢指针就会相等，然后退出循环
    }
    return (b == 1);
}
```

#### 203 移除链表元素

> <https://leetcode-cn.com/problems/remove-linked-list-elements/>

为了删除元素可直接让指针在待删除元素的前一个，故判断p->next->val是否为待删除元素，然后用另一个指针指向待删除，然后让前一个元素指向后一个元素的下一个在释放掉后一个指针即可。

```c
/*删除链表中等于给定值 val 的所有节点。
输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5*/
struct ListNode* removeElements(struct ListNode* head, int val){
    struct ListNode ret, *p = &ret, *q;
        ret.next = head;
        while (p && p->next) {
            if (p->next->val == val) {
                q = p->next;
                p->next = p->next->next;
                free(q);
            } else {
                p = p->next;
            }
        }
        return ret.next;
}
```

#### 206 翻转链表

> <https://leetcode-cn.com/problems/reverse-linked-list/>

用虚拟头结点然后用头插法即可。

头插法：虚拟头结点指向空p指向头结点，q指向p的下一个，p指向虚拟头结点的下一个，然后再让虚拟头结点指向p，最后p = q, 循环下去，直至p == NULL。

```c
struct ListNode* reverseList(struct ListNode* head){
    struct ListNode ret, *p, *q;
    p = head;
    ret.next = NULL;
    while (p != NULL) {
        q = p->next;
        p->next = ret.next;
        ret.next = p;
        p = q;
    }
    return ret.next;   
}
```

#### 双向链表翻转

```c++
ListNode* reverseLinkedList(ListNode *head) {
    ListNode *p, *q;
    p = head;
    while (1) {
        q = p->next;
        p->next = p->pre;
        p->pre = q;
        if (p->pre == NULL) break;
        p = p->pre;
    }
    return p;
}
```

## 栈和队列

### 20 有效的括号

> <https://leetcode-cn.com/problems/valid-parentheses/

用数组实现一个栈即可，左括号入栈，右括号看当前栈顶元素与其是否匹配

```c
/*判断给定括号是否匹配 输入: "()" 输出: true  输入: "([)]"  输出: false
*/
bool isValid(char * s){
    int len = strlen(s);
    char *stack = (char *)malloc(sizeof(char) * len);
    int flag = 1, top = -1;
    while (s[0]) {
        switch (s[0]) {
            case '(':
            case '{':
            case '[':stack[++top] = s[0];break;
            case ')':flag = (top != -1 && stack[top--] == '('); break;
            case ']':flag = (top != -1 && stack[top--] == '['); break;
            case '}':flag = (top != -1 && stack[top--] == '{'); break;
        }
        s++;
        if (flag == 0) break;
    }
    return (flag && top == -1);
}
```

### 225 用队列实现栈

> <https://leetcode-cn.com/problems/implement-stack-using-queues/>

定义两个栈来回倒

```c
typedef struct MyQueue {
    int *data;
    int head, tail;
    int size, cnt;
}MyQueue;

MyQueue *MyQueueCreate(int size) {
    MyQueue *q = (MyQueue *)malloc(sizeof(MyQueue));
    q->data = (int *)malloc(sizeof(int) * size);
    q->head = q->tail = 0;
    q->cnt = 0;
    q->size = size;
    return q;
}

void MyQueuePush(MyQueue *obj, int x) {
    if (obj == NULL) return ;
    if (obj->cnt == obj->size) return ;
    obj->data[(obj->tail)++] = x;
    if (obj->tail == obj->size) obj->tail -= obj->size;
    obj->cnt += 1;
    return ;
}

int MyQueueFront(MyQueue *obj) {
    return obj->data[obj->head];    
}

int MyQueuePop(MyQueue *obj) {
    if (obj == NULL) return 0;
    if (obj->cnt == 0) return 0;
    obj->head += 1;
    if (obj->head == obj->size) obj->head -= obj->size;
    obj->cnt -= 1;
    return 1;
}

int MyQueueEmpty(MyQueue *obj) {
    return obj->cnt == 0;
}

void MyQueueFree(MyQueue *obj) {
    if (obj == NULL) return ;
    free(obj->data);
    free(obj);
    return ;
}

typedef struct {
    MyQueue *q1, *q2;
} MyStack;

/** Initialize your data structure here. */

MyStack* myStackCreate() {
   int size = 1024;
    MyStack *obj = (MyStack *)malloc(sizeof(MyStack));
    obj->q1 = MyQueueCreate(size);
    obj->q2 = MyQueueCreate(size);
    return obj;
}

/** Push element x onto stack. */
void myStackPush(MyStack* obj, int x) {
    if (!MyQueueEmpty(obj->q1)) {
        MyQueuePush(obj->q1, x);
    } else {
        MyQueuePush(obj->q2, x);
    }
    return ;
}

/** Removes the element on top of the stack and returns that element. */
int myStackPop(MyStack* obj) {
    MyQueue *p = MyQueueEmpty(obj->q1) ? obj->q2 : obj->q1;
    MyQueue *q = MyQueueEmpty(obj->q1) ? obj->q1 : obj->q2;
    int element = MyQueueFront(p);
    MyQueuePop(p);
    while (!MyQueueEmpty(p)) {
        MyQueuePush(q, element);
        element = MyQueueFront(p);
        MyQueuePop(p);
    }
    return element;
}

/** Get the top element. */
int myStackTop(MyStack* obj) {
    MyQueue *p = MyQueueEmpty(obj->q1) ? obj->q2 : obj->q1;
    MyQueue *q = MyQueueEmpty(obj->q1) ? obj->q1 : obj->q2;
    int element;
    while (!MyQueueEmpty(p)) {
        element = MyQueueFront(p);
        MyQueuePop(p);
        MyQueuePush(q, element);
    }
    return element;
}

/** Returns whether the stack is empty. */
bool myStackEmpty(MyStack* obj) {
    return MyQueueEmpty(obj->q1) && MyQueueEmpty(obj->q2);
}

void myStackFree(MyStack* obj) {
    MyQueueFree(obj->q1);
    MyQueueFree(obj->q2);
    free(obj);
}
```

### 232 用栈实现队列

> <https://leetcode-cn.com/problems/implement-queue-using-stacks/>

定义两个栈来回倒

```c
 typedef struct MyStack {
    int *data;
     int top;
 }MyStack;

MyStack *MyStackCreate(int size){
    MyStack *obj = (MyStack *)malloc(sizeof(MyStack));
    obj->data = (int *)malloc(sizeof(int) * size);
    obj->top = -1;
    return obj;
}

int MyStackTop(MyStack *obj) {
    return obj->data[obj->top];
}

void MyStackPush(MyStack *obj, int x) {
    obj->data[++(obj->top)] = x;
}

int MyStackPop(MyStack *obj) {
    return obj->data[obj->top--];
}

int MyStackEmpty(MyStack *obj) {
    return obj->top == -1;
}

void MyStackFree(MyStack *obj) {
    free(obj->data);
    free(obj);
}

typedef struct {
    MyStack *s1, *s2;
} MyQueue;

/** Initialize your data structure here. */

MyQueue* myQueueCreate() {
    int size = 1024;
    MyQueue *q = (MyQueue *)malloc(sizeof(MyQueue));
    q->s1 = MyStackCreate(size);
    q->s2 = MyStackCreate(size);
    return q;
}

/** Push element x to the back of queue. */
void myQueuePush(MyQueue* obj, int x) {
    MyStackPush(obj->s1, x);
}

/** Removes the element from in front of queue and returns that element. */
int myQueuePop(MyQueue* obj) {
    while (MyStackEmpty(obj->s2)) {
        while (!MyStackEmpty(obj->s1)) {
            MyStackPush(obj->s2, MyStackPop(obj->s1));
        }
    }
    return MyStackPop(obj->s2);
}

/** Get the front element. */
int myQueuePeek(MyQueue* obj) {
    if (MyStackEmpty(obj->s2)) {
        while (!MyStackEmpty(obj->s1)) {
            MyStackPush(obj->s2, MyStackPop(obj->s1));
        }
    }
    return MyStackTop(obj->s2);
}

/** Returns whether the queue is empty. */
bool myQueueEmpty(MyQueue* obj) {
    return MyStackEmpty(obj->s1) && MyStackEmpty(obj->s2);
}

void myQueueFree(MyQueue* obj) {
    MyStackFree(obj->s1);
    MyStackFree(obj->s2);
    free(obj);
}
```

### 234 回文链表

> <https://leetcode-cn.com/problems/palindrome-linked-list/>

找到链表一半的位置，将后半段翻转，并让指针q指向它，在用一个指针p指向原链表，用两个比较看是否相等，直至p == NULL

```c
//判断呢链表是否为回文链表
int length(struct ListNode *head) {
    int len = 0;
    while (head) len += 1, head = head->next;
    return len;
}

struct ListNode *getNode (struct ListNode *head, int ind) {
    while (ind--) head = head->next;
    return head;
}

struct ListNode *reverse(struct ListNode *head) {
    struct ListNode *p = head, *q, ret;
    ret.next = NULL;
    while (p) {
        q = p->next;
        p->next = ret.next;
        ret.next = p;
        p = q;
    }
    return ret.next;
}
bool isPalindrome(struct ListNode* head){
    int len = length(head);
    struct ListNode *p = head, *q = reverse(getNode(head, (len + 1) / 2));
    while (q) {
        if (p->val - q->val) return false;
        p = p->next;
        q = q->next;
    }
    return true;
}c
```

### 237 删除链表中的结点

> <https://leetcode-cn.com/problems/delete-node-in-a-linked-list/>

因为题中比你更没有给头结点指针，只给了待删除结点，所以可以直接用待删除结点的下一个的val覆盖掉待删除节点的val，然后再删除待删除节点的下一个

```c
/*删除特定结点  输入: head = [4,5,1,9], node = 5 输出: [4,1,9]*/
void deleteNode(struct ListNode* node) {
    struct ListNode *p, *q, ret;
    p = node->next;
    node->val = p->val;
    node->next = p->next;
    return node;
}
```

### 268 缺失数字

> <https://leetcode-cn.com/problems/missing-number/solution/que-shi-shu-zi-by-zed-65536/>

```c
int missingNumber(int* nums, int numsSize){
    for (int i = 0; i < numsSize; i++) {
        while (nums[i] != i && nums[i] != numsSize) {
            int a = nums[i], b = nums[nums[i]];
            nums[a] = a, nums[i] = b;
        }
    }
    for (int i = 0; i < numsSize; i++) {
        if (nums[i] - i) return i;
    }
    return numsSize;//为了预防有序状态例如[0,1],跟本不需要交换，说明缺少的就是numsSize
}

/*int missingNumber(int* nums, int numsSize){
    int a[numsSize + 1], ans;
    memset(a, 0, sizeof(a));
    for (int i = 0; i < numsSize; i++) {
        a[nums[i]] = 1;
    }
    for (int i = 0; i < numsSize + 1; i++) {
        if (a[i] == 0) {
            ans = i;;
            break;
        }
    }
    return ans;
}*/
/*求和
 * int missingNumber(int* nums, int numsSize){
    int ans = (numsSize + 1) * numsSize / 2, i;
    for(i = 0; i < numsSize; i++){
        ans -= nums[i];
    }
    return ans;
}
*/
```

### 287 寻找重复的数

> <https://leetcode-cn.com/problems/find-the-duplicate-number/>

还是运用快慢指针，将这个**题目**给的**特殊的数组当作一个链表来看**，数组的下标就是指向元素的指针，把数组的元素也看作指针。如0是指针，**指向nums[0]，而nums[0]也是指针，指向nums[nums[0]]**..所以可将其看成是一个环形数组，当快慢指针相遇时，一个不动一个指向头，接下来，两个同时走，最后两个指针相遇的时候就是重复的元素。

![287](/home/unique/Desktop/海贼/picture/287.jpg)

[1， 3， 4， 2， 2]     一一映射

0->1 1->3 2->4 3->2 4->2 

变为 1->3->2->4->2 2又到4 所以可以看成是一个有环的链表

设到入环之前的距离为x 环的长度为c 相遇位置为c

所以快指针就相当于走了x+m+c  慢指针相当于走了 x + m. 而快指针走的是慢指针的二倍， 所一c = x + m

所以一个指针不动另一个从头开始走x步就是入环的就是重复的

```c
/*8ms*/
int findDuplicate(int* nums, int numsSize) {
    int p = nums[0], q = nums[0];
    do {
        p = nums[p];
        q = nums[nums[q]];
    } while (p != q);
    p = nums[0];
    while (p != q) {
        p = nums[p];
        q = nums[q];
    }
    return p;
}

/*12ms
int findDuplicate(int* nums, int numsSize){
    int a[100000], ans;
    memset (a, 0, sizeof(a));
    for (int i = 0; i < numsSize; i++) {
        a[nums[i]] += 1;
        if (a[nums[i]] > 1) {
            ans = nums[i];
            break;
        }
       
    }
    return ans;
}*/
```

## 二叉树

### 100 相同的树

> <https://leetcode-cn.com/problems/same-tree/>

```c
bool isSameTree(struct TreeNode* p, struct TreeNode* q){
    if (p == NULL && q == NULL) return true;
    if (p == NULL || q == NULL) return false;
    if (p->val - q->val != 0) return false;
    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
}
```

### 101 对称二叉树

> <https://leetcode-cn.com/problems/symmetric-tree/>

```c
bool isSameTree (struct TreeNode *p, struct TreeNode*q) {
    if (p == NULL && q == NULL) return true;
    if (p == NULL || q == NULL) return false;
    if (p->val - q->val != 0) return false;
    return isSameTree(p->left, q->right) && isSameTree(p->right, q->left);
}

bool isSymmetric(struct TreeNode* root){
    if (root == NULL) return true;
    return isSameTree(root->left, root->right);
}
```

### 102 二叉树的层序遍历

> <https://leetcode-cn.com/problems/binary-tree-level-order-traversal/

可以想象成一个二维数组，第一维用来存每一层的遍历结果， 第二维用来存储每层的结点个数以及用来存储每个结点，先求得树的深度，在求得每层有几个结点，然后用递归的方法

```c
int getDepth(struct TreeNode *root) {//用来求树的深度
    if (root == NULL) return 0;
    int l = getDepth(root->left), r = getDepth(root->right);
    return (l > r ? l : r) + 1;
}

void getCnt (struct TreeNode *root, int k, int *cnt) {//第k层结点数
    if (root == NULL) return ;
    cnt[k] += 1;
    getCnt(root->left, k + 1, cnt);
    getCnt(root->right, k + 1, cnt);
    return ;
}

void getResult(struct TreeNode *root, int k, int *cnt, int **ret){
    if (root == NULL) return ;
    ret[k][cnt[k]++] = root->val;//将k层的元素存到相应位置
    getResult(root->left, k + 1, cnt, ret);
    getResult(root->right, k + 1, cnt, ret);
    return ;
}

int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    int depth = getDepth(root);
    int *cnt = (int *)calloc(sizeof(int), depth);
    int **ret = (int **)malloc(sizeof(int *) * depth);
    getCnt(root, 0, cnt);
    for (int i = 0; i < depth; i++) {
        ret[i] = (int *)malloc(sizeof(int) * cnt[i]);
        cnt[i] = 0;
    }
    getResult(root, 0, cnt, ret);
    *returnSize = depth;
    *returnColumnSizes = cnt;
    return ret;
}
```

### 107 二叉树的层序遍历2

> <https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/>

同上leedcode102

```c
int getDepth(struct TreeNode *root) {
    if (root == NULL) return 0;
    int d1 = getDepth(root->left);
    int d2 = getDepth(root->right);
    return fmax(d1, d2) + 1;
}

void getSize(struct TreeNode *root, int k, int *size) {
    if (root == NULL) return ;
    size[k] += 1;
    getSize(root->left, k - 1, size);
    getSize(root->right, k - 1, size);
    return ;
}

void getData(struct TreeNode *root, int **ret, int *size, int k) {
    if (root == NULL) return ;
    ret[k][size[k]++] = root->val;
    getData(root->left, ret, size, k - 1);
    getData(root->right, ret, size, k - 1);
    return ;
}

int** levelOrderBottom(struct TreeNode* root, int** columnSizes, int* returnSize) {
    if (root == NULL) return NULL;
    int n = getDepth(root);
    int **ret = (int **)malloc(sizeof(int *) * n);
    int *size = (int *)calloc(sizeof(int), n);
    getSize(root, n - 1, size);
    for (int i = 0; i < n; i++) {
        ret[i] = (int *)malloc(sizeof(int) * size[i]);
        size[i] = 0;
    }
    getData(root, ret, size, n - 1);
    *returnSize = n;
    *columnSizes = size;
    return ret;
}
```

### 104 二叉树的最大深度

> <https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/>

递归(不要忘了算上根节点)

```c
int maxDepth(struct TreeNode* root) {
    if (root == NULL) return 0;
    int d1 = maxDepth(root->left);
    int d2 = maxDepth(root->right);
    return fmax(d1, d2) + 1;
}
```

### 110 平衡二叉树

> <https://leetcode-cn.com/problems/balanced-binary-tree/

递归

```c
/*给定一个二叉树，判断它是否是高度平衡的二叉树。
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。*/
int hight(struct TreeNode *node) {
    if (node == NULL) return 0;
    int l = hight(node->left);
    int r = hight(node->right);
    return fmax(l, r) + 1;
}
bool isBalanced(struct TreeNode* root){
    if (root == NULL) return true;
    int d = abs(hight(root->left) - hight(root->right));
    return (d <= 1) && isBalanced(root->left) && isBalanced(root->right);
}
……………………………………………………………………………………………………………………………………………………………………………………………………………………
第二种方法
int Depth(struct TreeNode *root) {
    if (root == NULL) return 0;
    int l = Depth(root->left), r = Depth(root->right);
    if (l == -2 || r == -2 || abs(l - r) > 1) return -2;
    return (l > r ? l : r) + 1;
}

bool isBalanced(struct TreeNode *root) {
    return Depth(root) >= 0;
}
```

### 111 二叉树最小的深度

> <https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/>

递归

```c
int minDepth(struct TreeNode* root) {
    if (root == NULL) return 0;
    if (root->left == NULL && root->right == NULL) return 1;
    if (root->left == NULL || root->right == NULL)
        return minDepth(root->right ? root->right : root->left) + 1;
    return fmin(minDepth(root->left), minDepth(root->right)) + 1;
}
```

### 112 路径综合

> <https://leetcode-cn.com/problems/path-sum/>

dfs搜索题

直接遍历二叉树，找到和为sum的就return 

```c
/*给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。*/
bool hasPathSum(struct TreeNode* root, int sum){
    if (root == NULL) return false;
    if (root->left == NULL && root->right == NULL) return root->val == sum;
    return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);
}
```

### 226 翻转二叉树

> <https://leetcode-cn.com/problems/invert-binary-tree/>

直接交换

```c
struct TreeNode* invertTree(struct TreeNode* root){
    if (root == NULL) return NULL;
    struct TreeNode *temp = root->left;
    root->left = root->right;
    root->right = temp;
    invertTree(root->left);
    invertTree(root->right);
    return root;
}
```

### 235 二叉搜索树的最近公共祖先

> <https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

递归！！！先定下来p就是小的那个，如果p大，那就交换，判断p与q的位置关系，然后做出答案。

![leedcode235](/home/unique/Desktop/海贼/picture/leedcode235.png)

```c
/*给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”。*/
struct TreeNode *__lowestCommonAncestor(struct TreeNode *root, struct TreeNode *p, struct TreeNode *q) {
    if (root->val == p->val) return p;//p == 2 q == 4
    if (root->val == q->val) return q;//p == 0 q == 2
    if (root->val > p->val && root->val < q->val) return root;// p == 0 q == 4 
    if (p->val > root->val) return __lowestCommonAncestor(root->right, p, q);//p == 4 q == 5
    return __lowestCommonAncestor(root->left, p, q);
    }

struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    if (root == NULL) return NULL;
    if (p->val == q->val) return p;
    if (p->val > q->val) {//p永远是小的那个
        struct TreeNode *temp = p;
        p = q;
        q = temp;
    }
    return __lowestCommonAncestor(root, p, q);
    
}
/*struct TreeNode *lowestCommonAncestor(struct TreeNode *root, struct TreeNode *p, struct TreeNode *q) {
    if (p->val < root->val && q->val < root->val) return lowestCommonAncestor(root->left, p, q);
    else if (p->val > root->val && q->val > root->val) return lowestCommonAncestor(root->right, p, q);
    return root;
}*/
```

### 257 二叉树的所有路径

> <https://leetcode-cn.com/problems/binary-tree-paths/>

```c
/*给定一个二叉树，返回所有从根节点到叶子节点的路径。*/
int getpathCnt(struct TreeNode *root) {
    if (root == NULL) return 0;
    if (root->left == NULL && root->right == NULL) return 1;
    return getpathCnt(root->left) + getpathCnt(root->right);
}

int getREsult(struct TreeNode *root, int len, int k, char **ret, char *buff) {
    if (root == NULL) return 0;
    len += sprintf(buff + len, "%d", root->val);
    buff[len] = 0;
    if (root->left == NULL && root->right == NULL) {
        ret[k] = strdup(buff);
        return 1;
    } 
    len += sprintf(buff + len, "->");
    int cnt = getREsult(root->left, len, k, ret, buff);
    cnt += getREsult(root->right,len, k + cnt, ret, buff);
    return cnt;
}

char ** binaryTreePaths(struct TreeNode* root, int* returnSize){
    int pathCnt = getpathCnt(root);
    char **ret = (char **) malloc(sizeof(char *) * pathCnt);
    int max_len = 1024;
    char *buff = (char *) malloc(sizeof(char)* max_len);
    getREsult(root, 0, 0, ret, buff);
    *returnSize = pathCnt;
    return ret;
}
```



#### 268

## 堆

#### 136 只出现一次的数字

> <https://leetcode-cn.com/problems/single-number/submissions/>

```c
找到数组中唯一一个只出现一次的数
用异或相同为0，不同为1
int singleNumber(int* nums, int numsSize) {
    int res = 0;
    for(int i = 0; i < numsSize; i++)
        res = nums[i]^res;
    return res;
}
```

#### 

## 计蒜客

### 哈西表

> <https://www.jisuanke.com/course/792/41195>

```
输入N个名字，看看前面出现过没有，出现过输出“Yes” 否则输出“No”
用哈希表做
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

typedef struct HashTable {
    char **data;
    int size;
}HashTable;

void init(HashTable *h, int n) {
    h->data = (char **)malloc(sizeof(char *) * n);
    memset(h->data, 0, sizeof(char *));
    h->size = n;
}

int hash(HashTable *h, char *str) {
    unsigned int code = 0;
    for (int i = 0; str[i]; i++) {
        code = (code << 3) ^ str[i];
    }
    return (int)(code % h->size);
}

int search(HashTable *h, char *str, int *pos) {
    int times = 0;
    *pos = hash(h, str);
    while (h->data[*pos] && strcmp(h->data[*pos], str)) {//如果pos上有数并且不为value
        ++times;
        (*pos) += times;
        *pos %= h->size;
    }
    if (h->data[*pos]) {//pos上有数，为value
        return 1;
    } else {
        return 0;
    }
}

int insert(HashTable * h, char *str) {//插入函数
    int pos;
    if (search(h, str, &pos)) return 0;
    h->data[pos] = strdup(str);
    return 1;
}

void clear(HashTable *h) {
    free(h->data);
    free(h);
}

void str_to_lower(char *str){//将字符串转化为小写
    for (int i = 0; str[i]; i++) {
        str[i] = tolower(str[i]);
    }
    return ;
}

int main() {
    HashTable *h = (HashTable *)malloc(sizeof(HashTable));
    int n;
    scanf("%d", &n);
    init(h, n * 4);
    char str[105];
    while (n--) {
        scanf("%s", str);
        str_to_lower(str);
        printf("%s\n", insert(h, str) ? "No" : "Yes");//insert为真说明插入成功则说明该名字之前没有出现过
    }
    clear(h);
    return 0;
}

```

### 通话记录

```
已知10条通话记录0未接1已接2已播，统计个数，没有的用0占位
样例输入复制
2 18270477699
1 10149800116
0 19906559817
1 16209018105
1 16804212234
2 19289130583
1 17982711123
0 10897630486
1 11860787674
0 15192777554
样例输出复制
19906559817 10149800116 18270477699
10897630486 16209018105 19289130583
15192777554 16804212234 0
0 17982711123 0
0 11860787674 0
0 0 0
0 0 0
0 0 0
0 0 0
0 0 0
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
char phone_num[3][10][12] = {0};
int ind[3];
int main() {
    ind[0] = ind[1] = ind[2] = 0;
    int t;
    for (int i = 0; i < 10; i++) {
        scanf("%d", &t);
        scanf("%s", phone_num[t][ind[t]++]);
        //ind[0]为未接号码个数 ind[1]为接通的号码个数 ind[2]为打出的号码个数
    }
    for (int i = 0; i < 10; i++) {
        printf("%s", ind[0] ? (ind[0]--, phone_num[0][i]) : "0");
        for (int j = 1; j < 3; j++) {
            printf(" %s", ind[j] ? (ind[j]--, phone_num[j][i]) : "0");
        }
        printf("\n");
    }
    return 0;
}
```

## 位运算

```c
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <cstring>
#include <cmath>
#include <ctime>
#include <iomanip>
using namespace std;
long long a, b, p;

long long func(int a, int b, int p) {
    long long ans = 1, temp = a;
    while (b) {
        if (b & 1) ans = ans * temp % p;
        //如果b为奇数，就相当于先算一次a的一次幂
        temp = temp * temp % p;//然后在算偶次幂
        b >>= 1;//b右移到最后一定等于1
    }
    return ans;
}

int main() {
    cin >> a >> b >> p;
    long long ans = func(a, b, p);
    cout << ans % p << endl;
    return 0;
}
```

