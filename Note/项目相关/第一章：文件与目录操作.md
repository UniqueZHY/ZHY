# 第一章：文件与目录操作

## 第一节：相关命令的实现

### 1.命令行参数解析

* 主函数中的`argc` `argv` 的含义
  * `argc`是主程序参数的个数，也就是传入参数的个数，这个值一开始不确定，是看自己输入了多少参数而确定的；
  * `argv`数组存放的是传入的参数，从0开始，第一个值存放的是可执行文件的文件名!然后依次存放后面传入的参数



#### `getopt`函数

* `getopt`函数：命令行解析函数

  * 头文件：<`unistd.h`>

  * 原型：

    ```c
    int getopt(int  argc, char *const argv[], const char *optstring);
    ```

  * `argc` `argv` :由`main`函数的参数直接传递而来

  * `optstring`一个包含准确选项字符的字符串

  * 返回值:返回下一个选项

* `getopt`设置的一些全局变量

  * `char *optarg`: --指向当前参数（如果有）的指针
  * `int optind`:--再次调用`getopt()`时的下一个`argv`指针的索引
  * `int optopt`: --这个变量非零时，向`stderr`打印错误。默认为1

* 参数`optstring`详解

  * `getopt()`函数的第三个参数`optstring`是一个有所有合法的“可选字符”所组成的字符串。

    * 1.单个字符，表示选项
    * 2.单个字符后接一个冒号":"，表示该选项后必须跟一个参数值。参数紧跟在选项后或者以空格隔开。该参数的指针符赋给`optarg`
    * 3.单个字符后面接两个冒号"::"表示该选项后可以带参数也可以不带。但参数必须紧跟在选项后不能以空格隔开。该参数的指针赋给`optarg`

    例子 ："`xy:z::`"表示x选项没有选项参数，y选项必须有选项参数，中间可有空格可没有，z参数可有参数选项，也可以没有参数选项，但是如果有选项参数的话必须紧跟在选项之后不能有空格

* `getopt`函数的通用用法

  ```c
  while ((c == getopt (argc, argv, "xy:z::"))    != -1)  {
  	switch(c) {
  		case 'x' :  ...  ...
  		case 'y' :  ...  ...
  		case 'z' :  ...  ...
  		...  ...
  	}
  }
  ```



### 2.ls命令的实现

```c
/*************************************************************************
        > File Name: ls.c
        > Author: zhangfengbo
        > Mail:1819067326@qq.com 
        > Created Time: Mon 23 Mar 2020 07:53:19 PM CST
 ************************************************************************/

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <math.h>
#include <dirent.h>
#include <sys/types.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <grp.h>
#include <pwd.h>
#include <time.h>

#define FILEMAX 1024
#define NAMEMAX 256

int flag_a = 0;
int flag_l = 0;
int dir_num = 0;
int fg_c, bg_c;

void size_window(char filename[][NAMEMAX], int cnt, int* row, int* col){
    struct winsize size;
    int len[cnt], max = 0, total = 0;
    memset(len, 0, sizeof(int) * cnt);
    if (isatty(STDOUT_FILENO) == 0) {
        exit(1);
    }

    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &size) < 0) {
        perror("ioctl");
        exit(1);
    }

    for (int i= 0; i < cnt; i++){
        len[i] = strlen(filename[i]);
        if (max < len[i]) max = len[i];
        total += len[i] + 1;
    }
    if (max + 1 >= size.ws_col) {
        *row = cnt;
        *col = 1;
        return ;
    }
    if (total <= size.ws_col) {
        *row = 1;
        *col = cnt;
        return ;
    }

    int try_begin = 0;
    for (int i = 0, tmp = 0; i < cnt; i++) {
        tmp += (len[i] + 1);
        if (tmp >= size.ws_col) {
            try_begin = i;
            break;
        }
    }

    for (int i = try_begin; ;i--) {
        int *wide = (int *)malloc(sizeof(int) * i);
        memset(wide, 0, sizeof(int) * i);
        *row = (int)ceil(cnt / i);
        int try_sum = 0;
        for (int x = 0; x < i; x++) {
            for (int y = x * *row; y < (x + 1) * *row && y < cnt; y++) {
                if (wide[x] < len[y]) wide[x] = len[y];
            }
            try_sum += (wide[x] + 1);
        }

        if (try_sum > size.ws_col) continue;
        if (try_sum <= size.ws_col) {
            *col = i;
            break;
        }
    }
}

void update_color(mode_t mode) {
    bg_c = 0;
    fg_c = 37;
    if (mode & (S_IXUSR | S_IXGRP | S_IXOTH)) fg_c = 32;
    if (mode & 0111) fg_c = 32;
    switch (mode & S_IFMT) {
        case S_IFDIR:
            fg_c = 34;
            break;
        case S_IFLNK:
            fg_c = 36;
            break;
    }
}

void show_files(char filename[][NAMEMAX], int cnt, int row, int col) {
    int wide_file[cnt];
    struct stat tmp_st;
    memset(wide_file, 0, sizeof(int) * cnt);
    for(int i = 0; i < col; i++) {
        for (int j = (i * row); j < (i + 1) * row && j < cnt; j++) {
            if (wide_file[i] < strlen(filename[j])) wide_file[i] = strlen(filename[j]) ;

        }
    }

    for (int i = 0; i < row; i++) {
        for (int j = i; j < i + (row * col) && j < cnt; j = j + row) {
            int tmp = j / row;
            stat(filename[j], &tmp_st);
            update_color(tmp_st.st_mode);
            printf("\033[%d;%dm%-*s\033[0m", bg_c, fg_c, wide_file[tmp] + 1, filename[j]);
        }
            printf("\n");
        }
}


void mode_to_str(mode_t mode, char *str) {
    if (S_ISREG(mode)) str[0] = '-';
    if (S_ISDIR(mode)) str[0] = 'd';
    if (S_ISCHR(mode)) str[0] = 'c';
    if (S_ISBLK(mode)) str[0] = 'b';
    if (S_ISSOCK(mode)) str[0] = 's';
    if (S_ISLNK(mode)) str[0] = 'l';
    if (S_ISFIFO(mode)) str[0] = 'p';

    if (mode & S_IRUSR) str[1] = 'r';
    if (mode & S_IWUSR) str[2] = 'w';
    if (mode & S_IXUSR) str[3] = 'x';
    if (mode & S_IRGRP) str[4] = 'r';
    if (mode & S_IWGRP) str[5] = 'w';
    if (mode & S_IXGRP) str[6] = 'x';

    if (mode & S_IROTH) str[7] = 'r';
    if (mode & S_IWOTH) str[8] = 'w';
    if (mode & S_IXOTH) str[9] = 'x';

    if ((mode & S_IXUSR) && (mode & S_ISUID)) str[3] = 's';
    update_color(mode);
}

char *uid_to_name(uid_t uid){
    struct passwd *pw_ptr;
    static char tmpstr[10] = {0};
    if ((pw_ptr = getpwuid(uid)) == NULL) {
        sprintf(tmpstr, "%d", uid);
        return tmpstr;
    } else {
        return pw_ptr->pw_name;
    }
}

char *gid_to_name(gid_t gid) {
    struct group *gr_ptr;
    static char tmpstr[10] = {0};
    if ((gr_ptr = getgrgid(gid)) == NULL) {
        sprintf(tmpstr, "%d", gid);
        return tmpstr;
    } else {
        return gr_ptr->gr_name;
    }
}

void show_info(char *filename, struct stat *info) {
    char modestr[11] = "----------";
    mode_to_str(info->st_mode, modestr);
    printf("%s ", modestr);
    printf("%4ld ", info->st_nlink);
    printf("%8s ", uid_to_name(info->st_uid));
    printf("%8s ", gid_to_name(info->st_gid));
    printf("%8ld ", info->st_size);
    printf("%.15s ",  4 + ctime(&info->st_mtime));
    printf("\033[%d;%dm%s\033[0m ", bg_c, fg_c, filename);
    if (modestr[0] == 'l') {
        int cnt;
        char buf[NAMEMAX] = {0};
        if (cnt == readlink(filename, buf, 256) < 0) {
            perror("readlink");
        }
        printf("-> \033[%d;%dm%s\033[0m", bg_c, fg_c, buf);
    }
    printf("\n");
}

void do_stat(char *filename) {
    struct stat st;
    if (stat(filename, &st) < 0) {
        perror(filename);
    } else {
        show_info(filename, &st);
    }
}

int cmp_name(const void* _a, const void* _b) {
    char *a = (char *)_a;
    char *b = (char *)_b;
    return strcmp(a, b);
}

void do_ls(char *dirname) {
    DIR *dirp = NULL;
    struct dirent *direntp;
    char names[FILEMAX][NAMEMAX] = {0};
    if ((dirp = opendir(dirname)) == NULL) {
        if (access(dirname, R_OK) == 0) {
            if (flag_l == 0) {
                dir_num--;
                struct stat tmp_st;
                stat(dirname, &tmp_st);
                update_color(tmp_st.st_mode);
                printf("\033[%d;%dm%s\033[0m\n",bg_c, fg_c, dirname);
                return;
            } else {
                dir_num--;
                do_stat(dirname);
                return;
            }
        } else {
            perror(dirname);
            return ;
        }
    } else {
        if (dir_num)
            printf("%s:\n", dirname);
        chdir(dirname);
        int cnt = 0;
        while((direntp = readdir(dirp)) != NULL) {
            if (direntp->d_name[0] == '.' && (flag_a == 0)) continue;
            strcpy(names[cnt++], direntp->d_name);
        }
        qsort(names, cnt, NAMEMAX, cmp_name);

        if (flag_l == 1) {
            for (int i = 0; i < cnt; i++) {
                do_stat(names[i]);
            }
        } else {
            int row, col;
            size_window(names, cnt, &row, &col);
            show_files(names, cnt, row, col);
        }

    }
}


int main(int argc, char **argv) {
    int opt;
    while((opt = getopt(argc, argv, "al")) != -1) {
        switch (opt) {
            case 'a':
            flag_a = 1;
                break;
            case 'l':
                flag_l = 1;
                break;
            default:
                fprintf(stderr, "Usage: %s [-al] [filename]\n", argv[0]);
                exit(1);
        }
    }
    argc -= (optind - 1);
    argv += (optind - 1);

    if (argc == 1) {
        dir_num = 0;
        do_ls(".");
    } else {
        dir_num = argc - 2;
        while(--argc) {
            do_ls(*(++argv));
        }
    }
    return 0;
}
```



### 3.more命令的实现

#### fopen , fget, fgetc, fputc

```c
/*************************************************************************
        > File Name: more.c
        > Author: zhangfengbo
        > Mail:1819067326@qq.com 
        > Created Time: Sun 22 Mar 2020 10:51:59 PM CST
 ************************************************************************/
#include <stdio.h>
#include <stdlib.h>

#define PAGELINE 15//一页有多少行
#define LENLINE 512//一行有多少字

void do_more(FILE *fp);


int main(int argc, char **argv) {
    FILE *fp;
    if (argc == 1)
        do_more(stdin);
    else
        while (--argc) {
            if ((fp = fopen(*++argv, "r")) != NULL){
                do_more(fp);
            }
        }
    return 0;
}

void do_more(FILE *fp) {
    char line[LENLINE] = {0};
    FILE *cmd = fopen("/dev/tty", "r");
    int num_line = 0, reply, get_cmd(FILE*);
    while (fgets(line, LENLINE, fp)) {
        if (num_line == PAGELINE) {
            reply = get_cmd(cmd);
            if (reply == 0) break;
            num_line -= reply;
        }
        if (fputs(line, stdout) == EOF) {
            perror("fputs");
            exit(1);
        }
        num_line++;
    }

}

int get_cmd(FILE *fp) {
    printf("more:");
    int c;
    while ((c = fgetc(fp)) != EOF){
        if (c == 'q') return 0;
        if (c == ' ') return PAGELINE;
        if (c == '\n') return 1;
    }
    return -1;
}
```



### 4.`cp`命令的实现

#### open, create, read, write

```c
/*************************************************************************
        > File Name: cp.c
        > Author: zhangfengbo
        > Mail:1819067326@qq.com 
        > Created Time: Mon 23 Mar 2020 09:57:31 PM CST
 ************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>

#define BUFSIZE 512


int main(int argc, char **argv) {
    int fd_in, fd_out;
    ssize_t nread;
    char buf[BUFSIZE + 5] = {0};

    if (argc != 3) {
        printf("Usage: %s sourcefile destfile\n", argv[0]);
        exit(1);
    }

    if ((fd_in = open(argv[1], O_RDONLY)) == -1) {
        perror(argv[1]);
        exit(1);
    }

    if ((fd_out = creat(argv[2], 0644)) == -1) {
        perror(argv[2]);
        exit(1);
    }

    while ((nread = read(fd_in, buf, BUFSIZE)) > 0) {
        printf("nread = %ld\n", nread);
        int nwrite;
        if ((nwrite = write(fd_out, buf, strlen(buf))) != nread) {
            perror("write");
        }
        memset(buf, 0, BUFSIZE + 5);
    }

    close(fd_in);
    close(fd_out);
    return 0;
}
```

## 第二节：阻塞IO与非阻塞IO

### 1.三态模型

* ready  就绪
* block  阻塞
* running  进行

![img](https://images2015.cnblogs.com/blog/1107494/201704/1107494-20170420135629571-462537817.jpg)

### 2.阻塞Io与非阻塞IO

```c
//head.h
/*************************************************************************
        > File Name: ../common/head.h
        > Author: suyelu
        > Mail: suyelu@haizeix.com
        > Created Time: 六  3/28 14:23:19 2020
 ************************************************************************/

#ifndef HEAD_H
#define HEAD_H
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <string.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <stdbool.h>
#include <pwd.h>
#include <sys/wait.h>
#include <signal.h>
#endif

//用到ioctl函数
//fcntl函数
#include "head.h"

void make_nonblock_ioctl(int fd){
    unsigned long ul = 1;
    ioctl(fd, FIONBIO, &ul);
}


void make_block_ioctl(int fd) {
    unsigned long ul = 0;
    ioctl(fd, FIONBIO, &ul);
}


void make_nonblock(int fd) {
    int flag;
    if ((flag = fcntl(fd, F_GETFL)) < 0) {
        return;
    }
    flag |= O_NONBLOCK;
    fcntl(fd, F_SETFL, flag);
}

void make_block(int fd) {
    int flag;
    if ((flag = fcntl(fd, F_GETFL)) < 0) {
        return ;
    }
    flag &= ~O_NONBLOCK;
    fcntl(fd, F_SETFL, flag);
}

```

## 第三节：缓冲IO

### 1.缓冲IO的介绍

#### 缓冲IO的三种机制

* 行缓冲
* 块缓冲 (全缓冲) :block buffered
* 无缓冲

缓冲技术大致分为三种：单缓冲、双缓冲、缓冲池。下面我来简单介绍一下计算机中的缓冲技术。操作系统为什么采用缓冲技术？或者说缓冲技术有什么用？下面我来简单给大家介绍一下。

 一、导图分析

![img](https://img-blog.csdn.net/20150412142115798?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhvdWt1bjEwMDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

 二、图解

 单缓冲：操作系统在主存储器中只设置一个缓冲区。

 双缓冲：操作系统在主存储器中设置两个缓冲区。

 缓冲池：操作系统在主存储器中设置一组缓冲区。

 单缓冲与双缓冲的区别：当CPU在读双缓冲区中的1号缓冲区的信息时，另外的信息可以读入2号缓冲区当中去。而单缓冲只有在CPU读完缓冲区的的信息，缓冲区才可以读取另一块信息。

 缓冲技术的作用：1、实现记录的成组与分解操作，协调了记录的逻辑记录的大小与物理块大小不一致问题。（因为当逻辑文件转换成物理文件时是通过主存储器来实现的，块是主存储器与存储设备进行信息交换的物理单位）2、缓解处理器与外围设备之间速度不匹配的矛盾，提高了文件信息的传送速度。

 下面我用一张图来简单描述一下处理器（CPU）是怎样在辅助存储介质中读取信息并做处理的。

![img](https://img-blog.csdn.net/20150412143155805?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhvdWt1bjEwMDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

 处理器（CPU）的组成：控制单元、逻辑单元、存储单元。

 当处理器读取一个文件时，处理器先发布一条命令找到该文件，然后将文件读入主存储器（电脑的内存条）当中的缓冲区中，然后在读入高速缓冲存储器中然（适用于页式虚拟存储管理），再读入寄存器中，处理器当中的控制单元和逻辑单元再进行相关的操作，最后逻辑单元将处理的结果存放到处理器的存储单元当中。

 大家应该知道、处理器的运行速度是远远地大于处理器在外围设备读取信息的速度的，采用缓冲技术就是为了解决这一个矛盾的。

 主存储器中开辟的缓冲区与高速缓冲存储器相当于处理器与辅助存储器的一个桥梁，只不过在主存储器中的缓冲区读取的速度要小于高速缓冲，这就好比主存储器中的缓冲区是一条普通的公路，而高速缓冲存储器是一条高速公路一样。

 三、小结

 由于在计算机系统中大量的文件信息是存储在磁盘上的，系统在运行期间要不断的执行读或写操作，采用了缓冲技术能减少处理器对磁盘的访问次数，从而提高系统的工作效率。

### 2.内核与缓冲IO

**1.C标准库的I/O缓冲区** 

​    UNIX的传统 是Everything is a file,键盘、显示器、串口、磁盘等设备在/dev 目录下都有一个特殊的设备文件与之对应,这些设备文件也可以像普通文件(保存在磁盘上的文件)一样打开、读、写和关闭,使用的函数接口是相同的。用户程序调用C标准I/O库函数读写普通文件或设备,而这些库函数要通过系统调用把读写请求传给内核 ,最终由内核驱动磁盘或设备完成I/O操作。C标准库为每个打开的文件分配一个I/O缓冲区以加速读写操作,通过文件的FILE 结构体可以找到这个缓冲区,用户调用读写函数大多数时候都在I/O缓冲区中读写,只有少数时候需要把读写请求传给内核。以fgetc / fputc 为例,当用户程序第一次调用fgetc 读一个字节时,fgetc 函数可能通过系统调用 进入内核读1K字节到I/O缓冲区中,然后返回I/O缓冲区中的第一个字节给用户,把读写位置指 向I/O缓冲区中的第二个字符,以后用户再调fgetc ,就直接从I/O缓冲区中读取,而不需要进内核 了,当用户把这1K字节都读完之后,再次调用fgetc 时,fgetc 函数会再次进入内核读1K字节 到I/O缓冲区中。在这个场景中用户程序、C标准库和内核之间的关系就像在“Memory Hierarchy”中 CPU、Cache和内存之间的关系一样,C标准库之所以会从内核预读一些数据放 在I/O缓冲区中,是希望用户程序随后要用到这些数据,C标准库的I/O缓冲区也在用户空间,直接 从用户空间读取数据比进内核读数据要快得多。另一方面,用户程序调用fputc 通常只是写到I/O缓 冲区中,这样fputc 函数可以很快地返回,如果I/O缓冲区写满了,fputc 就通过系统调用把I/O缓冲 区中的数据传给内核,内核最终把数据写回磁盘或设备。有时候用户程序希望把I/O缓冲区中的数据立刻 传给内核,让内核写回设备或磁盘,这称为Flush操作,对应的库函数是fflush,fclose函数在关闭文件 之前也会做Flush操作。



我们知道main 函数被启动代码这样调用:exit(main(argc, argv));。

​    main 函数return时启动代码会 调用exit ,exit 函数首先关闭所有尚未关闭的FILE *指针(关闭之前要做Flush操作),然后通 过_exit 系统调用进入内核退出当前进程.



C标准库的I/O缓冲区有三种类型:全缓冲、行缓冲和无缓冲。当用户程序***\*调用库函数做写操作(读操作时I/O缓冲区是如何变化的？)\****时, 不同类型的缓冲区具有不同特性。 

  全缓冲 

如果缓冲区写满了就写回内核。对于驻留在磁盘上的文件通常是由标准I/O库实施全缓冲的。在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用malloc获得需使用的缓冲区。

  行缓冲 

如果用户程序写的数据中有换行符就把这一行写回内核,***\*或者如果缓冲区写满了\****就写回内核。标准输入和标准输出对应终端设备时通常是行缓冲的。 

   无缓冲 

用户程序每次调库函数做写操作都要通过系统调用写回内核。标准错误输出通常是无缓冲的,这样用户程序产生的错误信息可以尽快输出到设备。

除了写缓冲区满、写入换行符之外,***\*行缓冲还有两种情况会自动做Flush操作\****。如果
用户程序调用库函数从无缓冲的文件中读取 
或者从行缓冲的文件中读取,并且这次读操作会引发系统调用从内核读取数据

如果用户程序不想完全依赖于自动的Flush操作,可以调fflush函数手动做Flush操作。 
\#include <stdio.h> 
int fflush(FILE *stream); 
返回值:成功返回0,出错返回EOF并设置errno
fflush函数用于确保数据写回了内核,以免进程异常终止时丢失数据,如fflush(stdout); 作为一个特例,调 用fflush(NULL)可以对所有打开文件的I/O缓冲区做Flush操作。



***\*2. 用户程序的缓冲区\****
    在函数栈上分配的如char buf[10];之类的缓冲区, strcpy(buf, str);  str 所指向的字符串有可能超过10个字符而导致写越界,这种写越界可能当时不出错, 而在函数返回时出现段错误,原因是写越界覆盖了保存在栈帧上的返回地址, 函数返回时跳转到非法地址,因而出错。像buf 这种由调用者分配并传给函数读或写的一段内存通 常称为缓冲区(Buffer),缓冲区写越界的错误称为缓冲区溢出(Buffer Overflow)。如果只是出 现段错误那还不算严重,更严重的是缓冲区溢出Bug经常被恶意用户利用,使函数返回时跳转到一 个事先设好的地址,执行事先设好的指令,如果设计得巧妙甚至可以启动一个Shell,然后随心所欲 执行任何命令,可想而知,如果一个用root 权限执行的程序存在这样的Bug,被攻陷了,后果将很 严重。

​    下图以fgets / fputs 示意了I/O缓冲区的作用,使用fgets / fputs 函数时在用户程序中也需要分配缓冲 区(图中的buf1 和buf2 ),注意区分用户程序的缓冲区和C标准库的I/O缓冲区。

***\*3.内核缓冲区\****
(1)终端缓冲

  终端设备有输入和输出队列缓冲区,如下图所示

![img](https://img-my.csdn.net/uploads/201304/16/1366042079_2666.png)

​     以输入队列为例,从键盘输入的字符经线路规程过滤后进入输入队列,用户程序以先进先出的顺序 从队列中读取字符,一般情况下,当输入队列满的时候再输入字符会丢失,同时系统会响铃警报。 终端可以配置成回显(Echo)模式,在这种模式下,输入队列中的每个字符既送给用户程序也送给 输出队列,因此我们在命令行键入字符时,该字符不仅可以被程序读取,我们也可以同时在屏幕上 看到该字符的回显。
​    注意上述情况是用户进程(shell进程也是)调用read/write等unbuffer I/O函数的情况,当调用printf/scanf(底层实现也是read/write)等C标准I/O库函数时,当用户程序调用scanf读取键盘输入时,开始输入的字符都存到C标准库的I/O缓冲区,***\*直到我们遇到换行符(标准输入和标准输出都是行缓冲的)\****时,系统调用read将缓冲区的内容读到内核的终端输入队列;当调用printf打印一个字符串时,如果语句中带换行符,则立刻将放在I/O缓冲区的字符串调用write写到内核的输出队列,打印到屏幕上,如果printf语句没带换行符,则由上面的讨论可知,程序退出时会做fflush操作.


(2)虽然write 系统调用位于C标准库I/O缓冲区的底层,被称为Unbuffered I/O函数,但在write 的底层也可以分配一个内核I/O缓冲区,所以write 也不一定是直接写到文件的,也 可能写到内核I/O缓冲区中,可以使用fsync函数同步至磁盘文件，至于究竟写到了文件中还是内核缓冲区中对于进程来说是没有差别 的,如果进程A和进程B打开同一文件,进程A写到内核I/O缓冲区中的数据从进程B也能读到,***\*因为内核空间是进程共享的\****, 而c标准库的I/O缓冲区则不具有这一特性,***\*因为进程的用户空间是完全独立的\****.



(3)为了减少读盘次数,内核缓存了目录的树状结构,称为dentry(directory entry(目录下项) cache



(4)FIFO和UNIX Domain Socket这两种IPC机制都是利用文件系统中的特殊文件来标识的。FIFO文件在磁盘上没有数据块,仅用来标识内核中的一条通道,各进程可以打开这个文件进行read / write ,实际上是在读写内核通道(根本原因在于这个file 结构体所指向的read 、write 函数指针和常规文件不一样),这样就实现了进程间通信。UNIX Domain Socket和FIFO的原理类似,也需 要一个特殊的socket文件来标识内核中的通道,文件类型s表示socket,这些文件在磁盘上也没有数据块。UNIX Domain Socket是目前最广泛使用 的IPC机制.如下图:

## 第四节：IO多路复用与select

* 有些情况是IO多路转接

> 多进程 ：	1.进程数量受限
>
> ​					2.代价太高
>
> ​					3.受限于CPU
>
> ​					4.内存隔离
>
> ​					5.进程间通信代价高
>
> 多线程：	1.受限于CPU（影响响应能力）
>
> ​					2.阻塞（影响响应能力）
>
> ​					3.非阻塞（影响循环）

### 1.`select`的介绍（看man手册）

#### 1.1 select函数

**select的作用：**

> 轮询的方式，从多个文件描述符中获取状态变化后的情况。

**头文件**

```
#include <sys/time.h>   //for struct timeval
#include <unistd.h>     //for select
```

**函数原型**

```
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

**参数解释**

> - **`nfds:`** 要检测的文件描述符的范围，为文件最大描述符+1
> - **``readfds:``** 包含所有可能因状态变成**可读**而触发select函数返回的文件描述符
> - **``writefds:``** 包含所有可能因状态变成**可写**而触发select函数返回的文件描述符
> - **``exceptfds:``** 包含所有可能因状态**发生异常**而触发select函数返回的文件描述符

```
void FD_CLR(int fd, fd_set *set);       //将fd在set中去除
void FD_SET(int fd, fd_set *set);       //将fd添加到set中
int  FD_ISSET(int fd, fd_set *set);     //检查set中fd是否有状态变化
void FD_ZERO(fd_set *set);              //清空整个set
```

> - **timeout:**

```
struct timeval {
     long    tv_sec;         /* seconds */
     long    tv_usec;        /* microseconds */
};
```

**返回值**
当超时或其中一个/多个文件描述符发生变化时，此函数将返回，返回值：

> - -1: 函数执行出错
>
> - 0: 超时，并将时间结构体清空为0
>
> - > 0: 状态变化的文件描述符的个数

**基本实例**

```c
fd_set rdfds;   
struct timeval tv;
int rtn = 0;

FD_ZERO(&rdfds);     //清空fd_set
FD_SET(socket, &rdfds);  //将要检测的socket描述符加入到fd_set集合中

tv.tv_sec = 2;
tv.tv_usec = 1000;      //设置超时时间为2s+1ms

rtn = select(socket+1, &rdfds, NULL, NULL, &tv);

if(rtn < 0)
    perror("select");
else if(0 == rtn)
    printf("timeout\n");
else
{
    printf("rtn = %d\n", rtn);      //查看有多少个文件描述符发生了变化
    
    if(FD_ISSET(socket, &rdfds))    //判断下这个socket是否状态真的变成了可读
    {
        recv(...);
    }
}
```

#### 1.2 select做时间函数

```c
void time_delay(int seconds)
{ 
    struct timeval tv;
    int err;
    
    tv.tv_sec = seconds;     //超时时间
    tv.tv_usec = 0;
    
    do
    {
       err = select(0,NULL,NULL,NULL,&tv);  //将nfds设置为0即为超时函数
    }while(err<0 && errno==EINTR);          //
}
```



### 2.`select`的一个小例子

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
int main() {
           fd_set rfds;
           struct timeval tv;
           int retval;

           /* Watch stdin (fd 0) to see when it has input. */

           FD_ZERO(&rfds);
           FD_SET(0, &rfds);

           /* Wait up to five seconds. */

           tv.tv_sec = 5;
           tv.tv_usec = 0;

           retval = select(1, &rfds, NULL, NULL, &tv);
           /* Don't rely on the value of tv now! */

           if (retval == -1)
               perror("select()");
           else if (retval)
               printf("Data is available now.\n");
               /* FD_ISSET(0, &rfds) will be true. */
           else
               printf("No data within five seconds.\n");

           exit(EXIT_SUCCESS);
       }
```

###    3. 使用select实现socket_connect_timeout函数

```c
/*************************************************************************
        > File Name: tcp_client.h
        > Author: 
        > Mail: 
        > Created Time: 六  3/28 14:34:41 2020
 ************************************************************************/

#ifndef _TCP_CLIENT_H
#define _TCP_CLIENT_H
int socket_connect(char *host, int port);
int socket_connect_timeout(char *host, int port, long timeout);
#endif
```

```c
/*************************************************************************
        > File Name: tcp_client.c
        > Author: 
        > Mail: 
        > Created Time: 日  3/22 20:21:53 2020
 ************************************************************************/

#include  "head.h"
#include "common.h"

int socket_connect(char *host, int port) {
    int sockfd;
    struct sockaddr_in server;
    server.sin_family = AF_INET;
    server.sin_port = htons(port);
    server.sin_addr.s_addr = inet_addr(host);

    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket");
        return -1;
    }
    printf("Socket create.\n");
    if (connect(sockfd, (struct sockaddr *)&server, sizeof(server)) < 0) {
        perror("connect");
        return -1;
    }
    return sockfd;
}

int socket_connect_timeout(char *host, int port, long timeout) {
    int sockfd;
    struct sockaddr_in server;
    server.sin_family = AF_INET;
    server.sin_port = htons(port);
    server.sin_addr.s_addr = inet_addr(host);

    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket");
        return -1;
    }
    make_nonblock(sockfd);

    struct timeval tv;
    tv.tv_sec = 0;
    tv.tv_usec = timeout;

    fd_set wfds;
    FD_ZERO(&wfds);
    FD_SET(sockfd, &wfds);

    if (connect(sockfd, (struct sockaddr *)&server, sizeof(server)) < 0) {
        int retval, error = -1;
        int len = sizeof(int);
        retval = select(sockfd + 1, NULL, &wfds, NULL, &tv);
        if (retval < 0) {
            close(sockfd);
            return -1;
        } else if (retval) {
            if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &error, (socklen_t *)&len) < 0) {
                close(sockfd);
                return -1;
            }
            if (error) {
                close(sockfd);
                return -1;
            }
        } else {
            printf("Connect Time Out!\n");
            close(sockfd);
            return -1;
        }
    }
    make_block(sockfd);
    return sockfd;
}
```

### 4.使用select实现echo服务器

```c
/*************************************************************************
        > File Name: server.c
        > Author: 
        > Mail: 
        > Created Time: Tue 07 Apr 2020 06:40:01 PM CST
 ************************************************************************/

#include "../common/color.h"
#include "../common/common.h"
#include "../common/tcp_server.h"
#include "../common/head.h"

#define CLIENTSIZE 50
#define BUFSIZE 4096


struct  Buffer{
    int fd;
    char buff[BUFSIZE];
    int flag;
    int sendindex;
    int recvindex;
};

struct Buffer *AllocBuffer() {
    struct Buffer *buffer =(struct Buffer *)malloc(sizeof(struct Buffer));
    if (buffer == NULL) 
        return  NULL;
    buffer->fd = -1;
    buffer->flag = buffer->recvindex = buffer->sendindex = 0;
    memset(buffer->buff, 0, BUFSIZE);
    return buffer;
}

void FreeBuffer(struct Buffer *buffer) {
    free(buffer);
}




char ch_char(char c) {
    if (c >= 'a' && c <= 'z')
        return c - 32;
    return  c;
}

int RecvToBuffer(int fd, struct Buffer *buffer) {
    int recv_num;
    while (1) {
        char buff[BUFSIZE] = {0};
        recv_num = recv(fd, buff, sizeof(buff), 0);
        if (recv_num <= 0) break;
        printf("<"L_GREEN"Recv Data"NONE"> : recv data from %d : "L_GREEN"%s"NONE, fd, buff);
        if (buff[recv_num - 1] != 10) printf("\n");
        printf("<"YELLOW"Debug"NONE">Last two char: %d %d\n", buff[recv_num-2], buff[recv_num-1]);
        for (int i = 0; i < recv_num; i++) {
            if (buffer->recvindex < sizeof(buffer->buff))
                buffer->buff[buffer->recvindex++] = ch_char(buff[i]);
            if (buffer->recvindex > 2 && buffer->buff[buffer->recvindex - 1] == 10 && buffer->buff[buffer->recvindex - 3] == 10)
                buffer->flag = 1;
        }
    }
    if (recv_num < 0) {
        if (errno == EAGAIN)
            return 0;
        return -1;
    } else if (recv_num == 0) {
        return 1;
    }
}

int SendFromBuffer(int fd, struct Buffer *buffer) {
    int send_num;
    while (buffer->sendindex < buffer->recvindex){
        printf("<"RED"Send Data"NONE"> : Send data to %d.\n", fd);
        send_num = send(fd, buffer->buff + buffer->sendindex, buffer->recvindex - buffer->sendindex, 0);
        if (send_num < 0) {
            if (errno == EAGAIN)
                return 0;
            buffer->fd = -1;
            return -1;
        }
        buffer->sendindex += send_num;
    }
    if (buffer->sendindex == buffer->recvindex)
        buffer->sendindex = buffer->recvindex = 0;
    buffer->flag = 0;
    return 0;
}

int main(int argc, char ** argv) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s port!\n", argv[0]);
        exit(1);
    }
    int server_listen, fd, max_fd;
    if ((server_listen = socket_create(atoi(argv[1]))) < 0) {
        perror("socket_create");
        exit(1);
    }
    struct Buffer *buffer[CLIENTSIZE];    
    
    for (int i = 0; i < CLIENTSIZE; i++) {
        buffer[i] = AllocBuffer();
    }

    make_nonblock(server_listen);

    fd_set rfds, wfds, efds;
    max_fd = server_listen;

    buffer[server_listen]->fd = server_listen;

    while (1) {
        FD_ZERO(&rfds);
        FD_ZERO(&wfds);
        FD_ZERO(&efds);

        FD_SET(server_listen, &rfds);

        printf("<"L_BLUE"Select Start"NONE"> : A new turn for Select.\n");
        printf("<"PINK"Add rfds"NONE">: Set server_listern into rfds!\n");
        for (int i = 0; i < CLIENTSIZE; i++) {
           if (buffer[i]->fd == server_listen) continue;
            if (buffer[i]->fd > 0) {
                if (max_fd < buffer[i]->fd) max_fd =buffer[i]->fd;
                FD_SET(buffer[i]->fd, &rfds);
                printf("<"PINK"Add rfds"NONE">: Set %d into rfds!\n", buffer[i]->fd);
                if (buffer[i]->flag == 1) { 
                    FD_SET(buffer[i]->fd, &wfds);
                    printf("<"L_PINK"Add wfds"NONE">: Set %d into rfds!\n", buffer[i]->fd);
                }
            }
        }

        if (select(max_fd + 1, &rfds, &wfds, NULL, NULL) < 0) {
            perror("select");
            return 1;
        }

        printf("<"L_BLUE"Select Return"NONE">Select Return Success.\n");
        if (FD_ISSET(server_listen, &rfds)) {
            printf("<"L_YELLOW"Connect Request"NONE"> : New Client Request for Login.\n");
            if ((fd = accept(server_listen, NULL, NULL)) < 0 ) {
                perror("accept");
                return 1;
            }
            printf("<"GREEN"Connect Success"NONE"> : Login Success with %d\n", fd);
            if (fd > CLIENTSIZE) {
                printf("Too many clients!\n");
                close(fd);
            } else {
                make_nonblock(fd);
                if (buffer[fd]->fd == -1)
                    buffer[fd]->fd = fd;
            }
        }

        for (int i = 0; i <= max_fd; i++) {
            int retval = 0;
            if (i == server_listen || buffer[i]->fd < 0) continue;
            if (FD_ISSET(buffer[i]->fd, &rfds)) {
                retval = RecvToBuffer(i, buffer[i]);
            }
            if (retval == 0 && FD_ISSET(buffer[i]->fd, &wfds)) {
                retval = SendFromBuffer(i, buffer[i]);
            } 
            if (retval) {
                printf("Logout !\n");
                buffer[i]->fd = -1;
                close(i);
            }
        }
    }

    return 0;
} 
```

```c
编译的命令    gcc server.c ../common/common.c ../common/tcp_server.c -lpthread -o server
```

### 5.使用select+自定义buffer实现echo服务器

```c
/*************************************************************************
        > File Name: server.c
        > Author: 
        > Mail: 
        > Created Time: Tue 07 Apr 2020 06:40:01 PM CST
 ************************************************************************/

#include "../common/color.h"
#include "../common/common.h"
#include "../common/tcp_server.h"
#include "../common/head.h"

#define CLIENTSIZE 50
#define BUFSIZE 4096


struct  Buffer{
    int fd;
    char buff[BUFSIZE];
    int flag;
    int sendindex;
    int recvindex;
};

struct Buffer *AllocBuffer() {
    struct Buffer *buffer =(struct Buffer *)malloc(sizeof(struct Buffer));
    if (buffer == NULL) 
        return  NULL;
    buffer->fd = -1;
    buffer->flag = buffer->recvindex = buffer->sendindex = 0;
    memset(buffer->buff, 0, BUFSIZE);
    return buffer;
}

void FreeBuffer(struct Buffer *buffer) {
    free(buffer);
}




char ch_char(char c) {
    if (c >= 'a' && c <= 'z')
        return c - 32;
    return  c;
}

int RecvToBuffer(int fd, struct Buffer *buffer) {
    int recv_num;
    while (1) {
        char buff[BUFSIZE] = {0};
        recv_num = recv(fd, buff, sizeof(buff), 0);
        if (recv_num <= 0) break;
        printf("<"L_GREEN"Recv Data"NONE"> : recv data from %d : "L_GREEN"%s"NONE, fd, buff);
        if (buff[recv_num - 1] != 10) printf("\n");
        printf("<"YELLOW"Debug"NONE">Last two char: %d %d\n", buff[recv_num-2], buff[recv_num-1]);
        for (int i = 0; i < recv_num; i++) {
            if (buffer->recvindex < sizeof(buffer->buff))
                buffer->buff[buffer->recvindex++] = ch_char(buff[i]);
            if (buffer->recvindex > 2 && buffer->buff[buffer->recvindex - 1] == 10 && buffer->buff[buffer->recvindex - 3] == 10)
                buffer->flag = 1;
        }
    }
    if (recv_num < 0) {
        if (errno == EAGAIN)
            return 0;
        return -1;
    } else if (recv_num == 0) {
        return 1;
    }
}

int SendFromBuffer(int fd, struct Buffer *buffer) {
    int send_num;
    while (buffer->sendindex < buffer->recvindex){
        printf("<"RED"Send Data"NONE"> : Send data to %d.\n", fd);
        send_num = send(fd, buffer->buff + buffer->sendindex, buffer->recvindex - buffer->sendindex, 0);
        if (send_num < 0) {
            if (errno == EAGAIN)
                return 0;
            buffer->fd = -1;
            return -1;
        }
        buffer->sendindex += send_num;
    }
    if (buffer->sendindex == buffer->recvindex)
        buffer->sendindex = buffer->recvindex = 0;
    buffer->flag = 0;
    return 0;
}

int main(int argc, char ** argv) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s port!\n", argv[0]);
        exit(1);
    }
    int server_listen, fd, max_fd;
    if ((server_listen = socket_create(atoi(argv[1]))) < 0) {
        perror("socket_create");
        exit(1);
    }
    struct Buffer *buffer[CLIENTSIZE];    
    
    for (int i = 0; i < CLIENTSIZE; i++) {
        buffer[i] = AllocBuffer();
    }

    make_nonblock(server_listen);

    fd_set rfds, wfds, efds;
    max_fd = server_listen;

    buffer[server_listen]->fd = server_listen;

    while (1) {
        FD_ZERO(&rfds);
        FD_ZERO(&wfds);
        FD_ZERO(&efds);

        FD_SET(server_listen, &rfds);

        printf("<"L_BLUE"Select Start"NONE"> : A new turn for Select.\n");
        printf("<"PINK"Add rfds"NONE">: Set server_listern into rfds!\n");
        for (int i = 0; i < CLIENTSIZE; i++) {
           if (buffer[i]->fd == server_listen) continue;
            if (buffer[i]->fd > 0) {
                if (max_fd < buffer[i]->fd) max_fd =buffer[i]->fd;
                FD_SET(buffer[i]->fd, &rfds);
                printf("<"PINK"Add rfds"NONE">: Set %d into rfds!\n", buffer[i]->fd);
                if (buffer[i]->flag == 1) { 
                    FD_SET(buffer[i]->fd, &wfds);
                    printf("<"L_PINK"Add wfds"NONE">: Set %d into rfds!\n", buffer[i]->fd);
                }
            }
        }

        if (select(max_fd + 1, &rfds, &wfds, NULL, NULL) < 0) {
            perror("select");
            return 1;
        }

        printf("<"L_BLUE"Select Return"NONE">Select Return Success.\n");
        if (FD_ISSET(server_listen, &rfds)) {
            printf("<"L_YELLOW"Connect Request"NONE"> : New Client Request for Login.\n");
            if ((fd = accept(server_listen, NULL, NULL)) < 0 ) {
                perror("accept");
                return 1;
            }
            printf("<"GREEN"Connect Success"NONE"> : Login Success with %d\n", fd);
            if (fd > CLIENTSIZE) {
                printf("Too many clients!\n");
                close(fd);
            } else {
                make_nonblock(fd);
                if (buffer[fd]->fd == -1)
                    buffer[fd]->fd = fd;
            }
        }

        for (int i = 0; i <= max_fd; i++) {
            int retval = 0;
            if (i == server_listen || buffer[i]->fd < 0) continue;
            if (FD_ISSET(buffer[i]->fd, &rfds)) {
                retval = RecvToBuffer(i, buffer[i]);
            }
            if (retval == 0 && FD_ISSET(buffer[i]->fd, &wfds)) {
                retval = SendFromBuffer(i, buffer[i]);
            } 
            if (retval) {
                printf("Logout !\n");
                buffer[i]->fd = -1;
                close(i);
            }
        }
    }

    return 0;
} 
```

### 6.`poll`（讲解）(man手册)

#### 6.1 poll函数概述

select() 和 poll() 系统调用的本质一样，poll() 的机制与 select() 类似，与 select() 在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是 poll() 没有最大文件描述符数量的限制（但是数量过大后性能也是会下降）。poll() 和 select() 同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。

#### 6.2 poll()函数介绍

`int poll(struct pollfd *fds, nfds_t nfds, int timeout);
功能：监视并等待多个文件描述符的属性变化`

##### 6.2.1参数：

`fds：指向一个结构体数组的第0个元素的指针，每个数组元素都是一个struct pollfd结构，用于指定测试某个给定的fd的条件`

`struct pollfd{
	int fd;			//文件描述符
	short events;	//等待的事件
	short revents;	//实际发生的事件
};`
`fds结构体参数说明：`

`fd：每一个 pollfd 结构体指定了一个被监视的文件描述符，可以传递多个结构体，指示 poll() 监视多个文件描述符。`

`events：指定监测fd的事件（输入、输出、错误），每一个事件有多个取值，如下：`

![img](https://img-blog.csdn.net/20180917154157899?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NreXBlbmc1Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

`revents：revents 域是文件描述符的操作结果事件，内核在调用返回时设置这个域。events 域中请求的任何事件都可能在 revents 域中返回.`

`注意：每个结构体的 events 域是由用户来设置，告诉内核我们关注的是什么，而 revents 域是返回时内核设置的，以说明对该描述符发生了什么事件`

`nfds：用来指定第一个参数数组元素个数`

`timeout：指定等待的毫秒数，无论 I/O 是否准备好，poll() 都会返回.`

![img](https://img-blog.csdn.net/20180917154328554?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NreXBlbmc1Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 6.3返回值：

`成功时，poll() 返回结构体中 revents 域不为 0 的文件描述符个数；如果在超时前没有任何事件发生，poll()返回 0；`

`失败时，poll() 返回 -1，并设置 errno 为下列值之一：`

`EBADF：一个或多个结构体中指定的文件描述符无效。`
`EFAULT：fds `指针指向的地址超出进程的地址空间。``
EINTR：请求的事件之前产生一个信号，调用可以重新发起。
EINVAL：nfds 参数超出 PLIMIT_NOFILE 值。
ENOMEM：可用内存不足，无法完成请求。``

### 7.使用poll实现echo服务器

```c
/*************************************************************************
        > File Name: thread_poll_echo.c
        > Author: 
        > Mail: 
        > Created Time: Tue 07 Apr 2020 06:40:01 PM CST
 ************************************************************************/

#include "../common/color.h"
#include "../common/common.h"
#include "../common/tcp_server.h"
#include "../common/head.h"

#define MAXTASK 100
#define MAXTHREAD 20

char ch_char(char c) {
    if (c >= 'a' && c <= 'z')
        return c - 32;
    return  c;
}


void do_echo(int fd){
    char buf[512] = {0}, ch;
    int ind = 0;
    while (1) {
        if (recv(fd, &ch, 1, 0) <= 0) {
            break;
        }
        if (ind < sizeof(buf)) {
            buf[ind++] = ch_char(ch);
        }
        if (ch == '\n') {
            send(fd, buf, ind, 0);
            ind = 0;
            continue;
        }
    }
}


typedef struct {
    int sum;
    int *fd;
    int head;
    int tail;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
}TaskQueue;

void TaskQueueInit(TaskQueue *queue, int sum) {
    queue->sum = sum;
    queue->fd = calloc(sum, sizeof(int));
    queue->head = queue->tail = 0;
    pthread_mutex_init(&queue->mutex, NULL);
    pthread_cond_init(&queue->cond, NULL);
}

void TaskQueuePush(TaskQueue *queue, int fd) {
    pthread_mutex_lock(&queue->mutex);
    queue->fd[queue->tail] = fd;
    printf(GREEN"<TaskPush> "NONE": %d \n", fd);
    if (++queue->tail == queue->sum) {
        printf(RED"<QueueEnd> "NONE": %d \n", fd);
        queue->tail = 0;
    }
    pthread_cond_signal(&queue->cond);
    pthread_mutex_unlock(&queue->mutex);
}

int TaskQueuePop(TaskQueue *queue) {
    pthread_mutex_lock(&queue->mutex);
    while (queue->tail == queue->head) 
        pthread_cond_wait(&queue->cond, &queue->mutex);
    int fd = queue->fd[queue->head];
    printf(GREEN"<TaskPop> "NONE": %d \n", fd);
    if (++queue->head == queue->sum) { 
        printf(RED"<QueueEnd> "NONE": %d \n", fd);
        queue->head = 0;
    }
    pthread_mutex_unlock(&queue->mutex);
    return fd;
}

void *thread_run(void *arg) {
    pthread_t tid = pthread_self();
    pthread_detach(tid);

    TaskQueue *queue = (TaskQueue *)arg;
    while (1) {
        int fd = TaskQueuePop(queue);
        do_echo(fd);
    }
}

int main(int argc, char **argv){
    if (argc != 2) {
        fprintf(stderr, "Usage: %s port!\n", argv[0]);
        exit(1);
    }
    int port, server_listen, fd;
    port = atoi(argv[1]);

    if ((server_listen = socket_create(port)) < 0) {
        perror("socket_create");
        exit(1);
    }
    TaskQueue queue;
    TaskQueueInit(&queue, MAXTASK);
    pthread_t *tid = (pthread_t *)calloc(MAXTHREAD, sizeof(pthread_t));

    for (int i = 0; i < MAXTHREAD; i++) {
        pthread_create(&tid[i], NULL, thread_run, (void *)&queue);
    }

    while (1)  {
        if ((fd = accept(server_listen, NULL, NULL)) < 0) {
            perror("accept");
            exit(1);
        }
        printf(BLUE"<Login> "NONE": %d \n", fd);
        TaskQueuePush(&queue, fd);
    }

    return 0;
}
```



```c
/*************************************************************************
        > File Name: poll_echo
        > Author: suyelu
        > Mail: suyelu@haizeix.com
        > Created Time: Tue 07 Apr 2020 06:40:01 PM CST
 ************************************************************************/

#include "../common/color.h"
#include "../common/common.h"
#include "../common/tcp_server.h"
#include "../common/head.h"

#define POLLSIZE 10
#define BUFSIZE 512

char ch_char(char c) {
    if (c >= 'a' && c <= 'z')
        return c - 32;
    return  c;
}

int main(int argc, char ** argv) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s port!\n", argv[0]);
        exit(1);
    }
    int server_listen, fd;
    if ((server_listen = socket_create(atoi(argv[1]))) < 0) {
        perror("socket_create");
        exit(1);
    }
    
    struct pollfd event_set[POLLSIZE];

    for (int i = 0; i < POLLSIZE; i++) {
        event_set[i].fd = -1;
    }
    event_set[0].fd = server_listen;
    event_set[0].events = POLLIN;

    while (1) {
        int retval;
        if ((retval = poll(event_set, POLLSIZE, -1)) < 0) {
            perror("poll");
            return 1;
        }
        if (event_set[0].revents & POLLIN) {
            if ((fd = accept(server_listen, NULL, NULL)) < 0) {
                perror("accept");
                continue;
            }
            retval--;
            int i;
            for (i = 1; i < POLLSIZE; i++) {
                if (event_set[i].fd < 0) {
                    event_set[i].fd = fd;
                    event_set[i].events = POLLIN;
                    break;
                }
            }
            if (i == POLLSIZE) {
                printf("Too many clients!\n");
                close(fd);
            }
        }
        for (int i = 1; i < POLLSIZE; i++) {
            if (event_set[i].fd < 0) continue;
            if (event_set[i].revents & (POLLIN | POLLHUP | POLLERR)) {
                retval--;
                char buff[BUFSIZE] = {0};
                if (recv(event_set[i].fd, buff, BUFSIZE, 0) > 0) {
                    printf("Recv: %s \n", buff);
                    for (int i = 0; i < strlen(buff); i++) {
                        buff[i] = ch_char(buff[i]);
                    }
                    send(event_set[i].fd, buff, strlen(buff), 0);
                } else {
                    close(event_set[i].fd);
                    event_set[i].fd = -1;
                }
            }
            if (retval <= 0) break;
        }
    } 
    return 0;
} 
```

### 8.`epoll讲解`(man手册)

#### 8.2 `epoll的API机制`

``	epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。
	epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered）,这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。``
`1.epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。`
`2.epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered）,这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。`


`cat查看一个进程打开socket描述符上限
cat /proc/sys/fs/file-max
如有需要，可以通过修改配置文件的方式修改上限值
sudo vi /etc/security/limits.conf`
`在文件尾部写入以下配置，soft软限制，hard硬限制。如下：
soft nofile 65536
hard nofile 100000`

`epoll API函数
1.创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数，跟内存大小有关。
#include <sys/epoll.h>
int epoll_create(int size) size:监听数目`

`2.控制某个epoll监控的文件描述符上的事件：注册 修改 删除
int epoll_ctl(int epfd,int fd,struct epoll_event *event)
epfd: 为epoll_create的句柄
op: 表示动作 用三个宏来表示：
EPOLL_CTL_ADD(注册新的fd到epfd),
EPOLL_CTL_MOD(修改已经注册的fd的监听事件)
EPOLL_CTL_DEL(从epfd删除一个fd);
event:告诉内核需要监听的事件`

`struct epoll_event{
__uint32_t events;/*Epoll events*/
epoll_data_t data;//
}`
`该函数的作用就是将要监听的节点挂到树上``

------------------------------------------------


```c
/*************************************************************************
        > File Name: epoll_echo.c
        > Author: suyelu
        > Mail: suyelu@haizeix.com
        > Created Time: Sat 11 Apr 2020 08:24:48 PM CST
 ************************************************************************/
#include <sys/epoll.h>
#define MAX_EVENTS 10
#include "../common/head.h"
#include "../common/tcp_server.h"
#include "../common/common.h"
#define BUFFSIZE 512

int main(int argc, char **argv) {
    struct epoll_event ev, events[MAX_EVENTS];
    int listen_sock, conn_sock, nfds, epollfd;
    char buff[BUFFSIZE] = {0};
    if (argc != 2) exit(1);
    listen_sock = socket_create(atoi(argv[1]));
/* Code to set up listening socket, 'listen_sock',
   (socket(), bind(), listen()) omitted */
    epollfd = epoll_create1(0);
    if (epollfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }

    ev.events = EPOLLIN;
    ev.data.fd = listen_sock;

    if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {
        perror("epoll_ctl: listen_sock");
        exit(EXIT_FAILURE);
    }

    for (;;) {
        nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);
        
        if (nfds == -1) {
            perror("epoll_wait");
            exit(EXIT_FAILURE);
        }

        for (int n = 0; n < nfds; ++n) {
            if (events[n].data.fd == listen_sock) {
                conn_sock = accept(listen_sock, NULL, NULL);
                if (conn_sock == -1) {
                    perror("accept");
                    exit(EXIT_FAILURE);
                }
                make_nonblock(conn_sock);
                ev.events = EPOLLIN | EPOLLET;
                ev.data.fd = conn_sock;

                if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock, &ev) == -1) {
                    perror("epoll_ctl: conn_sock");
                    exit(EXIT_FAILURE);
                }
            } else {
                //do_use_fd(events[n].data.fd);
                if (events[n].events & (EPOLLIN | EPOLLHUP | EPOLLERR)) {
                    memset(buff, 0, sizeof(buff));
                    if (recv(events[n].data.fd, buff, BUFFSIZE, 0) > 0) {
                        printf("recv: %s", buff);
                        for (int i = 0; i < strlen(buff); i++) {
                            if (buff[i] >= 'a' && buff[i] <= 'z') buff[i] -= 32;
                        }
                        send(events[n].data.fd, buff, strlen(buff), 0);
                    } else {
                        if (epoll_ctl(epollfd, EPOLL_CTL_DEL, events[n].data.fd, NULL) < 0) {
                            perror("epoll_ctrl");
                        }
                        close(events[n].data.fd);
                        printf("Logout!\n");
                    }
                }
            }
        }
    }
return 0;
}
```

